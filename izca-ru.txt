===========================================================================================================
Обстоятельное руководство по компонентной архитектуре Zope
===========================================================================================================

:Автор: Baiju M
:Версия: 0.5.8
:Печатный экземпляр на англ. языке: `http://www.lulu.com/content/1561045
                    <http://www.lulu.com/content/1561045>`_
:PDF-версия оригинала на англ.: `http://www.muthukadan.net/docs/zca.pdf
                  <http://www.muthukadan.net/docs/zca.pdf>`_
:Перевод: Черкашин Евгений Александрович
:Версия перевода: 0.1


Copyright (C) 2007,2008,2009 Baiju M <baiju.m.mail AT gmail.com>.

Разрешается копировать, распространять и/или вносить изменения в этот
документ при соблюдении условий лицензии GNU Free Documentation
License, версия 1.2 или (по вашему желанию) какой-либо поздней версии,
официально опубликованной Фондом свободного программного обеспечения
(Free Software Foundation).

Исходный код программ, приведенный в этом документе, распространяется
при соблюдении положений лицензии Zope Public License, версии 2.1
(ZPL).

ИСХОДНЫЙ КОД ПРОГРАММ В ЭТОМ ДОКУМЕНТЕ И САМ ДОКУМЕНТ ПЕРЕДАЮТСЯ
ПОЛЬЗОВАТЕЛЮ "КАК ЕСТЬ" ("AS IS") AND ANY AND ALL EXPRESS OR IMPLIED
WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND
FITNESS FOR A PARTICULAR PURPOSE.

.. sidebar:: Благодарности

  Много людей помогли мне написать эту книгу.  Первоначальный
  манускрипт отрецензирован моим коллегой Брэдом Алленом (Brad Allen).
  Когда я объявил о книге в моем блоге, общественность вдохновила меня
  продолжить ее совершенствование.  Кент Тенни (Kent Tenney) творчески
  обработал практически все разделы книги, кроме того, он переписал
  основной пример - приложение.  Многие присылали мне замечания,
  исправления ошибок и недочетов, в том числе Лоренсо Санчеса (Lorenzo Gil
  Sanchez), Михаэль Гаубенвалнера (Michael Haubenwallner), Нандо
  Куинтан (Nando Quintana), Стефани Кляйн (Stephane Klein), Тим Кук
  (Tim Cook), Камал Джилл (Kamal Gill) и Томас Герв (Thomas
  Herve).  Лоренсо перевел книгу на испанский язык, а Стефани на
  французский.  Огромное всем спасибо!

  При переводе на русский язык неоценимую помощь оказал Антон
  Кочнев. Спасибо ему за это.

.. contents::
.. .. sectnum::

Приступая к работе
------------------



Введение
~~~~~~~~

Разработка больших программных систем практически всегда является
сложным и трудоемким занятием, где объектно-ориентированный подход к
анализу, проектированию и реализации (программированию) достаточно
хорошо себя зарекомендовал.  Проектирование и разработка программного
обеспечения, основывающиеся на компонентах, становятся все более и
более популярными подходом.  Компонентный подход и unit-тестирование
позволяет достаточно просто разрабатывать и поддерживать программные
системы.  Существует много различных программных инфраструктур и
инструментариев разработчика (frameworks, фреймворков), реализующих
компонентное проектирование в разных языках и средах программирования,
некоторые даже не зависят от какой-либо конкретной среды разработки.
Примерами выступают COM, разработанный Microsoft, и XPCOM - Mozilla.

**Компонентная архитектура Zope (Zope Component Architecture, ZCA)** -
это одна из таких инфраструктур, разработанной для в среды
программирования Python, реализующих компонентный подход к
проектированию и программированию.  Он позволяет разрабатывать большие
программные системы в среде программирования Python.  И делает это
совсем не плохо.  Компонентная архитектура ZCA не требует для своего
использования сервера приложений Zope, ZCA может использоваться в
разработке любого Python-приложения.  Справедливо было бы назвать ZCA
`компонентной архитектурой Python` (Python Component Architecture).

ZCA позволяет использовать объекты Python эффективно.  `Компоненты` -
это объекты, которые легко использовать повторно, а к их интерфейсам
можно получить полный доступ во время исполнения программы
(introspection).  `Интерфейс` - это объект, который описывает как
следует взаимодействовать с конкретной компонентой.  Другими словами,
компонента `[обслуживает, оснащает, оборудует] сервисы` (provide), определенные в
интерфейсе.  Компонента `реализуется` (implemented) в виде класса
(class) или другого исполняемого объекта (callable object).  И не
важно, как реализована эта компонента, а вот что важно - это то, что
она соответствует `требованиям`, определенным в интерфейсе (interface
contract).  При помощи ZCA сложность системы распределяется между
множеством кооперирующихся компонент.  Механизм такой кооперации
обеспечивается двумя базовыми разновидностями компонент в ZCA:
`адаптером` (adapter) и `утилитой` (utility).

ZCA распределен между тремя базовыми пакетами:

  - ``zope.interface``, используемый для определения (задания)
    интерфейсов компонент.

  - ``zope.event``, обеспечивающего поддержку простого механизма
    инициирования и обработки событий.

  - ``zope.component``, обеспечивающего порождение и регистрацию
    компонент, а также их предоставление приложению по запросу.

Обращаю внимание, что ZCA сам по себе не является компонентой и не
состоит из них, ZCA скорее механизм и библиотека для создания,
регистрации и обеспечения доступа к зарегистрированным компонентам.  В
продолжение к предыдущему замечанию, `Адаптер` - это, как правило,
обычный класс Python (или фабрика классов (factory), в общем случае),
а `утилита` - это обычный запускаемый объект в среде исполнения Python.

Среда ZCA разрабатывается как одно из направлений развития проекта
Zope 3.  Как сказано выше ZCA является чисто питоновским фреймворком,
и может использоваться в любых приложениях Python.  В настоящее время
ZCA активно используется в проектах Zope 3, Zope 2 и Grok.  Существуют
и другие приложения, в т.ч. и неинтернет-приложения, использующие ZCA
[#projects]_.

.. [#projects] http://wiki.zope.org/zope3/ComponentArchitecture

Краткая история проекта
~~~~~~~~~~~~~~~~~~~~~~~

Проект ZCA начался в 2001 году и был частью проекта Zope 3.  Причиной
его появления послужил анализ опыта, полученного при разработке
комплексных программных систем на основе Zope 2.  Джим Фултон (Jim
Fulton) стал лидером проекта.  Сообщество разработчиков, внесших свой
вклад в дизайн и реализацию ZCA, возглавляется известными инженерами:
Стефаном Рихтером (Stephan Richter), Филиппом фон Вайтершаусеном
(Philipp von Weitershausen), Гвидо ван Россумом (Guido van Rossum),
известным также как *Python BDFL*, Тресом Сивером (Tres Seaver),
Филиппом Дж Эби (Phillip J Eby) и Мартином Фаассеном (and Martijn
Faassen).

В самом начале в ZCA были определены дополнительные компоненты -
`сервисы` (services) и `представления` (views), но в процессе
разработки оказалось, что `утилиты` заменяют полностью сервисы, а
`мультиадаптеры` - представления.  В настоящее время ZCA включает в
себя совсем небольшое количество базовых разновидностей компонент:
`утилиты`, `адаптеры`, `подписчики` (абоненты) (subscribers) и
`обработчики` (handlers).  На самом деле `подписчики` и
`обработчики` - это два особых вида адаптеров.

В процессе подготовки версии Zope 3.2 Джим Фултон предложил
значительно упростить фреймворк ZCA [#proposal]_.  В результате этого
появился новый общий интерфейс `IComponentRegistry`, позволяющий
регистрировать как локальные так и глобальные компоненты.

.. [#proposal] http://wiki.zope.org/zope3/LocalComponentManagementSimplification

В результате от пакета ``zope.component`` перестал зависеть достаточно
длинный список других пакетов, при этом оставшиеся зависимости не
относились напрямую к разработке приложений Zope 3.  На конференции
PyCon 2007 Джим Фултон предложил включить в пакет setuptools функцию
`extras_require`, чтобы сильнее изолировать базовый набор функций ZCA
от вспомогательных функций [#extras]_.

.. [#extras] http://peak.telecommunity.com/DevCenter/setuptools#declaring-dependencies

В марте 2009, Трес Сивер окончательно устранил зависимости пакета от
``zope.deferredimport`` и ``zope.proxy``.

Теперь проект ZCA является независимым со своим собственным планом
выпусков и репозиторием Subversion.  Проект как и прежде является
составляющей частью среды разработки интернет-приложений Zope
[#framework]_.  При этом ошибки и недочеты, выявляемые в ZCA, все еще
публикуются на сайте системы отслеживания ошибок проекта Zope 3
[#bugs]_.  Кроме того, основной список рассылки `zope-dev` все еще
используется для информационного обмена разработчиками ZCA
[#discussions]_.  Есть еще другой список рассылки, предназначенный для
пользователей Zope 3, `zope3-users`, в котором можно получить ответы
на вопросы о ZCA [#z3users]_.

.. [#framework] http://docs.zope.org/zopeframework/
.. [#bugs] https://bugs.launchpad.net/zope3
.. [#discussions] http://mail.zope.org/mailman/listinfo/zope-dev
.. [#z3users] http://mail.zope.org/mailman/listinfo/zope3-users

Установка
~~~~~~~~~

Пакеты ``zope.component``, ``zope.interface`` и ``zope.event``
являются ядром Компонентной архитектуры Zope.  Они содержат
технические средства для определения, регистрации и поиска компонент.
Пакет ``zope.component`` и пакеты, зависящие от него, доступны в
формате egg на сайте Python Package Index (PyPI) [#pypi]_.

.. [#pypi] Repository of Python packages: http://pypi.python.org/pypi

Проще всего устанавливать ``zope.component`` и его зависимые пакеты
при помощи `easy_install` [#easyinstall]_ ::

  $ easy_install zope.component

.. [#easyinstall] http://peak.telecommunity.com/DevCenter/EasyInstall

Эта команда загружает ``zope.component``, его зависимые пакеты с сайта
PyPI и устанавливает все как библиотеки интерпретатора Python.

С другой стороны, можно загрузить ``zope.component`` и зависящие от
него пакеты с сайта PyPI и, затем, самостоятельно установить их.
Установку пакетов следует производить в порядке, описанном ниже.  В
операционной системе Windows необходимо загрузить двоичные сборки
следующих пакетов.

  1. ``zope.interface``
  2. ``zope.event``
  3. ``zope.component``

Для установки загруженных пакетов можно, как и раньше, использовать
команду ``easy_install``, при этом передавая в качестве параметра
устанавливаемые пакеты, аналогично двоичным egg-пакетам.  Команда
позволяет все пакеты указывать одновременно в одной командной
строке. ::

  $ easy_install /path/to/zope.interface-3.x.x.tar.gz
  $ easy_install /path/to/zope.event-3.x.x.tar.gz
  $ easy_install /path/to/zope.component-3.x.x.tar.gz


Кроме того, все пакеты можно разархивировать и установить по одному,
например::

  $ tar zxvf /path/to/zope.interface-3.x.x.tar.gz
  $ cd zope.interface-3.x.x
  $ python setup.py build
  $ python setup.py install

Этот набор команд устанавливает ZCA как общесистемную библиотеку
Python в директорий ``site-packages``, что, иногда, создает некоторые
проблемы.  Джим Фултон в списке рассылки Zope 3 не рекомендовал
устанавливать пакеты в общесистемной библиотеке Python
[#systempython]_.  Их рекомендуется устанавливать в виртуальное
окружение при помощи программы ``virtualenv`` и/или пакета
``zc.buildout``.  Такой подход дает больше возможностей для
экспериментов с пакетами Python.  Кроме того, в виртуальном окружении
удобно развертывать готовые приложения.

.. [#systempython] http://article.gmane.org/gmane.comp.web.zope.zope3/21045

Подготовка виртуального окружения
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Существует множество популярных подходов к настройке изолированного
виртуального окружения для среды программирования Python, удобного для
разработки приложений.  Наиболее популярные — это пакет
``virtualenv``, разработанный Яном Бикингом (Ian Biking) и пакет
``zc.buildout``, разработанный Джимом Фултоном.  Оба этих пакета можно
использовать одновременно.


**virtualenv**

Пакет ``virtualenv`` устанавливается при помощи команды
``easy_install``::

  $ easy_install virtualenv

Затем создается новое окружение::

  $ virtualenv --no-site-packages myve

Команда создает новое окружение в директории ``myve``.  Теперь в
директории ``myve`` можно установить ``zope.component`` и зависимые
пакеты при помощи команды ``easy_install``, если запустить ее с
указанием директории ``myve/bin`` в качестве префикса команды ::

  $ cd myve
  $ ./bin/easy_install zope.component

Теперь можно попробовать импортировать пакеты ``zope.interface`` и
``zope.component`` из командной строки интерпретатора ``python``, который
находится в директории ``myve/bin``::

  $ ./bin/python

После запуска Python выведет на экран его стандартное приглашение
(prompt) для ввода команд и выражений.  В командной строке мы
будем выполнять программный код, приводимый далее в книге .


**zc.buildout**

При помощи пакета ``zc.buildout`` и `рецепта` (recipe)
``zc.recipe.egg`` создаются специализированные версии интерпретатора
Python с встроенными egg-пакетами.  Для этого необходимо установить
пакет ``zc.buildout`` при помощи команды ``easy_install``, имеет смысл
это сделать также внутри виртуального окружения.

Чтобы создать новое buildout-окружение для проведения экспериментов с
egg-пакетами Python, сначала создайте для него новый директорий, и,
затем, создайте в нем так называемое buildout-окружение при помощи
команды ``buildout init``::

  $ mkdir mybuildout
  $ cd mybuildout
  $ buildout init

Теперь директорий ``mybuildout`` новое buildout-окружение.  Настройки
окружения по умолчанию хранятся в файле `buildout.cfg`.  Сначала в нем
содержится следующий текст::

  [buildout]
  parts =

Надо внести в настройки следующие изменения::

  [buildout]
  parts = py

  [py]
  recipe = zc.recipe.egg
  interpreter = python
  eggs = zope.component

Запуск команды ``buildout`` из директория ``mybuildout/bin`` (без
аргументов) создаст копию интерпретатора Python в директории
``mybuildout/bin``::

  $ ./bin/buildout
  $ ./bin/python

Последняя команда выведет на экран приглашение Python, в котором
запускается приводимый далее в книге программный код.

Пример задачи
-------------



Введение
~~~~~~~~

Рассмотрим приложение, предназначенное для регистрации постояльцев в
гостинице.  В среде Python его можно реализовать множеством способов.
Сначала кратко рассмотрим процедурный подход, затем перейдем к
объектно-ориентированному программированию.  После анализа результатов
дизайна и реализации задачи при помощи объектно-ориентированного
подхода, рассмотрим как данная задача решается при помощи классических
шаблонов проектирования (паттернов проектирования, design patterns)
`адаптер` и `интерфейс`.  Таким образом у вас появится начальное
представление о возможностях Компонентой архитектуры Zope.

Процедурный подход
~~~~~~~~~~~~~~~~~~

Модуль хранения данных - очень важный момент в разработке приложений.
В рассматриваемом примере будем использовать словарь (dictionary)
языка Python в качестве такой системы хранения.  Каждой записи
соответствует сгенерированный уникальный ключ (ID).  Ключ
ассоциируется со значением, которое тоже будет словарем и будет
содержать данные о бронировании комнаты в гостинице.

  >>> bookings_db = {} #key - уникальный идентификатор (ID), value -
  данные брони

В реализации системы нужна, как минимум, функция, которой передаются
данные о бронировании, и функция, которая генерирует уникальное
значение ID ключа для ассоциации с данными брони.

Генерировать значения ключа можно следующим образом::

  >>> def get_next_id():
  ...     db_keys = bookings_db.keys()
  ...     if db_keys == []:
  ...         next_id = 1
  ...     else:
  ...         next_id = max(db_keys) + 1
  ...     return next_id

Как видно из программы, реализация функции `get_next_id` достаточно
простая.  Функция получает из словаря список ключей. Если список пуст,
то это значит, что произошло первое бронирование комнаты в гостинице,
функция возвращает `1`.  Если список не пуст, то добавить `1` к
максимальному значению ключей и вернуть полученное значение.

Теперь созданную выше функцию встроим в программный код, создающий
записи в словаре bookings_db::

  >>> def book_room(name, place):
  ...     next_id = get_next_id()
  ...     bookings_db[next_id] = {
  ...     'name': name,
  ...     'room': place
  ...     }

В хранилище необходимо учесть, что может потребоваться сохранять и
другие данные, такие как следующие:

- номера телефонов,
- особенности бронирования,
- способы платежей клиентов,
- ...

Необходимо реализовать следующие функции:

- отмена бронирования,
- уточнение бронирования,
- оплата проживания,
- постоянное хранение данных и доступ к ним,
- обеспечение защиты информации в хранилище,
- ...

Процедурная реализация данного примера требует создания большого числа
функций, обменивающихся информацией друг с другом.  Изменения
требований к дизайну и реализации, добавление новых функций, создает
условия к усложнению процесса поддержки программного кода.  Кроме
того, становится сложнее выявлять и исправлять ошибки.

На этом закончим обсуждение процедурного подхода. Обеспечивать
постоянное хранение данных, гибкость дизайна и
возможность тестирования программного кода, как правило, проще,
используя объекты.

Объектно-ориентированный подход
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. ??? что, на самом деле должен, должен излагать этот абзац:
а) "о создании объекта, обрабатывающего регистрацию" или же
б) "о создании класса, обрабатывающего регистрацию"?

В объектно-ориентированном подходе появляются `классы`, которые служат
для инкапсуляции данных и программного кода, обрабатывающего эти
данные в рамках одного абстрактного типа данных.

Основным классом в рассматриваемом примере является ``FrontDesk``.
Класс ``FrontDesk``, а также другие классы, с которыми он
взаимодействует, обеспечивают обработку данных об отеле.  При помощи
`экземпляров` класса ``FrontDesk`` моделируется конкретный
бизнес-процесс в конкретном отеле.

Как правило, консолидация программного кода и данных в объектах
обеспечивает, в конечном счете, такой дизайн программной системы,
который является более понятным, его проще тестировать и изменять.

Рассмотрим детали реализации класса ``FrontDesk``::

  >>> class FrontDesk(object):
  ...
  ...     def book_room(self, name, place):
  ...         next_id = get_next_id()
  ...         bookings_db[next_id] = {
  ...         'name': name,
  ...         'place': place
  ...         }

Далее, задачей объекта `frontdesk` (экземпляра класса `FrontDesk`)
является обработка заявок на бронирование.  Его используют следующим
образом::

  >>> frontdesk = FrontDesk()
  >>> frontdesk.book_room("Jack", "Bangalore")

В реальности в каждый проект необходимо вносить изменения.  Например,
если руководство отеля решило, что каждый клиент должен при
бронировании сообщать свой номер телефона, то программый код класса
необходимо изменить.

Требование руководства можно удовлетворить добавив еще один аргумет к
методу `book_room`, кроме того, новое ключевое значение добавляется к
словарю::

  >>> class FrontDesk(object):
  ...
  ...     def book_room(self, name, place, phone):
  ...         next_id = get_next_id()
  ...         bookings_db[next_id] = {
  ...         'name': name,
  ...         'place': place,
  ...         'phone': phone
  ...         }

В результате изменилась структура базы данных.

Теперь появилась необходимость во всей программе откорректировать
вызов метода `book_room` - добавить новый аргумент `phone`.  Если же
инкапсулировать данные о постояльце в объекте `guest`, и использовать
только его при регистрации, то указанные выше изменения будут
минимизированы или совсем будут не нужны.  Изменения в объекте
`guest`, например, добавление поля `phone` не вызовет необходимости в
тотальной корректировки кода.

В результате получилось следующее::

  >>> class FrontDesk(object):
  ...
  ...     def book_room(self, guest):
  ...         next_id = get_next_id()
  ...         bookings_db[next_id] = {
  ...         'name': guest.name,
  ...         'place': guest.place,
  ...         'phone': guest.phone
  ...         }

Не смотря на полученный результат, программный код все таки придется
корректировать, чтобы отразить изменяющиеся во времени требования
заказчика.  Этого избежать практически никогда невозможно.  Задача
разработчика состоит в том, чтобы создать такой дизайн программы,
который не требовал бы значительных изменения программного кода при
изменении требований.  Это свойство дизайна называется
`Ремонтопригодность` (maintainability).  Чем меньше нужно вносить
изменений тем выше ремонтопригодность.

.. note::

  В процессе реализации программы (кодирования) очень важно верить в
  то, что вносимые изменения не повлияют на рабостоспособность всего
  приложения.  Существует способ обретения такой уверенности -
  автоматизированное тестирование.  Если под рукой корректный и полный
  набор тестов, а также и система контроля версий можно бесстрашно
  изменять программный код.  Одним из рекомендуемых источников
  информации по этому вопросу явлется книга `Экстримальное
  программирование` Кента Бека (Издательство: Питер, 2002 г., 224
  стр. ISBN 5-94723-032-1).

Итак, добавление объекта `guest` сократило программный код, и, что
более важно, упростило программную систему.  Ее код теперь проще
понять, реструктурировать и поддерживать.

Шаблон проектирования `Адаптер`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В реальных приложениях объект `frontdesk` должен реализовывать еще и
другие функции, например, отмену и изменения бронирования.  В текущей
реализации необходимо передавать объект `guest` объекту `frontdesk`
всякий раз при запуске методов `cancel_booking` и `update_booking`.

Можно избавиться от этого ограничения, если передать объект `guest` в
конструктор FrontDesk.__init__(), и сделав объект `guest` атрибутом
нового экземпляра `FrontDesk`.

  >>> class FrontDeskNG(object):
  ...
  ...     def __init__(self, guest):
  ...         self.guest = guest
  ...
  ...     def book_room(self):
  ...         guest = self.guest
  ...         next_id = get_next_id()
  ...         bookings_db[next_id] = {
  ...         'name': guest.name,
  ...         'place': guest.place,
  ...         'phone': guest.phone
  ...         }
  ...
  ...     def cancel_booking(self):
  ...         guest = self.guest
  ...         #далее следует реализация отмены бронирования ...
  ...
  ...     def update_booking(self):
  ...         guest = self.guest
  ...         #далее следует реализация изменения бронирования ...


.. надо бы включить этот кусок в начало раздела `Адаптеры` когда я
    найду подходящее высказывание из книги о шаблонах, чтобы начать
    раздел `Интерфейсы`.

    Вариант решения, к которому мы пришли, - это известный шаблон
    проектирования `Адаптер` (`Adapter`).  Банда четырех (`Gang of
    Four`), написавших [#patternbook]_, дают такое определение
    адаптера::

    "... (?) Преобразовать интерфейс класса в другой интерфейс, который уже
    известен клиенту.  Адаптеры позволяют взаимодействовать друг с
    другом классам, которые первоначально не должны были из-за
    несовместимых интерфейсов."


Решение, к которому мы пришли, - это всем известный шаблон
проектирования *Адаптер* (*Adapter*). Большинство адаптеров *содержат*
в себе *адаптируемый объект* (*adaptee*)::

  >>> class Adapter(object):
  ...
  ...     def __init__(self, adaptee):
  ...         self.adaptee = adaptee

Этот шаблон чрезвычайно полезен в процессе реализации программного
кода в следствии

- изменений требований заказчика;
- требований к системе хранения данных (ZODB, RDBM, XML ...);
- трамбований к выводу результата (HTML, PDF, plain text ...);
- изменения способа представления исходного текста (ReST, Markdown,
  Textile ...).

В ZCA используются адаптеры, а также *регистраторы компонент*, которые
позволяют настраивать реализацию блоков программного кода на
основе *конфигураций* (*configuration*) компонентов.

Далее, в разделе об адаптерах ZCA, будет продемонстрированы
приемущества использования конфигурирования, в частности,

- возможность переключения между вариантами реализации;
- возможность при необходимости добавлять новые реализации;
- повышается степень использования повторного кода: как
  унаследованного, так и программного кода ZCA.

Кроме того, использование конфигурирования позволяет создавать гибкий,
масштабируемый программный код.  Хотя, конечно, поддержка регистров
компонент добавляет дополнительный уровень сложности приложения.  Если
же приложению никогда не потребуются перечисленные возможности, то,
вероятно, в этом случае ZCA будет мало полезным.

Итак, теперь можно начать изучение Zope Component
Architecture. Начнем с интерфейсов.

Интерфейсы
----------



Введение
~~~~~~~~

В файле README.txt [#readmes]_ в path/to/zope/interface интерфейсы
определяются следующим образом::

    Интерфейсы - это объекты, которые явным образом задают
    (документируют) спецификацию внешнего поведения группы
    объектов. Эти объекты, в свою очередь, `обеспечивают` (provide)
    данные интерфейсы. Интерфейс задает спецификацию поведения при
    помощи

    - Информативной документации в виде питоновских doc-строк;

    - Определений атрибутов и их свойств;

    - Инвариантов - условий, которые должны выполняться во всех
      объектах, обеспечивающих данный интерфейс.

В классической книге по инженерии программного обеспечения `Приемы
объектно-ориентированного проектирования.  Паттерны проектирования`
[#patternbook]_ известной `Банды Четырех` дана следующая рекомендация:
"Программируй, ориентируясь на интерфейс, а не на реализацию".  Определение
формального интерфейса помогает понимать всю систему.  Кроме того,
интерфейсы позволяют использовать все преимущества, предоставляемые
ZCA.

.. [#readmes] Дерево исходных кодов Zope заполнено текстовыми файлами
    README.txt, которые предстаялют собой замечательную документацию
.. [#patternbook] http://en.wikipedia.org/wiki/Design_Patterns

Интерфейс определяет (формально задает) все характеристики, поведение
и предоставляемые возможности объекта.  Интерфейсы описывают *что*
объект может делать, но чтобы узнать *как* он это делает необходимо
изучать уже его реализацию.

Интерфейсам соответствуют синонимы `контракт` и `эскиз` (`чертеж`),
которые задают правовые и архитектурные положения набора спецификаций.

В некоторых современных системах программирования, таких как Java, C#,
VB.NET и т.п., интерфейсы являются явными элементами их языка.  В
языке Python нет таких языковых конструкций, поэтому интерфейсы в ZCA
реализованы при помощи специальных метаклассов.  Интерфейс задается
при помощи наследования этих метаклассов.

Рассмотри пример в классическом стиле *hello world*::

  >>> class Host(object):
  ...
  ...     def goodmorning(self, name):
  ...         """Пожелаем доброго утра постояльцам"""
  ...
  ...         return "Доброе утро, %s!" % name

В классе `Host` определен метод `goodmorning`.  Если у объекта
(экземпляра данного класса) вызвать метод `goodmorning` на экран
выведется сообщение `Доброе утро, ...!` ::

  >>> host = Host()
  >>> host.goodmorning('Jack')
  'Доброе утро, Jack!'

Здесь, ``host`` - это объект (экземпляр), который можно использовать в
основной программе.  Чтобы увидеть детали реализации, необходимо
получить доступ к классу ``Host`` либо через исходный код, либо при
помощи инструментов документирования API [#api]_ .

.. [#api] http://en.wikipedia.org/wiki/Application_programming_interface

Самое время начать использовать интерфейсы ZCA.  Для класса `Host`
интерфейс можно задать следующим образом::

  >>> from zope.interface import Interface

  >>> class IHost(Interface):
  ...
  ...     def goodmorning(guest):
  ...         """Пожелаем доброго утра постояльцам"""

Как видно из примера, интерфейс `IHost` унаследован от
zope.interface.Interface.  На самом деле конструкция выглядит так же
как как питоновский класс, но он задает интерфейс в рамках ZCA.
Приставка ``I`` - это полезное соглашение о форме и способе задания
имен интерфейсов.

Декларация интерфейса
~~~~~~~~~~~~~~~~~~~~~

Мы изучили пример задания (декларации) интерфейса при помощи
``zope.interface`` в предыдущем разделе.  В этом разделе рассмотрим
основные правила более подробно.

Рассмотрим следующий пример декларации интерфейса::

  >>> from zope.interface import Interface
  >>> from zope.interface import Attribute

  >>> class IHost(Interface):
  ...     """Объект host"""
  ...
  ...     name = Attribute("""Название host""")
  ...
  ...     def goodmorning(guest):
  ...         """Пожелаем доброго утра постояльцам"""

Интерфейс ``IHost`` включает два атрибута ``name`` и ``goodmorning``.
Надо сказать, что в языке Python методы также являются атрибутами
класса.  Атрибут ``name`` декларируется при помощи класса
``zope.interface.Attribute``.  Сама декларация атрибута ``name`` в
интерфейсе ``IHost`` не устанавливает ему какого-либо начального
значения.  Идея состоит в том, чтобы указать, что все реализации
интерфейса ``IHost`` будут так или иначе использовать этот атрибут.
Более того, данная декларация никоим образом не задает тип атрибута!
В качестве первого аргумента ``Attribute`` передается строка,
документирующая описываемый атрибут.

Второй атрибут, ``goodmorning``, является методом и задается
синтаксически как функция.  Заметим, что параметр `self` в методе
интерфейса не используется, так как `self`, ссылка на экземпляр
класса, - это деталь реализации класса.  Теперь, если программный
модуль реализует интерфейс ``IHost``, то в его программном коде будут
использованы атрибут ``name`` и метод (функция) ``goodmorning``.
Методу ``goodmorning`` необходимо передавать ровно один параметр.

Теперь изучим как объединять тройку `интерфейс-класс-объект`.  Объект
- это реально функционирующая сущность, объекты являются экземплярами
классов.  Именно интерфейс определяет структуру и внешнее поведение
объекта, а классы - это лишь детали реализации.  Именно по этой
причине программный код реализуется, ориентируясь/задавая интерфейс, а
не на реализацию.

В излагаемой концепции присутствуют еще две терминологические
единицы.  Первая - `обеспечить` (`provide`), вторая - `реализовать`
(`implement`).  Объекты обеспечивают интерфейсы, а классы реализуют
интерфейсы.  Другими словами, объекты обеспечивают интерфейсы, которые
их классы реализуют.  В приведенном выше примере ``host`` (объект)
обеспечивает ``IHost`` (интерфейс), ``Host`` (класс) реализует
``IHost`` (интерфейс).  Один объект может обеспечить несколько
интерфейсов, также как класс может реализовывать несколько
интерфейсов.  Кроме того, в дополнение к реализациям интерфейса в
классе, объекты могут обеспечивать интерфейсы в обход
класса, "на прямую" (directly).

.. note::

  Классы - это детали реализации объектов.  В Python классы сами по
  себе являются исполняемыми (callable) объектами, так почему же не
  дать возможность другим исполняемым объектам реализовывать
  интерфейсы.  И это возможно.   Для любого исполняемого объекта
  можно сообщить ZCA интерфейс и, что этот объект порождает объекты,
  обеспечивающие данный интерфейс.  Такие исполняемые объекты, в общем
  случае, называются `фабриками`.  Функции также являются исполняемыми
  объектами, т.е. они тоже могут реализовывать интерфейсы.

Реализация интерфейсов
~~~~~~~~~~~~~~~~~~~~~~

Чтобы указать, что класс реализует некоторый интерфейс, используется
функция ``zope.interface.implements`` в определении класса.

Рассмотрим пример, здесь класс ``Host`` реализует интерфейс
``IHost``::

  >>> from zope.interface import implements

  >>> class Host(object):
  ...
  ...     implements(IHost)
  ...
  ...     name = u''
  ...
  ...     def goodmorning(self, guest):
  ...         """Пожелаем доброго утра постояльцам"""
  ...
  ...         return "Доброе утро, %s!" % guest

.. note::

  Если вам интересно как работает функция ``implements``, обратитесь в
  блог-пост Джеймса Хенстриджа (James Henstridge)
  (http://blogs.gnome.org/jamesh/2005/09/08/python-class-advisors/) .
  В разделе `adapter` находится функция ``adapts``, которая
  функционирует аналогично функции ``implements``.

Так как класс ``Host`` реализует интерфейс ``IHost``, то экземпляры
класса ``Host`` обеспечивают интерфейс ``IHost``.  В ZCA есть в ряд
средств для интроспекции имеющихся деклараций интерфейсов.  Кроме
того, декларации могут быть сделаны вне определения класса: если не
указывать ``implements(IHost)`` в приведенном выше примере, то после
определения класса ``Host`` данную декларацию можно сделать следующим
образом::

  >>> from zope.interface import classImplements
  >>> classImplements(Host, IHost)

Компонентный подход в рассматриваемом примере
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Итак, вернемся к нашему примеру приложения.  Рассмотрим определение
интерфейса объекта `стол регистрации` (frontdesk)::

  >>> from zope.interface import Interface

  >>> class IDesk(Interface):
  ...     """Стол регистрации, регистрирующий данные о постояльце"""
  ...
  ...     def register():
  ...         """Регистрируем данные постояльца"""
  ...

В начале импортируется класс ``Interface`` из модуля
``zope.interface``.  Каждый подкласс класса ``Interface`` с точки
зрения компонентной архитектуры Zope является определением интерфейса.
Интерфейсы реализуется при помощи классов или любых других исполняемых
(callable) объектов языка Python.

В примере задан интерфейс стола регистрации - ``IDesk``.  Строка,
которая находится сразу под определением интерфейса (строка
документирования), объясняет предназначение интерфейса.  Определение
метода в интерфейсе задает контрактное обязательство (contract)
компоненты - в ней будет реализован одноименный метод.  В определении
метода в интерфейсе не надо указывать первый аргумент `self`, так как
интерфейс не предназначен для порождения экземпляров, т.е. эти
декларации методов никогда не будут выполнены.  Главная задача
интерфейса - спецификация перечня атрибутов и методов, которые должны
быть определены классе, который обязался реализовать данный интерфейс.
Поэтому параметр `self` - это деталь реализации метода в классе, а в
интерфейсе его указывать нет необходимости.

Кроме методов ZCA разрешает в интерфейсе декларировать обычные
атрибуты::

  >>> from zope.interface import Interface
  >>> from zope.interface import Attribute

  >>> class IGuest(Interface):
  ...
  ...     name = Attribute("Имя постояльца")
  ...     place = Attribute("Место размещения постояльца")

Данный интерфейс сообщает, что соответствующие `guest`-объекты
включают два атрибута.  В ZCA в интерфейсах можно задавать
одновременно и атрибуты и методы.  Интерфейсы, как правило,
реализуются при помощи классов и модулей, но можно и при помощи других
объектов.  Например, функция, которая динамически создает и возвращает
компоненты, является таким нетипичным примером реализации интерфейса.

Итак, теперь вам известно, что такое интерфейс, как его задавать и
использовать.  В одном из следующих разделов рассмотрим использование
интерфейсов в спецификации и реализации компонент-адаптеров.

Интерфейсы-маркеры
~~~~~~~~~~~~~~~~~~

Интерфейсы в некоторых случаях используются для указания, что
некоторый объект принадлежит специальному типу или обладает некоторыми
специфическими свойствами.  Интерфейс, который не содержит определений
атрибутов и методов, называется `маркерным интерфейсом` (`marker
interface`).

Вот простой пример маркерного интерфейса::

  >>> from zope.interface import Interface

  >>> class ISpecialGuest(Interface):
  ...     """Особый гость"""


Интерфейс предназначен для указания, что помеченный объект - это не
просто `гость`, а `особый гость`.

Инварианты
~~~~~~~~~~

Иногда бывает необходимо явным образом указать, что атрибуты
компоненты связаны друг с другом некоторым логическим правилом или
ограничением.  Механизм задания таких правил и ограничений в ZCA
реализуется при помощи `инвариантов` (`invariants`).  Инварианты
задаются также в интерфейсах при помощи функций и объектов модуля ``zope.interface.invariant``.

Рассмотрим простой пример, пусть существует объект `person` (человек).
Его можно описать при помощи атрибутов `имя` (`name`), `email` и
`телефон` (`phone`).  Теперь можно задать ограничение, которое
требует, чтобы email или телефон были обязательно заданы у каждого
объекта person, требовать, чтобы оба этих атрибута были заданы, мы не
будем.

Ограничение проверяет специальный исполняемый объект (callable
object).  В качестве такого объекта выступает исполняемый экземпляр
некоторого класса или даже обычная функция, например такая::

  >>> def contacts_invariant(obj):
  ...
  ...     if not (obj.email or obj.phone):
  ...         raise Exception(
  ...             "Необходимо указать как минимум один вид контакта")

Затем надо определить интерфейс объекта `person`, используя функцию
``zope.interface.invariant``, предписывающую, что для компоненты
задается инвариант::

  >>> from zope.interface import Interface
  >>> from zope.interface import Attribute
  >>> from zope.interface import invariant

  >>> class IPerson(Interface):
  ...
  ...     name = Attribute("Имя")
  ...     email = Attribute("Email-адрес")
  ...     phone = Attribute("Номер телефона")
  ...
  ...     invariant(contacts_invariant)

Теперь при помощи метода `validateInvariants` можно проверять
(верифицировать) структуру объекта на непротиворечивость, содержащихся
в нем данных::

  >>> from zope.interface import implements

  >>> class Person(object):
  ...     implements(IPerson)
  ...
  ...     name = None
  ...     email = None
  ...     phone = None

  >>> jack = Person()
  >>> jack.email = u"jack@some.address.com"
  >>> IPerson.validateInvariants(jack)
  >>> jill = Person()
  >>> IPerson.validateInvariants(jill)
  Traceback (most recent call last):
  ...
  Exception: "Необходимо указать как минимум один вид контакта"

Из примера видно, что объект `jack` верифицирован успешно, и при этом
не возникло никаких исключений.  Объект `jill`, наоборот, не прошел
проверку ограничения, что привело к возникновению соответствующего
исключения.

Адаптеры
--------



Реализация
~~~~~~~~~~

Компонентная архитектора Zope, как можно было заметить, направлена на
продуктивное использование объектов Python.  Компоненты-адаптеры - это
одна из базовых концепций, используемых ZCA, реализуемые и
используемые для повышения продуктивности процесса программирования.
Как и прежде, адаптеры - это объекты Python, но со специальным образом
оформленным интерфейсом.

Для того, чтобы указать, что класс является адаптером, используется
функция `adapts`, которая находится в пакете ``zope.component``.  В
следующем примере в определении адаптера `FrontDeskNG` содержатся
декларация интерфейса, который реализует класс, и декларация
адаптируемого интерфейса::

  >>> from zope.interface import implements
  >>> from zope.component import adapts

  >>> class FrontDeskNG(object):
  ...
  ...     implements(IDesk)
  ...     adapts(IGuest)
  ...
  ...     def __init__(self, guest):
  ...         self.guest = guest
  ...
  ...     def register(self):
  ...         guest = self.guest
  ...         next_id = get_next_id()
  ...         bookings_db[next_id] = {
  ...         'name': guest.name,
  ...         'place': guest.place,
  ...         'phone': guest.phone
  ...         }


Итак, компонента `FrontDeskNG` задана как адаптер для интерфейса
`IGuest` к интерфейсу `IDesk`.  Это значит, что везде, где требуются
компоненты, обеспечивающие интерфейс `IDesk`, можно использовать
компоненты, обеспечивающие `IGuest`, но через компоненту-адаптер
`FrontDeskNG`.  Интерфейс `IDesk` реализуется в классе `FrontDeskNG`,
т.е., экземпляры этого класса обеспечивают интерфейс `IDesk`.

::

  >>> class Guest(object):
  ...
  ...     implements(IGuest)
  ...
  ...     def __init__(self, name, place):
  ...         self.name = name
  ...         self.place = place

  >>> jack = Guest("Jack", "Bangalore")
  >>> jack_frontdesk = FrontDeskNG(jack)

  >>> IDesk.providedBy(jack_frontdesk)
  True

Кроме адаптера `FrontDeskNG` можно разработать и другие адаптеры,
которые могут обрабатывать регистрацию новых постояльцев каким-либо
другим способом.

Регистрация адаптера
~~~~~~~~~~~~~~~~~~~~

Для того, чтобы использовать разработанную компоненту-адаптер,
необходимо ее сначала зарегистрировать в реестре компонент, который в
ZCA называется менеджером сайта (site manager).  Обычно менеджер сайта
ассоциируется с некоторым интернет-сайтом.  Такое название
компоненты-реестра унаследовано от программной системы Zope 3, которая
является средой для разработки динамических сайтов, основанной на ZCA.
К настоящему моменту важно только знать, что существует некий
глобальный сайт и его глобальный менеджер сайта, выполняющий функции
реестра.  Глобальный менеджер сайта располагается в оперативной
памяти, а локальные - в долговременной.

Для регистрации компоненты сначала надо добраться до глобального
менеджера сайта (глобального реестра)::

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()
  >>> gsm.registerAdapter(FrontDeskNG,
  ...                     (IGuest,), IDesk, 'ng')

Для того, чтобы найти глобальный реестр необходимо вызвать глобальную
функцию ``getGlobalSiteManager``, которая находится в модуле
``zope.component``.  Фактически, реестр доступен как атрибут
``globalSiteManager`` пакета ``zope.component``.  То есть, можно
просто использовать атрибут ``zope.component.globalSiteManager``.  Для
регистрации адаптера используется метод ``registerAdapter`` реестра
компонент.  Первым аргументом метода должны быть или класс,
реализующий адаптер, или какая-либо фабрика.  Вторым аргументом
выступает набор (tuple) интерфейсов компонент, которые адаптируются.
В приведенном примере адаптируется только компоненты, обеспечивающие
интерфейс `IGuest`.  Третьим аргументом является интерфейс,
реализуемый компонентой-адаптером.  Четвертый аргумент является
необязательным, он позволяет идентифицировать адаптеры со специальными
свойствами.  В примере такой идентификатор как раз и был использован,
в результате получился специальный поименованный адаптер (`named
adapter`).  Если название не задано, то по умолчанию оно совпадает с
пустой строкой ('').

В определении адаптера `FrontDeskNG` задаются и адаптируемый интерфейс
и интерфейс, к которому происходит адаптация.  То же самое задано и
при регистрации адаптера, что бессмысленно дублирует информацию.
Особой необходимости в этом нет, поэтому можно зарегистрировать
адаптер `FrontDeskNG` следующим упрощенным вызовом::

  >>> gsm.registerAdapter(FrontDeskNG, name='ng')

В ZCA остался устаревший API, выполняющий регистрацию, и его не
следует использовать.  Функции устаревшего API начинаются с `provide`,
например: ``provideAdapter``, ``provideUtility`` и т.д.  При
разработке приложений Zope 3 достаточно удобно использовать еще один
способ регистрации компонент - Язык разметки для конфигурирования Zope
(Zope configuration markup language, ZCML).  Локальные компоненты Zope
3, т.е. компоненты, которые сохраняются в долговременной памяти, можно
также регистрировать из Интерфейса управления Zope (Zope Management
Interface, ZMI), ну и первым способом, программно, регистрация тоже
может быть выполнена.

Адаптер `FrontDeskNG` зарегистрирован под названием `ng`.  Подобным же
образом можно регистрировать другие адаптеры для этой же комбинации
интерфейсов под другими именами.  Напомним, что если компонента
зарегистрирована без названия, то в качестве названия используется пустая
строка.

.. note::

  Локальные компоненты сохраняются в дисковой памяти, в отличие от
  глобальных, которые всегда хранятся в оперативной памяти.
  Глобальные компоненты, как правило, регистрируются в момент
  конфигурирования приложения.  Локальные компоненты загружаются в
  оперативную память из базы данных при загрузке приложения.

Запрос адаптера в реестре
~~~~~~~~~~~~~~~~~~~~~~~~~

Доступ к зарегистрированной компоненте из реестра компонент
осуществляется при помощи двух функций из пакета ``zope.component``.
Первая функция называется ``getAdapter``, а другая - ``queryAdapter``.
Обе функции принимают одни и те же параметры и возвращают требуемую
компоненту, если таковая была зарегистрирована.  Eсли поиск компоненты
в реестре завершился неудачей, то ``getAdapter`` создает
исключительную ситуацию ``ComponentLookupError``, ``queryAdapter``
просто возвратит `None`.

Импортирование этих функций выполняется следующим образом::

  >>> from zope.component import getAdapter
  >>> from zope.component import queryAdapter

В следующем примере нам понадобиться поименованная компонента для
адаптируемого объекта `guest`, который обеспечивает интерфейс `IDesk`.
Компонента была определена и зарегистрирована под именем 'ng' в
предыдущем разделе.  Объект `guest` с именем `jack` определен в первом
разделе этой главы.

Пример демонстрирует, как можно получать доступ к поименованной ('ng')
компоненте, адаптирующей интерфейс (`IGuest`) объекта `jack` и
обеспечивающей интерфейс `IDesk`.  Здесь функции ``getAdapter`` и
``queryAdapter`` исполняются одинаково::

  >>> getAdapter(jack, IDesk, 'ng') #doctest: +ELLIPSIS
  <FrontDeskNG object at ...>
  >>> queryAdapter(jack, IDesk, 'ng') #doctest: +ELLIPSIS
  <FrontDeskNG object at ...>

В вызове функции первый аргумент - адаптируемый объект, второй -
интерфейс, к которому необходимо этот объект адаптировать, и
последний - идентификатор адаптера.  Если попытаться получить доступ с
идентификатором, который не использовался ранее при регистрации
адаптеров таких же объектам к такому же интерфейсу, то по понятным
причинам это завершиться неудачей.  Теперь работе наших функций будет
заметна разница::

  >>> getAdapter(jack, IDesk, 'not-exists') #doctest: +ELLIPSIS
  Traceback (most recent call last):
  ...
  ComponentLookupError: ...
  >>> reg = queryAdapter(jack,
  ...           IDesk, 'not-exists') #doctest: +ELLIPSIS
  >>> reg is None
  True

Видно, что в результате неудачного доступа в ``getAdapter`` возникло
исключение ``ComponentLookupError``, но ``queryAdapter`` мирно вернул
`None`.  Если при получении доступа к компоненте не использовать ее
идентификатор, это означает, что он будет равен пустой строке.  И если
компоненты без идентификатора не было зарегистрировано, то получить
такой доступ тоже невозможно.  Как и прежде в ``getAdapter`` возникнет
исключение ``ComponentLookupError``, а ``queryAdapter`` вернет
`None`.  Вот пример такого неудачного доступа::

  >>> getAdapter(jack, IDesk) #doctest: +ELLIPSIS
  Traceback (most recent call last):
  ...
  ComponentLookupError: ...
  >>> reg = queryAdapter(jack, IDesk) #doctest: +ELLIPSIS
  >>> reg is None
  True

В этом разделе продемонстрировано как регистрируются простые адаптеры,
и как потом получать к ним доступ при помощи реестра компонент.
Простые адаптеры называются единичными адаптерами, так как адаптируют
только один объект.  Если компонента адаптирует более одного объекта,
то она называется мультиадаптером.


Получение доступа к адаптеру с использованием интерфейса
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Получить доступ к адаптеру можно, используя только интерфейс.  Этот
метод работает только для единичных непоименованных адаптеров.  Первый
аргумент - адаптируемый объект, второй аргумент, ключевое слово, -
объект, который возвращается, если доступ к компоненте оказывается
неудачным.

  >>> IDesk(jack, alternate='default-output')
  'default-output'

  Второй аргумент можно задавать и не в формате ключевого слова:

  >>> IDesk(jack, 'default-output')
  'default-output'

  Если второй аргумент совсем не задан, то неудачная попытка доступа
  порождает исключение `TypeError`:

  >>> IDesk(jack) #doctest: +NORMALIZE_WHITESPACE +ELLIPSIS
  Traceback (most recent call last):
  ...
  TypeError: ('Could not adapt',
    <Guest object at ...>,
    <InterfaceClass __builtin__.IDesk>)

  Зарегистрируем `FrontDeskNG` как непоименованный адаптер:

  >>> gsm.registerAdapter(FrontDeskNG)

  Теперь доступ должен быть удачно получен:

  >>> IDesk(jack, 'default-output') #doctest: +ELLIPSIS
  <FrontDeskNG object at ...>

В простых ситуациях можно спокойно использовать интерфейсы для
получения доступа к компонентам-адаптерам.

Шаблон проектирования `Adapter`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Концепция использования адаптеров в Zope Component Architecture и в
применении шаблона `Adapter` в классической книге "Шаблоны
проектирования" являются очень схожими.  Но приемы использования
адаптеров в ZCA обладают большей гибкостью и широтой применения по
сравнению с классическим шаблоном.  Шаблон `Adapter` задает лишь
преобразование некоторого класса в какой-то другой интерфейс, который
ожидает некоторый сервис от экземпляров данного класса.  Шаблон
позволяет разным классам взаимодействовать друг с другом, даже если
они до этого не могли это делать из-за несовместимости их интерфейсов.
В подразделе `Мотивация` книги "Шаблоны проектирования" авторы пишут:
"Часто адаптер отвечает за функциональность, которую не может
предоставить адаптируемый класс".  Адаптеры ZCA фокусируются больше
как раз на реализации новых функций, чем просто создание нового
интерфейса для адаптируемого объекта.  При этом адаптер в ZCA
расширяет функциональность за счет новых методов.  Будет, наверное,
интересным заметить, что `Adapter` в ранних версиях дизайна проекта
ZCA назывался `Feature`. [#feature]_

.. [#feature] Дискуссия по переименованию `Feature` в `Adapter` в
              списке рассылки:
   http://mail.zope.org/pipermail/zope3-dev/2001-December/000008.html

Упомянутая в предыдущем абзаце цитата из книги Банды четырех
заканчивается следующими словами: " ... которую не может предоставить
адаптируемый класс".  Но в следующем предложении абзаца использовано
словосочетание "адаптируемого объекта" вместо "адаптируемого класса",
так как авторы книги на самом деле пишут про два варианта адаптеров, в
зависимости от их реализации.  Первый вариант - это "Адаптер класса",
а другой - "Адаптер объекта".  Адаптер классов использует
множественное наследование для адаптации одного интерфейса к другому,
с другой стороны, адаптер объекта опирается на композицию объектов.
Адаптеры ZCA согласно книге Банды четырех следуют принципу адаптеру
объекта, который использует делегирование (агрегирование) в качестве
механизма композиции.  Второй принцип объектно-ориентированного
дизайна согласно Банде четырех выражается следующим образом:
"Предпочитайте объектную композицию наследованию классов".  Если
хотите более детально познакомиться с приемами адаптации, прочтите
книгу "Шаблоны проектирования".

Самой привлекательной стороной адаптеров ZCA - это явное использование
интерфейсов, в виде специальных объектов Python, во время исполнения
программы, а также реестра компонент.  Адаптеры ZCA регистрируются в
реестре компонент, через который клиентские объекты, затем, могут к
ним получить доступ, опять же при помощи интерфейсов и механизмов
поименования.

Утилиты
-------



Введение
~~~~~~~~

Вы уже знакомы с концепциями "интерфейс"", "адаптер" и "реестр
компонент".  Иногда удобно регистрировать и отдельные объекты, которые
ничего не адаптируют.  Примерами таких объектов выступают соединения с
базами данных, трансляторы XML, объекты, порождающие уникальные
идентификаторы.  Компоненты такого вида, существование которых
поддерживает ZCA, называются компонентами-``утилитами``.

Утилиты - это просто объекты, которые обеспечивают некоторый
интерфейс, и к которым модули программ получают доступ по этим
интерфейсам и регистрационным именам.  Такой подход, с пользованием
глобального реестра, позволяет регистрировать различные объекты и
получать к ним доступ из различных частей программы, и при этом нет
необходимости передавать эти объекты между модулями программы
каким-либо специальным образом.

В программе нет необходимости регистрировать все глобальные объекты,
смысл регистрации состоит в том, чтобы создать механизмы замены одних
объектов, реализующих некоторый сервис, на другие, которые делают это
как-то по-другому.

Простые утилиты
~~~~~~~~~~~~~~~

Утилиты могут быть зарегистрированы поименованными или нет.  Пример
поименованной утилиты рассмотрим в следующем разделе.  Перед тем, как
реализовать утилиту, как обычно, определим ее интерфейс.  Следующий
программный код определяет интерфейс `greeter` утилиты, которая будет
приветствовать постояльцев::

  >>> from zope.interface import Interface
  >>> from zope.interface import implements

  >>> class IGreeter(Interface):
  ...
  ...     def greet(name):
  ...         """Поприветствовать"""

Как и для адаптеров, для утилиты можно реализовать несколькими
способами.  Это классическая реализация при помощи класса::

  >>> class Greeter(object):
  ...
  ...     implements(IGreeter)
  ...
  ...     def greet(self, name):
  ...         return "Здравствуйте, " + name

На самом деле утилита - это экземпляр класса `Greeter`.  Чтобы
утилитой можно было пользоваться, необходимо ее зарегистрировать.  Для
этого пользуется также API ZCA.  Экземпляр класса, утилита
(`utility`), регистрируется при помощи метода реестра компонент
``registerUtility``::

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> greet = Greeter()
  >>> gsm.registerUtility(greet, IGreeter)

В этом примере утилита зарегистрирована как компонента, обеспечивающая
интерфейс `IGreeter`.  Доступ к утилите можно получить по запросу ее
интерфейса при помощи функций `queryUtility` или `getUtility`::

  >>> from zope.component import queryUtility
  >>> from zope.component import getUtility

  >>> queryUtility(IGreeter).greet('Jack')
  'Здравствуйте, Jack'

  >>> getUtility(IGreeter).greet('Jack')
  'Здравствуйте, Jack'

Теперь видно, что по аналогии с адаптерами, которые являются обычно
классами, утилиты являются обычно экземплярами классов.  Поэтому
экземпляры утилит создаются единожды, а экземпляры адаптеров - всякий
раз, как кто-то желает получить к ним доступ.

Поименованные утилиты
~~~~~~~~~~~~~~~~~~~~~

При регистрации компоненты-утилиты, как и адаптера, можно давать им
имена.  Утилита, зарегистрированная под каким-либо именем, называется
поименованной утилитой.

Приведем пример регистрации поименованной утилиты `greeter`::

  >>> greet = Greeter()
  >>> gsm.registerUtility(greet, IGreeter, 'new')

Экземпляр `greet` зарегистрирован как утилита, обеспечивающая
интерфейс `IGreeter`, под именем `new`.  Теперь можно получить к ней
доступ одной из функций `queryUtility` или `getUtility`::

  >>> from zope.component import queryUtility
  >>> from zope.component import getUtility

  >>> queryUtility(IGreeter, 'new').greet('Jill')
  'Здравствуйте, Jill'

  >>> getUtility(IGreeter, 'new').greet('Jill')
  'Здравствуйте, Jill'

Заметим, что для получения доступа необходимо использовать имя `name`
во втором аргументе функций.

Вызов функции `getUtility` без имени (второй аргумент) эквивалентно
вызову этой функции с пустой строкой в качестве второго аргумента, так
как это - значение по умолчанию.  Механизм обеспечения доступа
пытается найти компоненту, чье имя - пустая строка, но его попытка
завершается неуспехом.  Если компонента не найдена, то механизм
создает исключение ``ComponentLookupError``.  Механизм не будет вам
возвращать каки-то другие компоненты, зарегистрированные под другими
именами.  Функции получения доступа к адаптерам `getAdapter` и
`queryAdapter` функционируют аналогично.

Factory
~~~~~~~

A ``Factory`` is a utility component which provides ``IFactory``
interface.

To create a factory, first define the interface of the object::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface
  >>> from zope.interface import implements

  >>> class IDatabase(Interface):
  ...
  ...     def getConnection():
  ...         """Return connection object"""

Here is fake implementation of `IDatabase` interface::

  >>> class FakeDb(object):
  ...
  ...     implements(IDatabase)
  ...
  ...     def getConnection(self):
  ...         return "connection"

You can create a factory using ``zope.component.factory.Factory``::

  >>> from zope.component.factory import Factory

  >>> factory = Factory(FakeDb, 'FakeDb')

Now you can register it like this::

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> from zope.component.interfaces import IFactory
  >>> gsm.registerUtility(factory, IFactory, 'fakedb')

To use the factory, you may do it like this::

  >>> from zope.component import queryUtility
  >>> queryUtility(IFactory, 'fakedb')() #doctest: +ELLIPSIS
  <FakeDb object at ...>

There is a shortcut to use factory::

  >>> from zope.component import createObject
  >>> createObject('fakedb') #doctest: +ELLIPSIS
  <FakeDb object at ...>

Advanced adapters
-----------------

This chapter discuss some advanced adapters like multi adapter,
subscription adapter and handler.

Multi adapter
~~~~~~~~~~~~~

A simple adapter normally adapts only one object, but an adapter may
adapt more than one object.  If an adapter adapts more than one
objects, it is called `multi-adapter`.

::

  >>> from zope.interface import Interface
  >>> from zope.interface import implements
  >>> from zope.component import adapts

  >>> class IAdapteeOne(Interface):
  ...     pass

  >>> class IAdapteeTwo(Interface):
  ...     pass

  >>> class IFunctionality(Interface):
  ...     pass

  >>> class MyFunctionality(object):
  ...     implements(IFunctionality)
  ...     adapts(IAdapteeOne, IAdapteeTwo)
  ...
  ...     def __init__(self, one, two):
  ...         self.one = one
  ...         self.two = two

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> gsm.registerAdapter(MyFunctionality)

  >>> class One(object):
  ...     implements(IAdapteeOne)

  >>> class Two(object):
  ...     implements(IAdapteeTwo)

  >>> one = One()
  >>> two = Two()

  >>> from zope.component import getMultiAdapter

  >>> getMultiAdapter((one,two), IFunctionality) #doctest: +ELLIPSIS
  <MyFunctionality object at ...>

  >>> myfunctionality = getMultiAdapter((one,two), IFunctionality)
  >>> myfunctionality.one #doctest: +ELLIPSIS
  <One object at ...>
  >>> myfunctionality.two #doctest: +ELLIPSIS
  <Two object at ...>

Subscription adapter
~~~~~~~~~~~~~~~~~~~~

Unlike regular adapters, subscription adapters are used when we want
all of the adapters that adapt an object to a particular interface.
Subscription adapter is also known as `subscriber`.

Consider a validation problem.  We have objects and we want to assess
whether they meet some sort of standards.  We define a validation
interface::

  >>> from zope.interface import Interface
  >>> from zope.interface import Attribute
  >>> from zope.interface import implements

  >>> class IValidate(Interface):
  ...
  ...     def validate(ob):
  ...         """Determine whether the object is valid
  ...
  ...         Return a string describing a validation problem.
  ...         An empty string is returned to indicate that the
  ...         object is valid.
  ...         """

Perhaps we have documents::

  >>> class IDocument(Interface):
  ...
  ...     summary = Attribute("Document summary")
  ...     body = Attribute("Document text")

  >>> class Document(object):
  ...
  ...     implements(IDocument)
  ...
  ...     def __init__(self, summary, body):
  ...         self.summary, self.body = summary, body

Now, we may want to specify various validation rules for
documents. For example, we might require that the summary be a single
line::

  >>> from zope.component import adapts

  >>> class SingleLineSummary:
  ...
  ...     adapts(IDocument)
  ...     implements(IValidate)
  ...
  ...     def __init__(self, doc):
  ...         self.doc = doc
  ...
  ...     def validate(self):
  ...         if '\n' in self.doc.summary:
  ...             return 'Summary should only have one line'
  ...         else:
  ...             return ''

Or we might require the body to be at least 1000 characters in length::

  >>> class AdequateLength(object):
  ...
  ...     adapts(IDocument)
  ...     implements(IValidate)
  ...
  ...     def __init__(self, doc):
  ...         self.doc = doc
  ...
  ...     def validate(self):
  ...         if len(self.doc.body) < 1000:
  ...             return 'too short'
  ...         else:
  ...             return ''

We can register these as subscription adapters::

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> gsm.registerSubscriptionAdapter(SingleLineSummary)
  >>> gsm.registerSubscriptionAdapter(AdequateLength)

We can then use the subscribers to validate objects::

  >>> from zope.component import subscribers

  >>> doc = Document("A\nDocument", "blah")
  >>> [adapter.validate()
  ...  for adapter in subscribers([doc], IValidate)
  ...  if adapter.validate()]
  ['Summary should only have one line', 'too short']

  >>> doc = Document("A\nDocument", "blah" * 1000)
  >>> [adapter.validate()
  ...  for adapter in subscribers([doc], IValidate)
  ...  if adapter.validate()]
  ['Summary should only have one line']

  >>> doc = Document("A Document", "blah")
  >>> [adapter.validate()
  ...  for adapter in subscribers([doc], IValidate)
  ...  if adapter.validate()]
  ['too short']

Handler
~~~~~~~

Handlers are subscription adapter factories that don't produce
anything.  They do all of their work when called.  Handlers are
typically used to handle events.  Handlers are also known as event
subscribers or event subscription adapters.

Event subscribers are different from other subscription adapters in
that the caller of event subscribers doesn't expect to interact with
them in any direct way.  For example, an event publisher doesn't
expect to get any return value.  Because subscribers don't need to
provide an API to their callers, it is more natural to define them
with functions, rather than classes.  For example, in a
document-management system, we might want to record creation times for
documents::

  >>> import datetime

  >>> def documentCreated(event):
  ...     event.doc.created = datetime.datetime.utcnow()

In this example, we have a function that takes an event and performs
some processing.  It doesn't actually return anything.  This is a
special case of a subscription adapter that adapts an event to
nothing.  All of the work is done when the adapter "factory" is
called.  We call subscribers that don't actually create anything
"handlers".  There are special APIs for registering and calling them.

To register the subscriber above, we define a document-created event::

  >>> from zope.interface import Interface
  >>> from zope.interface import Attribute
  >>> from zope.interface import implements

  >>> class IDocumentCreated(Interface):
  ...
  ...     doc = Attribute("The document that was created")

  >>> class DocumentCreated(object):
  ...
  ...     implements(IDocumentCreated)
  ...
  ...     def __init__(self, doc):
  ...         self.doc = doc

We'll also change our handler definition to::

  >>> def documentCreated(event):
  ...     event.doc.created = datetime.datetime.utcnow()

  >>> from zope.component import adapter

  >>> @adapter(IDocumentCreated)
  ... def documentCreated(event):
  ...     event.doc.created = datetime.datetime.utcnow()

This marks the handler as an adapter of `IDocumentCreated` events.

Now we'll register the handler::

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> gsm.registerHandler(documentCreated)

Now, we can create an event and use the `handle` function to call
handlers registered for the event::

  >>> from zope.component import handle

  >>> handle(DocumentCreated(doc))
  >>> doc.created.__class__.__name__
  'datetime'

ZCA usage in Zope
-----------------

Zope Component Architecture is used in both Zope 3 and Zope 2.  This
chapter will go through usage of the ZCA in Zope.

ZCML
~~~~

The **Zope Configuration Markup Language (ZCML)** is an XML based
configuration system for registration of components.  So, instead of
using Python API for registration, you can use ZCML.  But to use
ZCML, you will be required to install more dependency packages.

You can install ``zope.component`` with ZCML support using
easy_install like this::

  $ easy_install "zope.component [zcml]"

A ZCML file should start with ``configure`` directive with
appropriate namespace declaration::

  <configure xmlns="http://namespaces.zope.org/zope">
  ...
  </configure>

The `adapter` directive can be used to register adapters::

  <adapter
      factory=".company.EmployeeSalary"
      provides=".interfaces.ISalary"
      for=".interfaces.IEmployee"
      />

The `provides` and `for` attributes are optional, provided you have
declared it in the implementation::

  <adapter
      factory=".company.EmployeeSalary"
      />

If you want to register the component as a named adapter, you can use
the `name` attribute::

  <adapter
      factory=".company.EmployeeSalary"
      name="salary"
      />

A utility can be registered using `utility` directive.  To register
an utility::

  <utility
      component=".database.connection"
      provides=".interfaces.IConnection"
      />

The `provides` attribute is optional, provided you have declared it in
the implementation::

  <configure xmlns="http://namespaces.zope.org/zope">

  <utility
      component=".database.connection"
      />

If you want to register the component as a named utility, you can use
the `name` attribute::

  <utility
      component=".database.connection"
      name="db_connection"
      />

Instead of directly using the component, you can also give a factory::

  <utility
      factory=".database.Connection"
      />

Overrides
~~~~~~~~~

When you register components using Python API (``register*`` methods),
the last registered component will replace previously registered
component, if both are registered with same type of arguments.  For
example, consider this example::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface

  >>> class IA(Interface):
  ...     pass

  >>> class IP(Interface):
  ...     pass

  >>> from zope.interface import implements
  >>> from zope.component import adapts

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> class AP(object):
  ...
  ...     implements(IP)
  ...     adapts(IA)
  ...
  ...     def __init__(self, context):
  ...         self.context = context

  >>> class AP2(object):
  ...
  ...     implements(IP)
  ...     adapts(IA)
  ...
  ...     def __init__(self, context):
  ...         self.context = context

  >>> class A(object):
  ...
  ...     implements(IA)

  >>> a = A()
  >>> ap = AP(a)

  >>> gsm.registerAdapter(AP)

  >>> getAdapter(a, IP) #doctest: +ELLIPSIS
  <AP object at ...>

If you register another adapter, the existing one will be replaced::

  >>> gsm.registerAdapter(AP2)

  >>> getAdapter(a, IP) #doctest: +ELLIPSIS
  <AP2 object at ...>

But when registering components using ZCML, the second registration
will raise a conflict error.  This is a hint for you, otherwise there
is a chance for overriding registration by mistake.  This may lead to
hard to track bugs in your system.  So, using ZCML is a win for the
application.

Sometimes you will be required to override existing registration.
ZCML provides ``includeOverrides`` directive for this.  Using this,
you can write your overrides in a separate file::

  <includeOverrides file="overrides.zcml" />

NameChooser
~~~~~~~~~~~

Location: `zope.app.container.contained.NameChooser`

This is an adapter for choosing a unique name for an object inside a
container.

The registration of adapter is like this::

  <adapter
      provides=".interfaces.INameChooser"
      for="zope.app.container.interfaces.IWriteContainer"
      factory=".contained.NameChooser"
      />

From the registration, you can see that the adaptee is a
``IWriteContainer`` and the adapter provides ``INameChooser``.

This adapter provides a very convenient functionality for Zope
programmers.  The main implementations of ``IWriteContainer`` in
Zope 3 are ``zope.app.container.BTreeContainer`` and
``zope.app.folder.Folder``.  Normally you will be inheriting from
these implementations for creating your own container classes.
Suppose there is no interface called ``INameChooser`` and
adapter, then you will be required to implement this functionality
for every implementations separately.

LocationPhysicallyLocatable
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Location:
``zope.location.traversing.LocationPhysicallyLocatable``

This adapter is frequently used in Zope 3 applications, but
normally it is called through an API in ``zope.traversing.api``.
(Some old code even use ``zope.app.zapi`` functions, which is
again one more indirection)

The registration of adapter is like this::

  <adapter
      factory="zope.location.traversing.LocationPhysicallyLocatable"
      />

The interface provided and adaptee interface is given in the
implementation.

Here is the beginning of implementation::

  class LocationPhysicallyLocatable(object):
      """Provide location information for location objects
      """
      zope.component.adapts(ILocation)
      zope.interface.implements(IPhysicallyLocatable)
      ...

Normally, almost all persistent objects in Zope 3 application
will be providing the ``ILocation`` interface.  This interface
has only two attribute, ``__parent__`` and ``__name__``.  The
``__parent__`` is the parent in the location hierarchy.  And
``__name__`` is the name within the parent.

The ``IPhysicallyLocatable`` interface has four methods:
``getRoot``, ``getPath``, ``getName``, and ``getNearestSite``.

- ``getRoot`` function will return the physical root object.

- ``getPath`` return the physical path to the object as a
  string.

- ``getName`` return the last segment of the physical path.

- ``getNearestSite`` return the site the object is contained
  in.  If the object is a site, the object itself is returned.

If you learn Zope 3, you can see that these are the important
things which you required very often.  To understand the beauty
of this system, you must see how Zope 2 actually get the physical
root object and how it is implemented.  There is a method called
``getPhysicalRoot`` virtually for all container objects.

DefaultSized
~~~~~~~~~~~~

Location: ``zope.size.DefaultSized``

This adapter is just a default implementation of ``ISized`` interface.
This adapter is registered for all kind of objects.  If you want to
register this adapter for a particular interface, then you have to
override this registration for your implementation.

The registration of adapter is like this::

  <adapter
      for="*"
      factory="zope.size.DefaultSized"
      provides="zope.size.interfaces.ISized"
      permission="zope.View"
      />

As you can see, the adaptee interface is `*`, so it can adapt any kind
of objects.

The ``ISized`` is a simple interface with two method contracts::

  class ISized(Interface):

      def sizeForSorting():
          """Returns a tuple (basic_unit, amount)

          Used for sorting among different kinds of sized objects.
          'amount' need only be sortable among things that share the
          same basic unit."""

      def sizeForDisplay():
          """Returns a string giving the size.
          """

You can see another ``ISized`` adapter registered for ``IZPTPage`` in
``zope.app.zptpage`` package.

ZopeVersionUtility
~~~~~~~~~~~~~~~~~~

Location: ``zope.app.applicationcontrol.ZopeVersionUtility``

This utility gives version of the running Zope.

The registration goes like this::

  <utility
      component=".zopeversion.ZopeVersionUtility"
      provides=".interfaces.IZopeVersion" />

The interface provided, ``IZopeVersion``, has only one method named
``getZopeVersion``.  This method return a string containing the Zope
version (possibly including SVN information).

The default implementation, ``ZopeVersionUtility``, get version info
from a file ``version.txt`` in `zope/app` directory.  If Zope is
running from subversion checkout, it will show the latest revision
number.  If none of the above works it will set it to:
`Development/Unknown`.

Case study
----------

.. note::

  This chapter is not yet completed.  Please send your suggestions !

Introduction
~~~~~~~~~~~~

This chapter demonstrates creating a desktop application using PyGTK
GUI library and the ZCA.  This application also use two different
kinds of data persistence mechanisms, one object database (ZODB) & and
another relational database (SQLite).  However, practically, only one
storage can be used for a particular installation.  The reason for
using two different persistence mechanisms is to demonstrate how to
use the ZCA to glue components.  Majority of the code in this
application is related to PyGTK.

As the application grows you may use the ZCA components wherever you
want pluggability or extensibility.  Use plain Python objects directly
where you do not required pluggability or extensibility.

There is no difference in using ZCA for web or desktop or any other
kind of application or framework.  It is better to follow a
convention for the location from where you are going to register
components.  This application use a convention, which can be extended
by putting registration of similar components in separate modules and
later import them from main registration module.  In this application
the main component registration module is `register.py`.

Source code of this application can be downloaded from:
http://www.muthukadan.net/downloads/zcalib.tar.bz2

Use cases
~~~~~~~~~

The application we are going to discuss here is a library management
system with minimal features.  The requirements can be summarized like
this:

- Add members with a unique number and name.

- Add books with barcode, author & title

- Issue books

- Return books


The application can be designed in such a way that major features can
be accessed from a single window.  The main window for accessing all
these features can be designed like this:

.. image:: mainwindow.png
   :align: center

From member window, user should be able to manage members.  So, it
should be possible to *add*, *update* and *delete* members as shown
in the below picture:

.. image:: memberwindow.png
   :align: center

Similar to member window, the catalog window allows user to *add*,
*edit* and *delete* books:

.. image:: catalogwindow.png
   :align: center

The circulation window should have the facility for issuing and
returning books:

.. image:: circulationwindow.png
   :align: center

Overview of PyGTK code
~~~~~~~~~~~~~~~~~~~~~~

As you can see in the code, most of the code are related to PyGTK.
The code structure is very similar for different windows.  The windows
of this application are designed using Glade GUI builder.  You should
give proper names for widgets you are going to use from code.  In the
main window, all menu entries has names like: circulation, catalog,
member, quit & about.

The ``gtk.glade.XML`` class is used to parse glade file, this will
create GUI widget objects.  This is how to parse and access objects::

  import gtk.glade
  xmlobj = gtk.glade.XML('/path/to/file.glade')
  widget = xmlobj.get_widget('widget_name')

In the mainwindow.py, you can see code like this::

  curdir = os.path.abspath(os.path.dirname(__file__))
  xml = os.path.join(curdir, 'glade', 'mainwindow.glade')
  xmlobj = gtk.glade.XML(xml)

  self.mainwindow = xmlobj.get_widget('mainwindow')

The name of main window widget is `mainwindow`.  Similarly, other
widgets are retrieved like this::

  circulation = xmlobj.get_widget('circulation')
  member = xmlobj.get_widget('member')
  quit = xmlobj.get_widget('quit')
  catalog = xmlobj.get_widget('catalog')
  about = xmlobj.get_widget('about')

Then, these widgets are connected for some events::

  self.mainwindow.connect('delete_event', self.delete_event)
  quit.connect('activate', self.delete_event)
  circulation.connect('activate', self.on_circulation_activate)
  member.connect('activate', self.on_member_activate)
  catalog.connect('activate', self.on_catalog_activate)
  about.connect('activate', self.on_about_activate)

The `delete_event` is the event when the window is closing using the
window close button.  The `activate` event is emitted when the menu is
selected.  The widgets are connected to some callback functions for
some events.

You can see from the above code that, main window is connected to
`on_delete_event` method for `delete_event`.  The `quit` widget is
also connected to same method for `activate` event::

    def on_delete_event(self, *args):
        gtk.main_quit()

The callback function just call `main_quit` function

The code
~~~~~~~~

This is the `zcalib.py`::

  import registry
  import mainwindow

  if __name__ == '__main__':
      registry.initialize()
      try:
          mainwindow.main()
      except KeyboardInterrupt:
          import sys
          sys.exit(1)

Here, two modules are imported `registry` and `mainwindow`.  Then,
registry is initialized and mainwindow's `main` function is called.
If user is trying to exit application using `Ctrl+C`, system will exit
normally, that's why we catched `KeyboardInterrupt` exception.

This is the `registry.py`::

  import sys
  from zope.component import getGlobalSiteManager

  from interfaces import IMember
  from interfaces import IBook
  from interfaces import ICirculation
  from interfaces import IDbOperation


  def initialize_rdb():
      from interfaces import IRelationalDatabase
      from relationaldatabase import RelationalDatabase
      from member import MemberRDbOperation
      from catalog import BookRDbOperation
      from circulation import CirculationRDbOperation

      gsm = getGlobalSiteManager()
      db = RelationalDatabase()
      gsm.registerUtility(db, IRelationalDatabase)

      gsm.registerAdapter(MemberRDbOperation,
                          (IMember,),
                          IDbOperation)

      gsm.registerAdapter(BookRDbOperation,
                          (IBook,),
                          IDbOperation)

      gsm.registerAdapter(CirculationRDbOperation,
                          (ICirculation,),
                          IDbOperation)

  def initialize_odb():
      from interfaces import IObjectDatabase
      from objectdatabase import ObjectDatabase
      from member import MemberODbOperation
      from catalog import BookODbOperation
      from circulation import CirculationODbOperation

      gsm = getGlobalSiteManager()
      db = ObjectDatabase()
      gsm.registerUtility(db, IObjectDatabase)

      gsm.registerAdapter(MemberODbOperation,
                          (IMember,),
                          IDbOperation)

      gsm.registerAdapter(BookODbOperation,
                          (IBook,),
                          IDbOperation)

      gsm.registerAdapter(CirculationODbOperation,
                          (ICirculation,),
                          IDbOperation)

  def check_use_relational_db():
      use_rdb = False
      try:
          arg = sys.argv[1]
          if arg == '-r':
              return True
      except IndexError:
          pass
      return use_rdb

  def initialize():
      use_rdb = check_use_relational_db()
      if use_rdb:
          initialize_rdb()
      else:
          initialize_odb()

Look at the `initialize` function which we are calling from the main
module, `zcalib.py`.  The `initialize` function first check which db
to use, relational database (RDB) or object database (ODB) and this
checking is done at `check_use_relational_db` function.  If `-r`
option is given at command line, it will call `initialize_rdb`
otherwise, `initialize_odb`.  If the RDB function is called, it will
setup all components related to RDB.  On the other hand, if the ODB
function is called, it will setup all components related to ODB.

Here is the `mainwindow.py`::

  import os
  import gtk
  import gtk.glade

  from circulationwindow import circulationwindow
  from catalogwindow import catalogwindow
  from memberwindow import memberwindow

  class MainWindow(object):

      def __init__(self):
          curdir = os.path.abspath(os.path.dirname(__file__))
          xml = os.path.join(curdir, 'glade', 'mainwindow.glade')
          xmlobj = gtk.glade.XML(xml)

          self.mainwindow = xmlobj.get_widget('mainwindow')
          circulation = xmlobj.get_widget('circulation')
          member = xmlobj.get_widget('member')
          quit = xmlobj.get_widget('quit')
          catalog = xmlobj.get_widget('catalog')
          about = xmlobj.get_widget('about')

          self.mainwindow.connect('delete_event', self.delete_event)
          quit.connect('activate', self.delete_event)

          circulation.connect('activate', self.on_circulation_activate)
          member.connect('activate', self.on_member_activate)
          catalog.connect('activate', self.on_catalog_activate)
          about.connect('activate', self.on_about_activate)

      def delete_event(self, *args):
          gtk.main_quit()

      def on_circulation_activate(self, *args):
          circulationwindow.show_all()

      def on_member_activate(self, *args):
          memberwindow.show_all()

      def on_catalog_activate(self, *args):
          catalogwindow.show_all()

      def on_about_activate(self, *args):
          pass

      def run(self):
          self.mainwindow.show_all()

  def main():
      mainwindow = MainWindow()
      mainwindow.run()
      gtk.main()


The `main` function here creates an instance of `MainWindow` class,
which will initialize all widgets.

Here is the `memberwindow.py`::

  import os
  import gtk
  import gtk.glade

  from zope.component import getAdapter

  from components import Member
  from interfaces import IDbOperation


  class MemberWindow(object):

      def __init__(self):
          curdir = os.path.abspath(os.path.dirname(__file__))
          xml = os.path.join(curdir, 'glade', 'memberwindow.glade')
          xmlobj = gtk.glade.XML(xml)

          self.memberwindow = xmlobj.get_widget('memberwindow')
          self.number = xmlobj.get_widget('number')
          self.name = xmlobj.get_widget('name')
          add = xmlobj.get_widget('add')
          update = xmlobj.get_widget('update')
          delete = xmlobj.get_widget('delete')
          close = xmlobj.get_widget('close')
          self.treeview = xmlobj.get_widget('treeview')

          self.memberwindow.connect('delete_event', self.on_delete_event)
          add.connect('clicked', self.on_add_clicked)
          update.connect('clicked', self.on_update_clicked)
          delete.connect('clicked', self.on_delete_clicked)
          close.connect('clicked', self.on_delete_event)

          self.initialize_list()

      def show_all(self):
          self.populate_list_store()
          self.memberwindow.show_all()

      def populate_list_store(self):
          self.list_store.clear()
          member = Member()
          memberdboperation = getAdapter(member, IDbOperation)
          members = memberdboperation.get()
          for member in members:
              number = member.number
              name = member.name
              self.list_store.append((member, number, name,))

      def on_delete_event(self, *args):
          self.memberwindow.hide()
          return True

      def initialize_list(self):
          self.list_store = gtk.ListStore(object, str, str)
          self.treeview.set_model(self.list_store)
          tvcolumn = gtk.TreeViewColumn('Member Number')
          self.treeview.append_column(tvcolumn)

          cell = gtk.CellRendererText()
          tvcolumn.pack_start(cell, True)
          tvcolumn.add_attribute(cell, 'text', 1)

          tvcolumn = gtk.TreeViewColumn('Member Name')
          self.treeview.append_column(tvcolumn)

          cell = gtk.CellRendererText()
          tvcolumn.pack_start(cell, True)
          tvcolumn.add_attribute(cell, 'text', 2)

      def on_add_clicked(self, *args):
          number = self.number.get_text()
          name = self.name.get_text()
          member = Member()
          member.number = number
          member.name = name
          self.add(member)
          self.list_store.append((member, number, name,))

      def add(self, member):
          memberdboperation = getAdapter(member, IDbOperation)
          memberdboperation.add()

      def on_update_clicked(self, *args):
          number = self.number.get_text()
          name = self.name.get_text()
          treeselection = self.treeview.get_selection()
          model, iter = treeselection.get_selected()
          if not iter:
              return
          member = self.list_store.get_value(iter, 0)
          member.number = number
          member.name = name
          self.update(member)
          self.list_store.set(iter, 1, number, 2, name)

      def update(self, member):
          memberdboperation = getAdapter(member, IDbOperation)
          memberdboperation.update()

      def on_delete_clicked(self, *args):
          treeselection = self.treeview.get_selection()
          model, iter = treeselection.get_selected()
          if not iter:
              return
          member = self.list_store.get_value(iter, 0)
          self.delete(member)
          self.list_store.remove(iter)

      def delete(self, member):
          memberdboperation = getAdapter(member, IDbOperation)
          memberdboperation.delete()

  memberwindow = MemberWindow()

Here is the `components.py`::

  from zope.interface import implements

  from interfaces import IBook
  from interfaces import IMember
  from interfaces import ICirculation

  class Book(object):

      implements(IBook)

      barcode = ""
      title = ""
      author = ""

  class Member(object):

      implements(IMember)

      number = ""
      name = ""

  class Circulation(object):

      implements(ICirculation)

      book = Book()
      member = Member()

Here is the `interfaces.py`::

  from zope.interface import Interface
  from zope.interface import Attribute


  class IBook(Interface):

      barcode = Attribute("Barcode")
      author = Attribute("Author of book")
      title = Attribute("Title of book")


  class IMember(Interface):

      number = Attribute("ID number")
      name = Attribute("Name of member")


  class ICirculation(Interface):

      book = Attribute("A book")
      member = Attribute("A member")


  class IRelationalDatabase(Interface):

      def commit():
          pass

      def rollback():
          pass

      def cursor():
          pass

      def get_next_id():
          pass


  class IObjectDatabase(Interface):

      def commit():
          pass

      def rollback():
          pass

      def container():
          pass

      def get_next_id():
          pass


  class IDbOperation(Interface):

      def get():
          pass

      def add():
          pass

      def update():
          pass

      def delete():
          pass

Here is the `member.py`::

  from zope.interface import implements
  from zope.component import getUtility
  from zope.component import adapts

  from components import Member

  from interfaces import IRelationalDatabase
  from interfaces import IObjectDatabase
  from interfaces import IMember
  from interfaces import IDbOperation


  class MemberRDbOperation(object):

      implements(IDbOperation)
      adapts(IMember)

      def __init__(self, member):
          self.member = member

      def get(self):
          db = getUtility(IRelationalDatabase)
          cr = db.cursor()
          number = self.member.number
          if number:
              cr.execute("""SELECT
                              id,
                              number,
                              name
                            FROM members
                            WHERE number = ?""",
                         (number,))
          else:
              cr.execute("""SELECT
                              id,
                              number,
                              name
                            FROM members""")
          rst = cr.fetchall()
          cr.close()
          members = []
          for record in rst:
              id = record['id']
              number = record['number']
              name = record['name']
              member = Member()
              member.id = id
              member.number = number
              member.name = name
              members.append(member)
          return members

      def add(self):
          db = getUtility(IRelationalDatabase)
          cr = db.cursor()
          next_id = db.get_next_id("members")
          number = self.member.number
          name = self.member.name
          cr.execute("""INSERT INTO members
                          (id, number, name)
                        VALUES (?, ?, ?)""",
                     (next_id, number, name))
          cr.close()
          db.commit()
          self.member.id = next_id

      def update(self):
          db = getUtility(IRelationalDatabase)
          cr = db.cursor()
          number = self.member.number
          name = self.member.name
          id = self.member.id
          cr.execute("""UPDATE members
                          SET
                             number = ?,
                             name = ?
                        WHERE id = ?""",
                     (number, name, id))
          cr.close()
          db.commit()

      def delete(self):
          db = getUtility(IRelationalDatabase)
          cr = db.cursor()
          id = self.member.id
          cr.execute("""DELETE FROM members
                        WHERE id = ?""",
                     (id,))
          cr.close()
          db.commit()


  class MemberODbOperation(object):

      implements(IDbOperation)
      adapts(IMember)

      def __init__(self, member):
          self.member = member

      def get(self):
          db = getUtility(IObjectDatabase)
          zcalibdb = db.container()
          members = zcalibdb['members']
          return members.values()

      def add(self):
          db = getUtility(IObjectDatabase)
          zcalibdb = db.container()
          members = zcalibdb['members']
          number = self.member.number
          if number in [x.number for x in members.values()]:
              db.rollback()
              raise Exception("Duplicate key")
          next_id = db.get_next_id('members')
          self.member.id = next_id
          members[next_id] = self.member
          db.commit()

      def update(self):
          db = getUtility(IObjectDatabase)
          zcalibdb = db.container()
          members = zcalibdb['members']
          id = self.member.id
          members[id] = self.member
          db.commit()

      def delete(self):
          db = getUtility(IObjectDatabase)
          zcalibdb = db.container()
          members = zcalibdb['members']
          id = self.member.id
          del members[id]
          db.commit()

PySQLite
~~~~~~~~



ZODB
~~~~



Conclusions
~~~~~~~~~~~



Reference
---------



adaptedBy
~~~~~~~~~

This function helps to find the adapted interfaces.

- Location: ``zope.component``

- Signature: `adaptedBy(object)`

Example::

  >>> from zope.interface import implements
  >>> from zope.component import adapts
  >>> from zope.component import adaptedBy

  >>> class FrontDeskNG(object):
  ...
  ...     implements(IDesk)
  ...     adapts(IGuest)
  ...
  ...     def __init__(self, guest):
  ...         self.guest = guest

  >>> adaptedBy(FrontDeskNG)
  (<InterfaceClass __builtin__.IGuest>,)

adapter
~~~~~~~

Adapters can be any callable object, you can use the `adapter`
decorator to declare that a callable object adapts some interfaces (or
classes)

- Location: ``zope.component``

- Signature: `adapter(*interfaces)`

Example::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface
  >>> from zope.interface import implementer
  >>> from zope.component import adapter
  >>> from zope.interface import implements

  >>> class IJob(Interface):
  ...     """A job"""

  >>> class Job(object):
  ...     implements(IJob)

  >>> class IPerson(Interface):
  ...
  ...     name = Attribute("Name")
  ...     job = Attribute("Job")

  >>> class Person(object):
  ...     implements(IPerson)
  ...
  ...     name = None
  ...     job = None

  >>> @implementer(IJob)
  ... @adapter(IPerson)
  ... def personJob(person):
  ...     return person.job

  >>> jack = Person()
  >>> jack.name = "Jack"
  >>> jack.job = Job()
  >>> personJob(jack) #doctest: +ELLIPSIS
  <Job object at ...>

adapts
~~~~~~

This function helps to declare adapter classes.

- Location: ``zope.component``

- Signature: `adapts(*interfaces)`

Example::

  >>> from zope.interface import implements
  >>> from zope.component import adapts

  >>> class FrontDeskNG(object):
  ...
  ...     implements(IDesk)
  ...     adapts(IGuest)
  ...
  ...     def __init__(self, guest):
  ...         self.guest = guest
  ...
  ...     def register(self):
  ...         next_id = get_next_id()
  ...         bookings_db[next_id] = {
  ...         'name': guest.name,
  ...         'place': guest.place,
  ...         'phone': guest.phone
  ...         }

alsoProvides
~~~~~~~~~~~~

Declare interfaces declared directly for an object.  The arguments
after the object are one or more interfaces.  The interfaces given are
added to the interfaces previously declared for the object.

- Location: ``zope.interface``

- Signature: `alsoProvides(object, *interfaces)`

Example::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface
  >>> from zope.interface import implements
  >>> from zope.interface import alsoProvides

  >>> class IPerson(Interface):
  ...
  ...     name = Attribute("Name of person")

  >>> class IStudent(Interface):
  ...
  ...     college = Attribute("Name of college")

  >>> class Person(object):
  ...
  ...     implements(IDesk)
  ...     name = u""

  >>> jack = Person()
  >>> jack.name = "Jack"
  >>> jack.college = "New College"
  >>> alsoProvides(jack, IStudent)

  You can test it like this:

  >>> from zope.interface import providedBy
  >>> IStudent in providedBy(jack)
  True

Attribute
~~~~~~~~~

Using this class, you can define normal attributes in an interface.

- Location: ``zope.interface``

- Signature: `Attribute(name, doc='')`

- See also: `Interface`_

Example::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface

  >>> class IPerson(Interface):
  ...
  ...     name = Attribute("Name of person")
  ...     email = Attribute("Email Address")

classImplements
~~~~~~~~~~~~~~~

Declare additional interfaces implemented for instances of a class.
The arguments after the class are one or more interfaces.  The
interfaces given are added to any interfaces previously declared.

- Location: ``zope.interface``

- Signature: `classImplements(cls, *interfaces)`

Example::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface
  >>> from zope.interface import implements
  >>> from zope.interface import classImplements

  >>> class IPerson(Interface):
  ...
  ...     name = Attribute("Name of person")

  >>> class IStudent(Interface):
  ...
  ...     college = Attribute("Name of college")

  >>> class Person(object):
  ...
  ...     implements(IDesk)
  ...     name = u""
  ...     college = u""

  >>> classImplements(Person, IStudent)
  >>> jack = Person()
  >>> jack.name = "Jack"
  >>> jack.college = "New College"

  You can test it like this:

  >>> from zope.interface import providedBy
  >>> IStudent in providedBy(jack)
  True

classImplementsOnly
~~~~~~~~~~~~~~~~~~~

Declare the only interfaces implemented by instances of a class.  The
arguments after the class are one or more interfaces.  The interfaces
given replace any previous declarations.

 - Location: ``zope.interface``

 - Signature: `classImplementsOnly(cls, *interfaces)`

Example::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface
  >>> from zope.interface import implements
  >>> from zope.interface import classImplementsOnly

  >>> class IPerson(Interface):
  ...
  ...     name = Attribute("Name of person")

  >>> class IStudent(Interface):
  ...
  ...     college = Attribute("Name of college")

  >>> class Person(object):
  ...
  ...     implements(IPerson)
  ...     college = u""

  >>> classImplementsOnly(Person, IStudent)
  >>> jack = Person()
  >>> jack.college = "New College"

  You can test it like this:

  >>> from zope.interface import providedBy
  >>> IPerson in providedBy(jack)
  False
  >>> IStudent in providedBy(jack)
  True

classProvides
~~~~~~~~~~~~~

Normally if a class implements a particular interface, the instance of
that class will provide the interface implemented by that class.  But
if you want a class to be provided by an interface, you can declare it
using ``classProvides`` function.

- Location: ``zope.interface``

- Signature: `classProvides(*interfaces)`

Example::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface
  >>> from zope.interface import classProvides

  >>> class IPerson(Interface):
  ...
  ...     name = Attribute("Name of person")

  >>> class Person(object):
  ...
  ...     classProvides(IPerson)
  ...     name = u"Jack"

  You can test it like this:

  >>> from zope.interface import providedBy
  >>> IPerson in providedBy(Person)
  True

ComponentLookupError
~~~~~~~~~~~~~~~~~~~~

This is the exception raised when a component lookup fails.

Example::

  >>> class IPerson(Interface):
  ...
  ...     name = Attribute("Name of person")

  >>> person = object()
  >>> getAdapter(person, IPerson, 'not-exists') #doctest: +ELLIPSIS
  Traceback (most recent call last):
  ...
  ComponentLookupError: ...

createObject
~~~~~~~~~~~~

Create an object using a factory.

Finds the named factory in the current site and calls it with the
given arguments.  If a matching factory cannot be found raises
``ComponentLookupError``.  Returns the created object.

A context keyword argument can be provided to cause the factory to be
looked up in a location other than the current site.  (Of course, this
means that it is impossible to pass a keyword argument named "context"
to the factory.

- Location: ``zope.component``

- Signature: `createObject(factory_name, *args, **kwargs)`

Example::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface
  >>> from zope.interface import implements

  >>> class IDatabase(Interface):
  ...
  ...     def getConnection():
  ...         """Return connection object"""

  >>> class FakeDb(object):
  ...
  ...     implements(IDatabase)
  ...
  ...     def getConnection(self):
  ...         return "connection"

  >>> from zope.component.factory import Factory

  >>> factory = Factory(FakeDb, 'FakeDb')

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> from zope.component.interfaces import IFactory
  >>> gsm.registerUtility(factory, IFactory, 'fakedb')

  >>> from zope.component import createObject
  >>> createObject('fakedb') #doctest: +ELLIPSIS
  <FakeDb object at ...>

Declaration
~~~~~~~~~~~

Need not to use directly.

directlyProvidedBy
~~~~~~~~~~~~~~~~~~

This function will return the interfaces directly provided by the
given object.

- Location: ``zope.interface``

- Signature: `directlyProvidedBy(object)`

Example::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface

  >>> class IPerson(Interface):
  ...
  ...     name = Attribute("Name of person")

  >>> class IStudent(Interface):
  ...
  ...     college = Attribute("Name of college")

  >>> class ISmartPerson(Interface):
  ...     pass

  >>> class Person(object):
  ...
  ...     implements(IPerson)
  ...     name = u""

  >>> jack = Person()
  >>> jack.name = u"Jack"
  >>> jack.college = "New College"
  >>> alsoProvides(jack, ISmartPerson, IStudent)

  >>> from zope.interface import directlyProvidedBy

  >>> jack_dp = directlyProvidedBy(jack)
  >>> IPerson in jack_dp.interfaces()
  False
  >>> IStudent in jack_dp.interfaces()
  True
  >>> ISmartPerson in jack_dp.interfaces()
  True

directlyProvides
~~~~~~~~~~~~~~~~

Declare interfaces declared directly for an object.  The arguments
after the object are one or more interfaces.  The interfaces given
replace interfaces previously declared for the object.

 - Location: ``zope.interface``

 - Signature: `directlyProvides(object, *interfaces)`

Example::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface

  >>> class IPerson(Interface):
  ...
  ...     name = Attribute("Name of person")

  >>> class IStudent(Interface):
  ...
  ...     college = Attribute("Name of college")

  >>> class ISmartPerson(Interface):
  ...     pass

  >>> class Person(object):
  ...
  ...     implements(IPerson)
  ...     name = u""

  >>> jack = Person()
  >>> jack.name = u"Jack"
  >>> jack.college = "New College"
  >>> alsoProvides(jack, ISmartPerson, IStudent)

  >>> from zope.interface import directlyProvidedBy

  >>> jack_dp = directlyProvidedBy(jack)
  >>> ISmartPerson in jack_dp.interfaces()
  True
  >>> IPerson in jack_dp.interfaces()
  False
  >>> IStudent in jack_dp.interfaces()
  True
  >>> from zope.interface import providedBy

  >>> ISmartPerson in providedBy(jack)
  True

  >>> from zope.interface import directlyProvides
  >>> directlyProvides(jack, IStudent)

  >>> jack_dp = directlyProvidedBy(jack)
  >>> ISmartPerson in jack_dp.interfaces()
  False
  >>> IPerson in jack_dp.interfaces()
  False
  >>> IStudent in jack_dp.interfaces()
  True

  >>> ISmartPerson in providedBy(jack)
  False

getAdapter
~~~~~~~~~~

Get a named adapter to an interface for an object.  Returns an adapter
that can adapt object to interface.  If a matching adapter cannot be
found, raises ``ComponentLookupError`` .

- Location: ``zope.interface``

- Signature: `getAdapter(object, interface=Interface, name=u'', context=None)`

Example::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface

  >>> class IDesk(Interface):
  ...     """A frontdesk will register object's details"""
  ...
  ...     def register():
  ...         """Register object's details"""
  ...

  >>> from zope.interface import implements
  >>> from zope.component import adapts

  >>> class FrontDeskNG(object):
  ...
  ...     implements(IDesk)
  ...     adapts(IGuest)
  ...
  ...     def __init__(self, guest):
  ...         self.guest = guest
  ...
  ...     def register(self):
  ...         next_id = get_next_id()
  ...         bookings_db[next_id] = {
  ...         'name': guest.name,
  ...         'place': guest.place,
  ...         'phone': guest.phone
  ...         }

  >>> class Guest(object):
  ...
  ...     implements(IGuest)
  ...
  ...     def __init__(self, name, place):
  ...         self.name = name
  ...         self.place = place

  >>> jack = Guest("Jack", "Bangalore")
  >>> jack_frontdesk = FrontDeskNG(jack)

  >>> IDesk.providedBy(jack_frontdesk)
  True

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()
  >>> gsm.registerAdapter(FrontDeskNG,
  ...                     (IGuest,), IDesk, 'ng')

  >>> getAdapter(jack, IDesk, 'ng') #doctest: +ELLIPSIS
  <FrontDeskNG object at ...>

getAdapterInContext
~~~~~~~~~~~~~~~~~~~

Instead of this function, use `context` argument of `getAdapter`_
function.

- Location: ``zope.component``

- Signature: `getAdapterInContext(object, interface, context)`

- See also: `queryAdapterInContext`_

Example::

  >>> from zope.component.globalregistry import BaseGlobalComponents
  >>> from zope.component import IComponentLookup
  >>> sm = BaseGlobalComponents()

  >>> class Context(object):
  ...     def __init__(self, sm):
  ...         self.sm = sm
  ...     def __conform__(self, interface):
  ...         if interface.isOrExtends(IComponentLookup):
  ...             return self.sm

  >>> context = Context(sm)

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface

  >>> class IDesk(Interface):
  ...     """A frontdesk will register object's details"""
  ...
  ...     def register():
  ...         """Register object's details"""
  ...

  >>> from zope.interface import implements
  >>> from zope.component import adapts

  >>> class FrontDeskNG(object):
  ...
  ...     implements(IDesk)
  ...     adapts(IGuest)
  ...
  ...     def __init__(self, guest):
  ...         self.guest = guest
  ...
  ...     def register(self):
  ...         next_id = get_next_id()
  ...         bookings_db[next_id] = {
  ...         'name': guest.name,
  ...         'place': guest.place,
  ...         'phone': guest.phone
  ...         }

  >>> class Guest(object):
  ...
  ...     implements(IGuest)
  ...
  ...     def __init__(self, name, place):
  ...         self.name = name
  ...         self.place = place

  >>> jack = Guest("Jack", "Bangalore")
  >>> jack_frontdesk = FrontDeskNG(jack)

  >>> IDesk.providedBy(jack_frontdesk)
  True

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()
  >>> sm.registerAdapter(FrontDeskNG,
  ...                     (IGuest,), IDesk)

  >>> from zope.component import getAdapterInContext

  >>> getAdapterInContext(jack, IDesk, sm) #doctest: +ELLIPSIS
  <FrontDeskNG object at ...>

getAdapters
~~~~~~~~~~~

Look for all matching adapters to a provided interface for objects.
Return a list of adapters that match. If an adapter is named, only the
most specific adapter of a given name is returned.

- Location: ``zope.component``

- Signature: `getAdapters(objects, provided, context=None)`

Example::

  >>> from zope.interface import implements
  >>> from zope.component import adapts

  >>> class FrontDeskNG(object):
  ...
  ...     implements(IDesk)
  ...     adapts(IGuest)
  ...
  ...     def __init__(self, guest):
  ...         self.guest = guest
  ...
  ...     def register(self):
  ...         next_id = get_next_id()
  ...         bookings_db[next_id] = {
  ...         'name': guest.name,
  ...         'place': guest.place,
  ...         'phone': guest.phone
  ...         }

  >>> jack = Guest("Jack", "Bangalore")
  >>> jack_frontdesk = FrontDeskNG(jack)

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> gsm.registerAdapter(FrontDeskNG, name='ng')

  >>> from zope.component import getAdapters
  >>> list(getAdapters((jack,), IDesk)) #doctest: +ELLIPSIS
  [(u'ng', <FrontDeskNG object at ...>)]

getAllUtilitiesRegisteredFor
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Return all registered utilities for an interface.  This includes
overridden utilities.  The returned value is an iterable of utility
instances.

- Location: ``zope.component``

- Signature: `getAllUtilitiesRegisteredFor(interface)`

Example::

  >>> from zope.interface import Interface
  >>> from zope.interface import implements

  >>> class IGreeter(Interface):
  ...     def greet(name):
  ...         "say hello"

  >>> class Greeter(object):
  ...
  ...     implements(IGreeter)
  ...
  ...     def greet(self, name):
  ...         print "Hello", name

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> greet = Greeter()
  >>> gsm.registerUtility(greet, IGreeter)

  >>> from zope.component import getAllUtilitiesRegisteredFor

  >>> getAllUtilitiesRegisteredFor(IGreeter) #doctest: +ELLIPSIS
  [<Greeter object at ...>]

getFactoriesFor
~~~~~~~~~~~~~~~

Return a tuple (name, factory) of registered factories that create
objects which implement the given interface.

 - Location: ``zope.component``

 - Signature: `getFactoriesFor(interface, context=None)`

Example::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface
  >>> from zope.interface import implements

  >>> class IDatabase(Interface):
  ...
  ...     def getConnection():
  ...         """Return connection object"""

  >>> class FakeDb(object):
  ...
  ...     implements(IDatabase)
  ...
  ...     def getConnection(self):
  ...         return "connection"

  >>> from zope.component.factory import Factory

  >>> factory = Factory(FakeDb, 'FakeDb')

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> from zope.component.interfaces import IFactory
  >>> gsm.registerUtility(factory, IFactory, 'fakedb')

  >>> from zope.component import getFactoriesFor

  >>> list(getFactoriesFor(IDatabase))
  [(u'fakedb', <Factory for <class 'FakeDb'>>)]

getFactoryInterfaces
~~~~~~~~~~~~~~~~~~~~

Get interfaces implemented by a factory.  Finds the factory of the
given name that is nearest to the context, and returns the interface
or interface tuple that object instances created by the named factory
will implement.

- Location: ``zope.component``

- Signature: `getFactoryInterfaces(name, context=None)`

Example::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface
  >>> from zope.interface import implements

  >>> class IDatabase(Interface):
  ...
  ...     def getConnection():
  ...         """Return connection object"""

  >>> class FakeDb(object):
  ...
  ...     implements(IDatabase)
  ...
  ...     def getConnection(self):
  ...         return "connection"

  >>> from zope.component.factory import Factory

  >>> factory = Factory(FakeDb, 'FakeDb')

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> from zope.component.interfaces import IFactory
  >>> gsm.registerUtility(factory, IFactory, 'fakedb')

  >>> from zope.component import getFactoryInterfaces

  >>> getFactoryInterfaces('fakedb')
  <implementedBy __builtin__.FakeDb>

getGlobalSiteManager
~~~~~~~~~~~~~~~~~~~~

Return the global site manager.  This function should never fail and
always return an object that provides `IGlobalSiteManager`

- Location: ``zope.component``

- Signature: `getGlobalSiteManager()`

Example::

  >>> from zope.component import getGlobalSiteManager
  >>> from zope.component import globalSiteManager
  >>> gsm = getGlobalSiteManager()
  >>> gsm is globalSiteManager
  True

getMultiAdapter
~~~~~~~~~~~~~~~

Look for a multi-adapter to an interface for an objects.  Returns a
multi-adapter that can adapt objects to interface.  If a matching
adapter cannot be found, raises ComponentLookupError.  The name
consisting of an empty string is reserved for unnamed adapters. The
unnamed adapter methods will often call the named adapter methods with
an empty string for a name.

- Location: ``zope.component``

- Signature: `getMultiAdapter(objects, interface=Interface, name='',
  context=None)`

- See also: `queryMultiAdapter`_

Example::

  >>> from zope.interface import Interface
  >>> from zope.interface import implements
  >>> from zope.component import adapts

  >>> class IAdapteeOne(Interface):
  ...     pass

  >>> class IAdapteeTwo(Interface):
  ...     pass

  >>> class IFunctionality(Interface):
  ...     pass

  >>> class MyFunctionality(object):
  ...     implements(IFunctionality)
  ...     adapts(IAdapteeOne, IAdapteeTwo)
  ...
  ...     def __init__(self, one, two):
  ...         self.one = one
  ...         self.two = two

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> gsm.registerAdapter(MyFunctionality)

  >>> class One(object):
  ...     implements(IAdapteeOne)

  >>> class Two(object):
  ...     implements(IAdapteeTwo)

  >>> one = One()
  >>> two = Two()

  >>> from zope.component import getMultiAdapter

  >>> getMultiAdapter((one,two), IFunctionality) #doctest: +ELLIPSIS
  <MyFunctionality object at ...>

  >>> myfunctionality = getMultiAdapter((one,two), IFunctionality)
  >>> myfunctionality.one #doctest: +ELLIPSIS
  <One object at ...>
  >>> myfunctionality.two #doctest: +ELLIPSIS
  <Two object at ...>

getSiteManager
~~~~~~~~~~~~~~

Get the nearest site manager in the given context.  If `context` is
`None`, return the global site manager.  If the `context` is not
`None`, it is expected that an adapter from the `context` to
`IComponentLookup` can be found.  If no adapter is found, a
`ComponentLookupError` is raised.

- Location: ``zope.component``

- Signature: `getSiteManager(context=None)`

Example 1::

  >>> from zope.component.globalregistry import BaseGlobalComponents
  >>> from zope.component import IComponentLookup
  >>> sm = BaseGlobalComponents()

  >>> class Context(object):
  ...     def __init__(self, sm):
  ...         self.sm = sm
  ...     def __conform__(self, interface):
  ...         if interface.isOrExtends(IComponentLookup):
  ...             return self.sm

  >>> context = Context(sm)

  >>> from zope.component import getSiteManager

  >>> lsm = getSiteManager(context)
  >>> lsm is sm
  True

Example 2::

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> sm = getSiteManager()
  >>> gsm is sm
  True

getUtilitiesFor
~~~~~~~~~~~~~~~

Look up the registered utilities that provide an interface.  Returns
an iterable of name-utility pairs.

- Location: ``zope.component``

- Signature: `getUtilitiesFor(interface)`

Example::

  >>> from zope.interface import Interface
  >>> from zope.interface import implements

  >>> class IGreeter(Interface):
  ...     def greet(name):
  ...         "say hello"

  >>> class Greeter(object):
  ...
  ...     implements(IGreeter)
  ...
  ...     def greet(self, name):
  ...         print "Hello", name

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> greet = Greeter()
  >>> gsm.registerUtility(greet, IGreeter)

  >>> from zope.component import getUtilitiesFor

  >>> list(getUtilitiesFor(IGreeter)) #doctest: +ELLIPSIS
  [(u'', <Greeter object at ...>)]

getUtility
~~~~~~~~~~

Get the utility that provides interface.  Returns the nearest utility
to the context that implements the specified interface.  If one is not
found, raises ``ComponentLookupError``.

- Location: ``zope.component``

- Signature: `getUtility(interface, name='', context=None)`

Example::

  >>> from zope.interface import Interface
  >>> from zope.interface import implements

  >>> class IGreeter(Interface):
  ...     def greet(name):
  ...         "say hello"

  >>> class Greeter(object):
  ...
  ...     implements(IGreeter)
  ...
  ...     def greet(self, name):
  ...         return "Hello " + name

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> greet = Greeter()
  >>> gsm.registerUtility(greet, IGreeter)

  >>> from zope.component import getUtility

  >>> getUtility(IGreeter).greet('Jack')
  'Hello Jack'

handle
~~~~~~

Call all of the handlers for the given objects.  Handlers are
subscription adapter factories that don't produce anything.  They do
all of their work when called.  Handlers are typically used to handle
events.

- Location: ``zope.component``

- Signature: `handle(*objects)`

Example::

  >>> import datetime

  >>> def documentCreated(event):
  ...     event.doc.created = datetime.datetime.utcnow()

  >>> from zope.interface import Interface
  >>> from zope.interface import Attribute
  >>> from zope.interface import implements

  >>> class IDocumentCreated(Interface):
  ...     doc = Attribute("The document that was created")

  >>> class DocumentCreated(object):
  ...     implements(IDocumentCreated)
  ...
  ...     def __init__(self, doc):
  ...         self.doc = doc


  >>> def documentCreated(event):
  ...     event.doc.created = datetime.datetime.utcnow()

  >>> from zope.component import adapter

  >>> @adapter(IDocumentCreated)
  ... def documentCreated(event):
  ...     event.doc.created = datetime.datetime.utcnow()


  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> gsm.registerHandler(documentCreated)

  >>> from zope.component import handle

  >>> handle(DocumentCreated(doc))
  >>> doc.created.__class__.__name__
  'datetime'

implementedBy
~~~~~~~~~~~~~

Return the interfaces implemented for a class' instances.

- Location: ``zope.interface``

- Signature: `implementedBy(class_)`

Example 1::

  >>> from zope.interface import Interface
  >>> from zope.interface import implements

  >>> class IGreeter(Interface):
  ...     def greet(name):
  ...         "say hello"

  >>> class Greeter(object):
  ...
  ...     implements(IGreeter)
  ...
  ...     def greet(self, name):
  ...         print "Hello", name

  >>> from zope.interface import implementedBy
  >>> implementedBy(Greeter)
  <implementedBy __builtin__.Greeter>

Example 2::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface
  >>> from zope.interface import implements

  >>> class IPerson(Interface):
  ...     name = Attribute("Name of person")

  >>> class ISpecial(Interface):
  ...     pass

  >>> class Person(object):
  ...     implements(IPerson)
  ...     name = u""

  >>> from zope.interface import classImplements
  >>> classImplements(Person, ISpecial)

  >>> from zope.interface import implementedBy

  To get a list of all interfaces implemented by that class::

  >>> [x.__name__ for x in implementedBy(Person)]
  ['IPerson', 'ISpecial']

implementer
~~~~~~~~~~~

Create a decorator for declaring interfaces implemented by a factory.
A callable is returned that makes an implements declaration on objects
passed to it.

- Location: ``zope.interface``

- Signature: `implementer(*interfaces)`

Example::

  >>> from zope.interface import implementer
  >>> class IFoo(Interface):
  ...     pass
  >>> class Foo(object):
  ...     implements(IFoo)

  >>> @implementer(IFoo)
  ... def foocreator():
  ...     foo = Foo()
  ...     return foo
  >>> list(implementedBy(foocreator))
  [<InterfaceClass __builtin__.IFoo>]

implements
~~~~~~~~~~

Declare interfaces implemented by instances of a class This function
is called in a class definition.  The arguments are one or more
interfaces.  The interfaces given are added to any interfaces
previously declared.  Previous declarations include declarations for
base classes unless implementsOnly was used.

- Location: ``zope.interface``

- Signature: `implements(*interfaces)`

Example::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface
  >>> from zope.interface import implements

  >>> class IPerson(Interface):
  ...
  ...     name = Attribute("Name of person")

  >>> class Person(object):
  ...
  ...     implements(IPerson)
  ...     name = u""

  >>> jack = Person()
  >>> jack.name = "Jack"

  You can test it like this:

  >>> from zope.interface import providedBy
  >>> IPerson in providedBy(jack)
  True

implementsOnly
~~~~~~~~~~~~~~

Declare the only interfaces implemented by instances of a class.  This
function is called in a class definition.  The arguments are one or
more interfaces.  Previous declarations including declarations for
base classes are overridden.

- Location: ``zope.interface``

- Signature: `implementsOnly(*interfaces)`

Example::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface
  >>> from zope.interface import implements
  >>> from zope.interface import implementsOnly

  >>> class IPerson(Interface):
  ...
  ...     name = Attribute("Name of person")

  >>> class IStudent(Interface):
  ...
  ...     college = Attribute("Name of college")

  >>> class Person(object):
  ...
  ...     implements(IPerson)
  ...     name = u""

  >>> class NewPerson(Person):
  ...     implementsOnly(IStudent)
  ...     college = u""

  >>> jack = NewPerson()
  >>> jack.college = "New College"

  You can test it like this:

  >>> from zope.interface import providedBy
  >>> IPerson in providedBy(jack)
  False
  >>> IStudent in providedBy(jack)
  True

Interface
~~~~~~~~~

Using this class, you can define an interface.  To define an
interface, just inherit from ``Interface`` class.

- Location: ``zope.interface``

- Signature: `Interface(name, doc='')`

Example 1::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface

  >>> class IPerson(Interface):
  ...
  ...     name = Attribute("Name of person")
  ...     email = Attribute("Email Address")


Example 2::

  >>> from zope.interface import Interface

  >>> class IHost(Interface):
  ...
  ...     def goodmorning(guest):
  ...         """Say good morning to guest"""

moduleProvides
~~~~~~~~~~~~~~

Declare interfaces provided by a module.  This function is used in a
module definition.  The arguments are one or more interfaces.  The
given interfaces are used to create the module's direct-object
interface specification.  An error will be raised if the module
already has an interface specification.  In other words, it is an
error to call this function more than once in a module definition.

This function is provided for convenience.  It provides a more
convenient way to call ``directlyProvides`` for a module.

- Location: ``zope.interface``

- Signature: `moduleProvides(*interfaces)`

- See also: `directlyProvides`_

You can see an example usage in `zope.component` source itself.  The
`__init__.py` file has a statement like this::

  moduleProvides(IComponentArchitecture,
                 IComponentRegistrationConvenience)

So, the `zope.component` provides two interfaces:
`IComponentArchitecture` and `IComponentRegistrationConvenience`.

noLongerProvides
~~~~~~~~~~~~~~~~

Remove an interface from the list of an object's directly provided
interfaces.

- Location: ``zope.interface``

- Signature: `noLongerProvides(object, interface)`

Example::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface
  >>> from zope.interface import implements
  >>> from zope.interface import classImplements

  >>> class IPerson(Interface):
  ...
  ...     name = Attribute("Name of person")

  >>> class IStudent(Interface):
  ...
  ...     college = Attribute("Name of college")

  >>> class Person(object):
  ...
  ...     implements(IPerson)
  ...     name = u""

  >>> jack = Person()
  >>> jack.name = "Jack"
  >>> jack.college = "New College"
  >>> directlyProvides(jack, IStudent)

  You can test it like this:

  >>> from zope.interface import providedBy
  >>> IPerson in providedBy(jack)
  True
  >>> IStudent in providedBy(jack)
  True
  >>> from zope.interface import noLongerProvides
  >>> noLongerProvides(jack, IStudent)
  >>> IPerson in providedBy(jack)
  True
  >>> IStudent in providedBy(jack)
  False

provideAdapter
~~~~~~~~~~~~~~

It is recommended to use `registerAdapter`_ .

provideHandler
~~~~~~~~~~~~~~

It is recommended to use `registerHandler`_ .

provideSubscriptionAdapter
~~~~~~~~~~~~~~~~~~~~~~~~~~

It is recommended to use `registerSubscriptionAdapter`_ .

provideUtility
~~~~~~~~~~~~~~

It is recommended to use `registerUtility`_ .

providedBy
~~~~~~~~~~

Test whether the interface is implemented by the object.  Return true
if the object asserts that it implements the interface, including
asserting that it implements an extended interface.

- Location: ``zope.interface``

- Signature: `providedBy(object)`

Example 1::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface
  >>> from zope.interface import implements

  >>> class IPerson(Interface):
  ...
  ...     name = Attribute("Name of person")

  >>> class Person(object):
  ...
  ...     implements(IPerson)
  ...     name = u""

  >>> jack = Person()
  >>> jack.name = "Jack"

  You can test it like this:

  >>> from zope.interface import providedBy
  >>> IPerson in providedBy(jack)
  True

Example 2::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface
  >>> from zope.interface import implements

  >>> class IPerson(Interface):
  ...     name = Attribute("Name of person")

  >>> class ISpecial(Interface):
  ...     pass

  >>> class Person(object):
  ...     implements(IPerson)
  ...     name = u""

  >>> from zope.interface import classImplements
  >>> classImplements(Person, ISpecial)
  >>> from zope.interface import providedBy
  >>> jack = Person()
  >>> jack.name = "Jack"

  To get a list of all interfaces provided by that object::

  >>> [x.__name__ for x in providedBy(jack)]
  ['IPerson', 'ISpecial']

queryAdapter
~~~~~~~~~~~~

Look for a named adapter to an interface for an object.  Returns an
adapter that can adapt object to interface.  If a matching adapter
cannot be found, returns the default.

- Location: ``zope.component``

- Signature: `queryAdapter(object, interface=Interface, name=u'',
  default=None, context=None)`

Example::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface

  >>> class IDesk(Interface):
  ...     """A frontdesk will register object's details"""
  ...
  ...     def register():
  ...         """Register object's details"""
  ...

  >>> from zope.interface import implements
  >>> from zope.component import adapts

  >>> class FrontDeskNG(object):
  ...
  ...     implements(IDesk)
  ...     adapts(IGuest)
  ...
  ...     def __init__(self, guest):
  ...         self.guest = guest
  ...
  ...     def register(self):
  ...         next_id = get_next_id()
  ...         bookings_db[next_id] = {
  ...         'name': guest.name,
  ...         'place': guest.place,
  ...         'phone': guest.phone
  ...         }

  >>> class Guest(object):
  ...
  ...     implements(IGuest)
  ...
  ...     def __init__(self, name, place):
  ...         self.name = name
  ...         self.place = place

  >>> jack = Guest("Jack", "Bangalore")
  >>> jack_frontdesk = FrontDeskNG(jack)

  >>> IDesk.providedBy(jack_frontdesk)
  True

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()
  >>> gsm.registerAdapter(FrontDeskNG,
  ...                     (IGuest,), IDesk, 'ng')

  >>> queryAdapter(jack, IDesk, 'ng') #doctest: +ELLIPSIS
  <FrontDeskNG object at ...>

queryAdapterInContext
~~~~~~~~~~~~~~~~~~~~~

Look for a special adapter to an interface for an object.

NOTE: This method should only be used if a custom context needs to be
provided to provide custom component lookup. Otherwise, call the
interface, as in::

  interface(object, default)

Returns an adapter that can adapt object to interface.  If a matching
adapter cannot be found, returns the default.

Context is adapted to IServiceService, and this adapter's 'Adapters'
service is used.

If the object has a __conform__ method, this method will be called
with the requested interface.  If the method returns a non-None value,
that value will be returned. Otherwise, if the object already
implements the interface, the object will be returned.

- Location: ``zope.component``

- Signature: `queryAdapterInContext(object, interface, context,
  default=None)`

- See also: `getAdapterInContext`_

Example::

  >>> from zope.component.globalregistry import BaseGlobalComponents
  >>> from zope.component import IComponentLookup
  >>> sm = BaseGlobalComponents()

  >>> class Context(object):
  ...     def __init__(self, sm):
  ...         self.sm = sm
  ...     def __conform__(self, interface):
  ...         if interface.isOrExtends(IComponentLookup):
  ...             return self.sm

  >>> context = Context(sm)

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface

  >>> class IDesk(Interface):
  ...     """A frontdesk will register object's details"""
  ...
  ...     def register():
  ...         """Register object's details"""
  ...

  >>> from zope.interface import implements
  >>> from zope.component import adapts

  >>> class FrontDeskNG(object):
  ...
  ...     implements(IDesk)
  ...     adapts(IGuest)
  ...
  ...     def __init__(self, guest):
  ...         self.guest = guest
  ...
  ...     def register(self):
  ...         next_id = get_next_id()
  ...         bookings_db[next_id] = {
  ...         'name': guest.name,
  ...         'place': guest.place,
  ...         'phone': guest.phone
  ...         }

  >>> class Guest(object):
  ...
  ...     implements(IGuest)
  ...
  ...     def __init__(self, name, place):
  ...         self.name = name
  ...         self.place = place

  >>> jack = Guest("Jack", "Bangalore")
  >>> jack_frontdesk = FrontDeskNG(jack)

  >>> IDesk.providedBy(jack_frontdesk)
  True

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()
  >>> sm.registerAdapter(FrontDeskNG,
  ...                     (IGuest,), IDesk)

  >>> from zope.component import queryAdapterInContext

  >>> queryAdapterInContext(jack, IDesk, sm) #doctest: +ELLIPSIS
  <FrontDeskNG object at ...>

queryMultiAdapter
~~~~~~~~~~~~~~~~~

Look for a multi-adapter to an interface for objects.  Returns a
multi-adapter that can adapt objects to interface.  If a matching
adapter cannot be found, returns the default.  The name consisting of
an empty string is reserved for unnamed adapters.  The unnamed adapter
methods will often call the named adapter methods with an empty string
for a name.

- Location: ``zope.component``

- Signature: `queryMultiAdapter(objects, interface=Interface,
  name=u'', default=None, context=None)`

- See also: `getMultiAdapter`_

Example::

  >>> from zope.interface import Interface
  >>> from zope.interface import implements
  >>> from zope.component import adapts

  >>> class IAdapteeOne(Interface):
  ...     pass

  >>> class IAdapteeTwo(Interface):
  ...     pass

  >>> class IFunctionality(Interface):
  ...     pass

  >>> class MyFunctionality(object):
  ...     implements(IFunctionality)
  ...     adapts(IAdapteeOne, IAdapteeTwo)
  ...
  ...     def __init__(self, one, two):
  ...         self.one = one
  ...         self.two = two

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> gsm.registerAdapter(MyFunctionality)

  >>> class One(object):
  ...     implements(IAdapteeOne)

  >>> class Two(object):
  ...     implements(IAdapteeTwo)

  >>> one = One()
  >>> two = Two()

  >>> from zope.component import queryMultiAdapter

  >>> getMultiAdapter((one,two), IFunctionality) #doctest: +ELLIPSIS
  <MyFunctionality object at ...>

  >>> myfunctionality = queryMultiAdapter((one,two), IFunctionality)
  >>> myfunctionality.one #doctest: +ELLIPSIS
  <One object at ...>
  >>> myfunctionality.two #doctest: +ELLIPSIS
  <Two object at ...>

queryUtility
~~~~~~~~~~~~

This function is used to look up a utility that provides an interface.
If one is not found, returns default.

- Location: ``zope.component``

- Signature: `queryUtility(interface, name='', default=None)`

Example::

  >>> from zope.interface import Interface
  >>> from zope.interface import implements

  >>> class IGreeter(Interface):
  ...     def greet(name):
  ...         "say hello"

  >>> class Greeter(object):
  ...
  ...     implements(IGreeter)
  ...
  ...     def greet(self, name):
  ...         return "Hello " + name

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> greet = Greeter()
  >>> gsm.registerUtility(greet, IGreeter)

  >>> from zope.component import queryUtility

  >>> queryUtility(IGreeter).greet('Jack')
  'Hello Jack'

registerAdapter
~~~~~~~~~~~~~~~

This function is used to register an adapter factory.

- Location: ``zope.component - IComponentRegistry``

- Signature: `registerAdapter(factory, required=None, provided=None,
  name=u'', info=u'')`

- See also: `unregisterAdapter`_

Example::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface

  >>> class IDesk(Interface):
  ...     """A frontdesk will register object's details"""
  ...
  ...     def register():
  ...         """Register object's details"""
  ...

  >>> from zope.interface import implements
  >>> from zope.component import adapts

  >>> class FrontDeskNG(object):
  ...
  ...     implements(IDesk)
  ...     adapts(IGuest)
  ...
  ...     def __init__(self, guest):
  ...         self.guest = guest
  ...
  ...     def register(self):
  ...         next_id = get_next_id()
  ...         bookings_db[next_id] = {
  ...         'name': guest.name,
  ...         'place': guest.place,
  ...         'phone': guest.phone
  ...         }

  >>> class Guest(object):
  ...
  ...     implements(IGuest)
  ...
  ...     def __init__(self, name, place):
  ...         self.name = name
  ...         self.place = place

  >>> jack = Guest("Jack", "Bangalore")
  >>> jack_frontdesk = FrontDeskNG(jack)

  >>> IDesk.providedBy(jack_frontdesk)
  True

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()
  >>> gsm.registerAdapter(FrontDeskNG,
  ...                     (IGuest,), IDesk, 'ng')

  You can test it like this:

  >>> queryAdapter(jack, IDesk, 'ng') #doctest: +ELLIPSIS
  <FrontDeskNG object at ...>

registeredAdapters
~~~~~~~~~~~~~~~~~~

Return an iterable of `IAdapterRegistrations`.  These registrations
describe the current adapter registrations in the object.

- Location: ``zope.component - IComponentRegistry``

- Signature: `registeredAdapters()`

Example::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface

  >>> class IDesk(Interface):
  ...     """A frontdesk will register object's details"""
  ...
  ...     def register():
  ...         """Register object's details"""
  ...

  >>> from zope.interface import implements
  >>> from zope.component import adapts

  >>> class FrontDeskNG(object):
  ...
  ...     implements(IDesk)
  ...     adapts(IGuest)
  ...
  ...     def __init__(self, guest):
  ...         self.guest = guest
  ...
  ...     def register(self):
  ...         next_id = get_next_id()
  ...         bookings_db[next_id] = {
  ...         'name': guest.name,
  ...         'place': guest.place,
  ...         'phone': guest.phone
  ...         }

  >>> class Guest(object):
  ...
  ...     implements(IGuest)
  ...
  ...     def __init__(self, name, place):
  ...         self.name = name
  ...         self.place = place

  >>> jack = Guest("Jack", "Bangalore")
  >>> jack_frontdesk = FrontDeskNG(jack)

  >>> IDesk.providedBy(jack_frontdesk)
  True

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()
  >>> gsm.registerAdapter(FrontDeskNG,
  ...                     (IGuest,), IDesk, 'ng2')


  >>> reg_adapter = list(gsm.registeredAdapters())
  >>> 'ng2' in [x.name for x in reg_adapter]
  True

registeredHandlers
~~~~~~~~~~~~~~~~~~

Return an iterable of `IHandlerRegistrations`.  These registrations
describe the current handler registrations in the object.

- Location: ``zope.component - IComponentRegistry``

- Signature: `registeredHandlers()`

Example::

  >>> import datetime

  >>> def documentCreated(event):
  ...     event.doc.created = datetime.datetime.utcnow()

  >>> from zope.interface import Interface
  >>> from zope.interface import Attribute
  >>> from zope.interface import implements

  >>> class IDocumentCreated(Interface):
  ...     doc = Attribute("The document that was created")

  >>> class DocumentCreated(object):
  ...     implements(IDocumentCreated)
  ...
  ...     def __init__(self, doc):
  ...         self.doc = doc


  >>> def documentCreated(event):
  ...     event.doc.created = datetime.datetime.utcnow()

  >>> from zope.component import adapter

  >>> @adapter(IDocumentCreated)
  ... def documentCreated(event):
  ...     event.doc.created = datetime.datetime.utcnow()


  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> gsm.registerHandler(documentCreated, info='ng3')

  >>> reg_adapter = list(gsm.registeredHandlers())
  >>> 'ng3' in [x.info for x in reg_adapter]
  True

  >>> gsm.registerHandler(documentCreated, name='ng4')
  Traceback (most recent call last):
  ...
  TypeError: Named handlers are not yet supported

registeredSubscriptionAdapters
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Return an iterable of `ISubscriptionAdapterRegistrations`.  These
registrations describe the current subscription adapter registrations
in the object.

- Location: ``zope.component - IComponentRegistry``

- Signature: `registeredSubscriptionAdapters()`

Example::

  >>> from zope.interface import Interface
  >>> from zope.interface import Attribute
  >>> from zope.interface import implements

  >>> class IValidate(Interface):
  ...     def validate(ob):
  ...         """Determine whether the object is valid
  ...
  ...         Return a string describing a validation problem.
  ...         An empty string is returned to indicate that the
  ...         object is valid.
  ...         """

  >>> class IDocument(Interface):
  ...     summary = Attribute("Document summary")
  ...     body = Attribute("Document text")

  >>> class Document(object):
  ...     implements(IDocument)
  ...     def __init__(self, summary, body):
  ...         self.summary, self.body = summary, body

  >>> from zope.component import adapts

  >>> class AdequateLength(object):
  ...
  ...     adapts(IDocument)
  ...     implements(IValidate)
  ...
  ...     def __init__(self, doc):
  ...         self.doc = doc
  ...
  ...     def validate(self):
  ...         if len(self.doc.body) < 1000:
  ...             return 'too short'
  ...         else:
  ...             return ''

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> gsm.registerSubscriptionAdapter(AdequateLength, info='ng4')

  >>> reg_adapter = list(gsm.registeredSubscriptionAdapters())
  >>> 'ng4' in [x.info for x in reg_adapter]
  True

registeredUtilities
~~~~~~~~~~~~~~~~~~~

This function return an iterable of `IUtilityRegistrations`.  These
registrations describe the current utility registrations in the
object.

- Location: ``zope.component - IComponentRegistry``

- Signature: `registeredUtilities()`

Example::

  >>> from zope.interface import Interface
  >>> from zope.interface import implements

  >>> class IGreeter(Interface):
  ...     def greet(name):
  ...         "say hello"

  >>> class Greeter(object):
  ...
  ...     implements(IGreeter)
  ...
  ...     def greet(self, name):
  ...         print "Hello", name

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> greet = Greeter()
  >>> gsm.registerUtility(greet, info='ng5')

  >>> reg_adapter = list(gsm.registeredUtilities())
  >>> 'ng5' in [x.info for x in reg_adapter]
  True

registerHandler
~~~~~~~~~~~~~~~

This function is used to register a handler.  A handler is a
subscriber that doesn't compute an adapter but performs some function
when called.

- Location: ``zope.component - IComponentRegistry``

- Signature: `registerHandler(handler, required=None, name=u'', info='')`

- See also: `unregisterHandler`_

Note: In the current implementation of ``zope.component`` doesn't
support `name` attribute.

Example::

  >>> import datetime

  >>> def documentCreated(event):
  ...     event.doc.created = datetime.datetime.utcnow()

  >>> from zope.interface import Interface
  >>> from zope.interface import Attribute
  >>> from zope.interface import implements

  >>> class IDocumentCreated(Interface):
  ...     doc = Attribute("The document that was created")

  >>> class DocumentCreated(object):
  ...     implements(IDocumentCreated)
  ...
  ...     def __init__(self, doc):
  ...         self.doc = doc


  >>> def documentCreated(event):
  ...     event.doc.created = datetime.datetime.utcnow()

  >>> from zope.component import adapter

  >>> @adapter(IDocumentCreated)
  ... def documentCreated(event):
  ...     event.doc.created = datetime.datetime.utcnow()


  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> gsm.registerHandler(documentCreated)

  >>> from zope.component import handle

  >>> handle(DocumentCreated(doc))
  >>> doc.created.__class__.__name__
  'datetime'

registerSubscriptionAdapter
~~~~~~~~~~~~~~~~~~~~~~~~~~~

This function is used to register a subscriber factory.

- Location: ``zope.component - IComponentRegistry``

- Signature: `registerSubscriptionAdapter(factory, required=None,
  provides=None, name=u'', info='')`

- See also: `unregisterSubscriptionAdapter`_

Example::

  >>> from zope.interface import Interface
  >>> from zope.interface import Attribute
  >>> from zope.interface import implements

  >>> class IValidate(Interface):
  ...     def validate(ob):
  ...         """Determine whether the object is valid
  ...
  ...         Return a string describing a validation problem.
  ...         An empty string is returned to indicate that the
  ...         object is valid.
  ...         """

  >>> class IDocument(Interface):
  ...     summary = Attribute("Document summary")
  ...     body = Attribute("Document text")

  >>> class Document(object):
  ...     implements(IDocument)
  ...     def __init__(self, summary, body):
  ...         self.summary, self.body = summary, body

  >>> from zope.component import adapts

  >>> class AdequateLength(object):
  ...
  ...     adapts(IDocument)
  ...     implements(IValidate)
  ...
  ...     def __init__(self, doc):
  ...         self.doc = doc
  ...
  ...     def validate(self):
  ...         if len(self.doc.body) < 1000:
  ...             return 'too short'
  ...         else:
  ...             return ''

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> gsm.registerSubscriptionAdapter(AdequateLength)

registerUtility
~~~~~~~~~~~~~~~

This function is used to register a utility.

- Location: ``zope.component - IComponentRegistry``

- Signature: `registerUtility(component, provided=None, name=u'',
  info=u'')`

- See also: `unregisterUtility`_

Example::

  >>> from zope.interface import Interface
  >>> from zope.interface import implements

  >>> class IGreeter(Interface):
  ...     def greet(name):
  ...         "say hello"

  >>> class Greeter(object):
  ...
  ...     implements(IGreeter)
  ...
  ...     def greet(self, name):
  ...         print "Hello", name

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> greet = Greeter()
  >>> gsm.registerUtility(greet)

subscribers
~~~~~~~~~~~

This function is used to get subscribers.  Subscribers are returned
that provide the provided interface and that depend on and are
computed from the sequence of required objects.

- Location: ``zope.component - IComponentRegistry``

- Signature: `subscribers(required, provided, context=None)`

Example::

  >>> from zope.interface import Interface
  >>> from zope.interface import Attribute
  >>> from zope.interface import implements

  >>> class IValidate(Interface):
  ...     def validate(ob):
  ...         """Determine whether the object is valid
  ...
  ...         Return a string describing a validation problem.
  ...         An empty string is returned to indicate that the
  ...         object is valid.
  ...         """

  >>> class IDocument(Interface):
  ...     summary = Attribute("Document summary")
  ...     body = Attribute("Document text")

  >>> class Document(object):
  ...     implements(IDocument)
  ...     def __init__(self, summary, body):
  ...         self.summary, self.body = summary, body

  >>> from zope.component import adapts

  >>> class SingleLineSummary:
  ...     adapts(IDocument)
  ...     implements(IValidate)
  ...
  ...     def __init__(self, doc):
  ...         self.doc = doc
  ...
  ...     def validate(self):
  ...         if '\n' in self.doc.summary:
  ...             return 'Summary should only have one line'
  ...         else:
  ...             return ''

  >>> class AdequateLength(object):
  ...     adapts(IDocument)
  ...     implements(IValidate)
  ...
  ...     def __init__(self, doc):
  ...         self.doc = doc
  ...
  ...     def validate(self):
  ...         if len(self.doc.body) < 1000:
  ...             return 'too short'
  ...         else:
  ...             return ''

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> gsm.registerSubscriptionAdapter(SingleLineSummary)
  >>> gsm.registerSubscriptionAdapter(AdequateLength)

  >>> from zope.component import subscribers

  >>> doc = Document("A\nDocument", "blah")
  >>> [adapter.validate()
  ...  for adapter in subscribers([doc], IValidate)
  ...  if adapter.validate()]
  ['Summary should only have one line', 'too short']

  >>> doc = Document("A\nDocument", "blah" * 1000)
  >>> [adapter.validate()
  ...  for adapter in subscribers([doc], IValidate)
  ...  if adapter.validate()]
  ['Summary should only have one line']

  >>> doc = Document("A Document", "blah")
  >>> [adapter.validate()
  ...  for adapter in subscribers([doc], IValidate)
  ...  if adapter.validate()]
  ['too short']

unregisterAdapter
~~~~~~~~~~~~~~~~~

This function is used to unregister an adapter factory.  A boolean is
returned indicating whether the registry was changed.  If the given
component is None and there is no component registered, or if the
given component is not None and is not registered, then the function
returns False, otherwise it returns True.

- Location: ``zope.component - IComponentRegistry``

- Signature: `unregisterAdapter(factory=None, required=None,
  provided=None, name=u'')`

- See also: `registerAdapter`_

Example::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface

  >>> class IDesk(Interface):
  ...     """A frontdesk will register object's details"""
  ...
  ...     def register():
  ...         """Register object's details"""
  ...

  >>> from zope.interface import implements
  >>> from zope.component import adapts

  >>> class FrontDeskNG(object):
  ...
  ...     implements(IDesk)
  ...     adapts(IGuest)
  ...
  ...     def __init__(self, guest):
  ...         self.guest = guest
  ...
  ...     def register(self):
  ...         next_id = get_next_id()
  ...         bookings_db[next_id] = {
  ...         'name': guest.name,
  ...         'place': guest.place,
  ...         'phone': guest.phone
  ...         }

  >>> class Guest(object):
  ...
  ...     implements(IGuest)
  ...
  ...     def __init__(self, name, place):
  ...         self.name = name
  ...         self.place = place

  >>> jack = Guest("Jack", "Bangalore")
  >>> jack_frontdesk = FrontDeskNG(jack)

  >>> IDesk.providedBy(jack_frontdesk)
  True

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()
  >>> gsm.registerAdapter(FrontDeskNG,
  ...                     (IGuest,), IDesk, 'ng6')

  You can test it like this:

  >>> queryAdapter(jack, IDesk, 'ng6') #doctest: +ELLIPSIS
  <FrontDeskNG object at ...>

  Now unregister:

  >>> gsm.unregisterAdapter(FrontDeskNG, name='ng6')
  True

  After unregistration:

  >>> print queryAdapter(jack, IDesk, 'ng6')
  None

unregisterHandler
~~~~~~~~~~~~~~~~~

This function is used for unregistering a handler.  A handler is a
subscriber that doesn't compute an adapter but performs some function
when called.  A boolean is returned indicating whether the registry
was changed.

- Location: ``zope.component - IComponentRegistry``

- Signature: `unregisterHandler(handler=None, required=None,
  name=u'')`

- See also: `registerHandler`_

Example::

  >>> from zope.interface import Interface
  >>> from zope.interface import Attribute
  >>> from zope.interface import implements

  >>> class IDocument(Interface):
  ...
  ...     summary = Attribute("Document summary")
  ...     body = Attribute("Document text")

  >>> class Document(object):
  ...
  ...     implements(IDocument)
  ...     def __init__(self, summary, body):
  ...         self.summary, self.body = summary, body

  >>> doc = Document("A\nDocument", "blah")

  >>> class IDocumentAccessed(Interface):
  ...     doc = Attribute("The document that was accessed")

  >>> class DocumentAccessed(object):
  ...     implements(IDocumentAccessed)
  ...
  ...     def __init__(self, doc):
  ...         self.doc = doc
  ...         self.doc.count = 0

  >>> from zope.component import adapter

  >>> @adapter(IDocumentAccessed)
  ... def documentAccessed(event):
  ...     event.doc.count = event.doc.count + 1

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> gsm.registerHandler(documentAccessed)

  >>> from zope.component import handle

  >>> handle(DocumentAccessed(doc))
  >>> doc.count
  1

  Now unregister:

  >>> gsm.unregisterHandler(documentAccessed)
  True

  After unregistration:

  >>> handle(DocumentAccessed(doc))
  >>> doc.count
  0

unregisterSubscriptionAdapter
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This function is used to unregister a subscriber factory.  A boolean
is returned indicating whether the registry was changed.  If the given
component is None and there is no component registered, or if the
given component is not None and is not registered, then the function
returns False, otherwise it returns True.

- Location: ``zope.component - IComponentRegistry``

- Signature: `unregisterSubscriptionAdapter(factory=None,
  required=None, provides=None, name=u'')`

- See also: `registerSubscriptionAdapter`_

Example::

  >>> from zope.interface import Interface
  >>> from zope.interface import Attribute
  >>> from zope.interface import implements

  >>> class IValidate(Interface):
  ...     def validate(ob):
  ...         """Determine whether the object is valid
  ...
  ...         Return a string describing a validation problem.
  ...         An empty string is returned to indicate that the
  ...         object is valid.
  ...         """

  >>> class IDocument(Interface):
  ...     summary = Attribute("Document summary")
  ...     body = Attribute("Document text")

  >>> class Document(object):
  ...     implements(IDocument)
  ...     def __init__(self, summary, body):
  ...         self.summary, self.body = summary, body

  >>> from zope.component import adapts

  >>> class AdequateLength(object):
  ...
  ...     adapts(IDocument)
  ...     implements(IValidate)
  ...
  ...     def __init__(self, doc):
  ...         self.doc = doc
  ...
  ...     def validate(self):
  ...         if len(self.doc.body) < 1000:
  ...             return 'too short'
  ...         else:
  ...             return ''

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> gsm.registerSubscriptionAdapter(AdequateLength)

  >>> from zope.component import subscribers

  >>> doc = Document("A\nDocument", "blah")
  >>> [adapter.validate()
  ...  for adapter in subscribers([doc], IValidate)
  ...  if adapter.validate()]
  ['too short']

  Теперь отменяем регистрацию:

  >>> gsm.unregisterSubscriptionAdapter(AdequateLength)
  True

  После отмены регистрации:

  >>> [adapter.validate()
  ...  for adapter in subscribers([doc], IValidate)
  ...  if adapter.validate()]
  []

unregisterUtility
~~~~~~~~~~~~~~~~~

[Переписать на русский!!!]Эта функция используется для отмены регичтрации утилиты.  Функция
возвращает логическое значение, в зависимости от того, произошло
изменение реестра или нет.  Если значение параметра `component` - None и
ранее не было зарегистрировано никаких компонент, или же если
сзначение этого параметна не None и такой компоненты ранее не было
зарегистрировано, то функция возвращает False. В других случаях
функция возвращает True.

- Расположение: ``zope.component - IComponentRegistry``

- Сигнатура: `unregisterUtility(component=None, provided=None,
  name=u'')`

- Смотри также: `registerUtility`_

Example::

  >>> from zope.interface import Interface
  >>> from zope.interface import implements

  >>> class IGreeter(Interface):
  ...     def greet(name):
  ...         "say hello"

  >>> class Greeter(object):
  ...
  ...     implements(IGreeter)
  ...
  ...     def greet(self, name):
  ...         return "Hello " + name

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> greet = Greeter()
  >>> gsm.registerUtility(greet)

  >>> queryUtility(IGreeter).greet('Jack')
  'Hello Jack'

  Теперь отменяем регистрацию:

  >>> gsm.unregisterUtility(greet)
  True

  После отмены регистрации:

  >>> print queryUtility(IGreeter)
  None

..

   Local Variables:
   eval: (rst-mode)
   End:
