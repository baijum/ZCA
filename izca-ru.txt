===========================================================================================================
Обстоятельное руководство по компонентной архитектуре Zope
===========================================================================================================

:Автор: Baiju M
:Версия: 0.5.8
:Печатный экземпляр на англ. языке: `http://www.lulu.com/content/1561045
                    <http://www.lulu.com/content/1561045>`_
:PDF-версия оригинала на англ.: `http://www.muthukadan.net/docs/zca.pdf
                  <http://www.muthukadan.net/docs/zca.pdf>`_
:Перевод: Черкашин Евгений Александрович
:Версия перевода: 0.1


Copyright (C) 2007,2008,2009 Baiju M <baiju.m.mail AT gmail.com>.

Разрешается копировать, распространять и/или вносить изменения в этот
документ при соблюдении условий лицензии GNU Free Documentation
License, версия 1.2 или (по вашему желанию) какой-либо поздней версии,
официально опубликованной Фондом свободного программного обеспечения
(Free Software Foundation).

Исходный код программ, приведенный в этом документе, распространяется
при соблюдении положений лицензии Zope Public License, версии 2.1
(ZPL).

ИСХОДНЫЙ КОД ПРОГРАММ В ЭТОМ ДОКУМЕНТЕ И САМ ДОКУМЕНТ ПЕРЕДАЮТСЯ
ПОЛЬЗОВАТЕЛЮ "КАК ЕСТЬ" ("AS IS") AND ANY AND ALL EXPRESS OR IMPLIED
WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND
FITNESS FOR A PARTICULAR PURPOSE.

.. sidebar:: Благодарности

  Много людей помогли мне написать эту книгу.  Первоначальный
  манускрипт отрецензирован моим коллегой Брэдом Алленом (Brad Allen).
  Когда я объявил о книге в моем блоге, общественность вдохновила меня
  продолжить ее совершенствование.  Кент Тенни (Kent Tenney) творчески
  обработал практически все разделы книги, кроме того, он переписал
  основной пример - приложение.  Многие присылали мне замечания,
  исправления ошибок и недочетов, в том числе Лоренсо Санчеса (Lorenzo Gil
  Sanchez), Михаэль Гаубенвалнера (Michael Haubenwallner), Нандо
  Куинтан (Nando Quintana), Стефани Кляйн (Stephane Klein), Тим Кук
  (Tim Cook), Камал Джилл (Kamal Gill) и Томас Герв (Thomas
  Herve).  Лоренсо перевел книгу на испанский язык, а Стефани на
  французский.  Огромное всем спасибо!

  При переводе на русский язык неоценимую помощь оказал Антон
  Кочнев. Спасибо ему за это.

.. contents::
.. .. sectnum::

Приступая к работе
------------------



Введение
~~~~~~~~

Разработка больших программных систем практически всегда является
сложным и трудоемким занятием, где объектно-ориентированный подход к
анализу, проектированию и реализации (программированию) достаточно
хорошо себя зарекомендовал.  Проектирование и разработка программного
обеспечения, основывающиеся на компонентах, становятся все более и
более популярными подходом.  Компонентный подход и unit-тестирование
позволяет достаточно просто разрабатывать и поддерживать программные
системы.  Существует много различных программных инфраструктур и
инструментариев разработчика (frameworks, фреймворков), реализующих
компонентное проектирование в разных языках и средах программирования,
некоторые даже не зависят от какой-либо конкретной среды разработки.
Примерами выступают COM, разработанный Microsoft, и XPCOM - Mozilla.

**Компонентная архитектура Zope (Zope Component Architecture, ZCA)** -
это одна из таких инфраструктур, разработанной для в среды
программирования Python, реализующих компонентный подход к
проектированию и программированию.  Он позволяет разрабатывать большие
программные системы в среде программирования Python.  И делает это
совсем не плохо.  Компонентная архитектура ZCA не требует для своего
использования сервера приложений Zope, ZCA может использоваться в
разработке любого Python-приложения.  Справедливо было бы назвать ZCA
`компонентной архитектурой Python` (Python Component Architecture).

ZCA позволяет использовать объекты Python эффективно.  `Компоненты` -
это объекты, которые легко использовать повторно, а к их интерфейсам
можно получить полный доступ во время исполнения программы
(introspection).  `Интерфейс` - это объект, который описывает как
следует взаимодействовать с конкретной компонентой.  Другими словами,
компонента `[обслуживает, оснащает, оборудует] сервисы` (provide), определенные в
интерфейсе.  Компонента `реализуется` (implemented) в виде класса
(class) или другого исполняемого объекта (callable object).  И не
важно, как реализована эта компонента, а вот что важно - это то, что
она соответствует `требованиям`, определенным в интерфейсе (interface
contract).  При помощи ZCA сложность системы распределяется между
множеством кооперирующихся компонент.  Механизм такой кооперации
обеспечивается двумя базовыми разновидностями компонент в ZCA:
`адаптером` (adapter) и `утилитой` (utility).

ZCA распределен между тремя базовыми пакетами:

  - ``zope.interface``, используемый для определения (задания)
    интерфейсов компонент.

  - ``zope.event``, обеспечивающего поддержку простого механизма
    инициирования и обработки событий.

  - ``zope.component``, обеспечивающего порождение и регистрацию
    компонент, а также их предоставление приложению по запросу.

Обращаю внимание, что ZCA сам по себе не является компонентой и не
состоит из них, ZCA скорее механизм и библиотека для создания,
регистрации и обеспечения доступа к зарегистрированным компонентам.  В
продолжение к предыдущему замечанию, `Адаптер` - это, как правило,
обычный класс Python (или фабрика классов (factory), в общем случае),
а `утилита` - это обычный запускаемый объект в среде исполнения Python.

Среда ZCA разрабатывается как одно из направлений развития проекта
Zope 3.  Как сказано выше ZCA является чисто питоновским фреймворком,
и может использоваться в любых приложениях Python.  В настоящее время
ZCA активно используется в проектах Zope 3, Zope 2 и Grok.  Существуют
и другие приложения, в т.ч. и неинтернет-приложения, использующие ZCA
[#projects]_.

.. [#projects] http://wiki.zope.org/zope3/ComponentArchitecture

Краткая история проекта
~~~~~~~~~~~~~~~~~~~~~~~

Проект ZCA начался в 2001 году и был частью проекта Zope 3.  Причиной
его появления послужил анализ опыта, полученного при разработке
комплексных программных систем на основе Zope 2.  Джим Фултон (Jim
Fulton) стал лидером проекта.  Сообщество разработчиков, внесших свой
вклад в дизайн и реализацию ZCA, возглавляется известными инженерами:
Стефаном Рихтером (Stephan Richter), Филиппом фон Вайтершаусеном
(Philipp von Weitershausen), Гвидо ван Россумом (Guido van Rossum),
известным также как *Python BDFL*, Тресом Сивером (Tres Seaver),
Филиппом Дж Эби (Phillip J Eby) и Мартином Фаассеном (and Martijn
Faassen).

В самом начале в ZCA были определены дополнительные компоненты -
`сервисы` (services) и `представления` (views), но в процессе
разработки оказалось, что `утилиты` заменяют полностью сервисы, а
`мультиадаптеры` - представления.  В настоящее время ZCA включает в
себя совсем небольшое количество базовых разновидностей компонент:
`утилиты`, `адаптеры`, `подписчики` (абоненты) (subscribers) и
`обработчики` (handlers).  На самом деле `подписчики` и
`обработчики` - это два особых вида адаптеров.

В процессе подготовки версии Zope 3.2 Джим Фултон предложил
значительно упростить фреймворк ZCA [#proposal]_.  В результате этого
появился новый общий интерфейс `IComponentRegistry`, позволяющий
регистрировать как локальные так и глобальные компоненты.

.. [#proposal] http://wiki.zope.org/zope3/LocalComponentManagementSimplification

В результате от пакета ``zope.component`` перестал зависеть достаточно
длинный список других пакетов, при этом оставшиеся зависимости не
относились напрямую к разработке приложений Zope 3.  На конференции
PyCon 2007 Джим Фултон предложил включить в пакет setuptools функцию
`extras_require`, чтобы сильнее изолировать базовый набор функций ZCA
от вспомогательных функций [#extras]_.

.. [#extras] http://peak.telecommunity.com/DevCenter/setuptools#declaring-dependencies

В марте 2009, Трес Сивер окончательно устранил зависимости пакета от
``zope.deferredimport`` и ``zope.proxy``.

Теперь проект ZCA является независимым со своим собственным планом
выпусков и репозиторием Subversion.  Проект как и прежде является
составляющей частью среды разработки интернет-приложений Zope
[#framework]_.  При этом ошибки и недочеты, выявляемые в ZCA, все еще
публикуются на сайте системы отслеживания ошибок проекта Zope 3
[#bugs]_.  Кроме того, основной список рассылки `zope-dev` все еще
используется для информационного обмена разработчиками ZCA
[#discussions]_.  Есть еще другой список рассылки, предназначенный для
пользователей Zope 3, `zope3-users`, в котором можно получить ответы
на вопросы о ZCA [#z3users]_.

.. [#framework] http://docs.zope.org/zopeframework/
.. [#bugs] https://bugs.launchpad.net/zope3
.. [#discussions] http://mail.zope.org/mailman/listinfo/zope-dev
.. [#z3users] http://mail.zope.org/mailman/listinfo/zope3-users

Установка
~~~~~~~~~

Пакеты ``zope.component``, ``zope.interface`` и ``zope.event``
являются ядром Компонентной архитектуры Zope.  Они содержат
технические средства для определения, регистрации и поиска компонент.
Пакет ``zope.component`` и пакеты, зависящие от него, доступны в
формате egg на сайте Python Package Index (PyPI) [#pypi]_.

.. [#pypi] Repository of Python packages: http://pypi.python.org/pypi

Проще всего устанавливать ``zope.component`` и его зависимые пакеты
при помощи `easy_install` [#easyinstall]_ ::

  $ easy_install zope.component

.. [#easyinstall] http://peak.telecommunity.com/DevCenter/EasyInstall

Эта команда загружает ``zope.component``, его зависимые пакеты с сайта
PyPI и устанавливает все как библиотеки интерпретатора Python.

С другой стороны, можно загрузить ``zope.component`` и зависящие от
него пакеты с сайта PyPI и, затем, самостоятельно установить их.
Установку пакетов следует производить в порядке, описанном ниже.  В
операционной системе Windows необходимо загрузить двоичные сборки
следующих пакетов.

  1. ``zope.interface``
  2. ``zope.event``
  3. ``zope.component``

Для установки загруженных пакетов можно, как и раньше, использовать
команду ``easy_install``, при этом передавая в качестве параметра
устанавливаемые пакеты, аналогично двоичным egg-пакетам.  Команда
позволяет все пакеты указывать одновременно в одной командной
строке. ::

  $ easy_install /path/to/zope.interface-3.x.x.tar.gz
  $ easy_install /path/to/zope.event-3.x.x.tar.gz
  $ easy_install /path/to/zope.component-3.x.x.tar.gz


Кроме того, все пакеты можно разархивировать и установить по одному,
например::

  $ tar zxvf /path/to/zope.interface-3.x.x.tar.gz
  $ cd zope.interface-3.x.x
  $ python setup.py build
  $ python setup.py install

Этот набор команд устанавливает ZCA как общесистемную библиотеку
Python в директорий ``site-packages``, что, иногда, создает некоторые
проблемы.  Джим Фултон в списке рассылки Zope 3 не рекомендовал
устанавливать пакеты в общесистемной библиотеке Python
[#systempython]_.  Их рекомендуется устанавливать в виртуальное
окружение при помощи программы ``virtualenv`` и/или пакета
``zc.buildout``.  Такой подход дает больше возможностей для
экспериментов с пакетами Python.  Кроме того, в виртуальном окружении
удобно развертывать готовые приложения.

.. [#systempython] http://article.gmane.org/gmane.comp.web.zope.zope3/21045

Подготовка виртуального окружения
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Существует множество популярных подходов к настройке изолированного
виртуального окружения для среды программирования Python, удобного для
разработки приложений.  Наиболее популярные — это пакет
``virtualenv``, разработанный Яном Бикингом (Ian Biking) и пакет
``zc.buildout``, разработанный Джимом Фултоном.  Оба этих пакета можно
использовать одновременно.


**virtualenv**

Пакет ``virtualenv`` устанавливается при помощи команды
``easy_install``::

  $ easy_install virtualenv

Затем создается новое окружение::

  $ virtualenv --no-site-packages myve

Команда создает новое окружение в директории ``myve``.  Теперь в
директории ``myve`` можно установить ``zope.component`` и зависимые
пакеты при помощи команды ``easy_install``, если запустить ее с
указанием директории ``myve/bin`` в качестве префикса команды ::

  $ cd myve
  $ ./bin/easy_install zope.component

Теперь можно попробовать импортировать пакеты ``zope.interface`` и
``zope.component`` из командной строки интерпретатора ``python``, который
находится в директории ``myve/bin``::

  $ ./bin/python

После запуска Python выведет на экран его стандартное приглашение
(prompt) для ввода команд и выражений.  В командной строке мы
будем выполнять программный код, приводимый далее в книге .


**zc.buildout**

При помощи пакета ``zc.buildout`` и `рецепта` (recipe)
``zc.recipe.egg`` создаются специализированные версии интерпретатора
Python с встроенными egg-пакетами.  Для этого необходимо установить
пакет ``zc.buildout`` при помощи команды ``easy_install``, имеет смысл
это сделать также внутри виртуального окружения.

Чтобы создать новое buildout-окружение для проведения экспериментов с
egg-пакетами Python, сначала создайте для него новый директорий, и,
затем, создайте в нем так называемое buildout-окружение при помощи
команды ``buildout init``::

  $ mkdir mybuildout
  $ cd mybuildout
  $ buildout init

Теперь директорий ``mybuildout`` новое buildout-окружение.  Настройки
окружения по умолчанию хранятся в файле `buildout.cfg`.  Сначала в нем
содержится следующий текст::

  [buildout]
  parts =

Надо внести в настройки следующие изменения::

  [buildout]
  parts = py

  [py]
  recipe = zc.recipe.egg
  interpreter = python
  eggs = zope.component

Запуск команды ``buildout`` из директория ``mybuildout/bin`` (без
аргументов) создаст копию интерпретатора Python в директории
``mybuildout/bin``::

  $ ./bin/buildout
  $ ./bin/python

Последняя команда выведет на экран приглашение Python, в котором
запускается приводимый далее в книге программный код.

Пример задачи
-------------



Введение
~~~~~~~~

Рассмотрим приложение, предназначенное для регистрации постояльцев в
гостинице.  В среде Python его можно реализовать множеством способов.
Сначала кратко рассмотрим процедурный подход, затем перейдем к
объектно-ориентированному программированию.  После анализа результатов
дизайна и реализации задачи при помощи объектно-ориентированного
подхода, рассмотрим как данная задача решается при помощи классических
шаблонов проектирования (паттернов проектирования, design patterns)
`адаптер` и `интерфейс`.  Таким образом у вас появится начальное
представление о возможностях Компонентой архитектуры Zope.

Процедурный подход
~~~~~~~~~~~~~~~~~~

Модуль хранения данных - очень важный момент в разработке приложений.
В рассматриваемом примере будем использовать словарь (dictionary)
языка Python в качестве такой системы хранения.  Каждой записи
соответствует сгенерированный уникальный ключ (ID).  Ключ
ассоциируется со значением, которое тоже будет словарем и будет
содержать данные о бронировании комнаты в гостинице.

  >>> bookings_db = {} #key - уникальный идентификатор (ID), value -
  данные брони

В реализации системы нужна, как минимум, функция, которой передаются
данные о бронировании, и функция, которая генерирует уникальное
значение ID ключа для ассоциации с данными брони.

Генерировать значения ключа можно следующим образом::

  >>> def get_next_id():
  ...     db_keys = bookings_db.keys()
  ...     if db_keys == []:
  ...         next_id = 1
  ...     else:
  ...         next_id = max(db_keys) + 1
  ...     return next_id

Как видно из программы, реализация функции `get_next_id` достаточно
простая.  Функция получает из словаря список ключей. Если список пуст,
то это значит, что произошло первое бронирование комнаты в гостинице,
функция возвращает `1`.  Если список не пуст, то добавить `1` к
максимальному значению ключей и вернуть полученное значение.

Теперь созданную выше функцию встроим в программный код, создающий
записи в словаре bookings_db::

  >>> def book_room(name, place):
  ...     next_id = get_next_id()
  ...     bookings_db[next_id] = {
  ...     'name': name,
  ...     'room': place
  ...     }

В хранилище необходимо учесть, что может потребоваться сохранять и
другие данные, такие как следующие:

- номера телефонов,
- особенности бронирования,
- способы платежей клиентов,
- ...

Необходимо реализовать следующие функции:

- отмена бронирования,
- уточнение бронирования,
- оплата проживания,
- постоянное хранение данных и доступ к ним,
- обеспечение защиты информации в хранилище,
- ...

Процедурная реализация данного примера требует создания большого числа
функций, обменивающихся информацией друг с другом.  Изменения
требований к дизайну и реализации, добавление новых функций, создает
условия к усложнению процесса поддержки программного кода.  Кроме
того, становится сложнее выявлять и исправлять ошибки.

На этом закончим обсуждение процедурного подхода. Обеспечивать
постоянное хранение данных, гибкость дизайна и
возможность тестирования программного кода, как правило, проще,
используя объекты.

Объектно-ориентированный подход
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. ??? что, на самом деле должен, должен излагать этот абзац:
а) "о создании объекта, обрабатывающего регистрацию" или же
б) "о создании класса, обрабатывающего регистрацию"?

В объектно-ориентированном подходе появляются `классы`, которые служат
для инкапсуляции данных и программного кода, обрабатывающего эти
данные в рамках одного абстрактного типа данных.

Основным классом в рассматриваемом примере является ``FrontDesk``.
Класс ``FrontDesk``, а также другие классы, с которыми он
взаимодействует, обеспечивают обработку данных об отеле.  При помощи
`экземпляров` класса ``FrontDesk`` моделируется конкретный
бизнес-процесс в конкретном отеле.

Как правило, консолидация программного кода и данных в объектах
обеспечивает, в конечном счете, такой дизайн программной системы,
который является более понятным, его проще тестировать и изменять.

Рассмотрим детали реализации класса ``FrontDesk``::

  >>> class FrontDesk(object):
  ...
  ...     def book_room(self, name, place):
  ...         next_id = get_next_id()
  ...         bookings_db[next_id] = {
  ...         'name': name,
  ...         'place': place
  ...         }

Далее, задачей объекта `frontdesk` (экземпляра класса `FrontDesk`)
является обработка заявок на бронирование.  Его используют следующим
образом::

  >>> frontdesk = FrontDesk()
  >>> frontdesk.book_room("Jack", "Bangalore")

В реальности в каждый проект необходимо вносить изменения.  Например,
если руководство отеля решило, что каждый клиент должен при
бронировании сообщать свой номер телефона, то программый код класса
необходимо изменить.

Требование руководства можно удовлетворить добавив еще один аргумет к
методу `book_room`, кроме того, новое ключевое значение добавляется к
словарю::

  >>> class FrontDesk(object):
  ...
  ...     def book_room(self, name, place, phone):
  ...         next_id = get_next_id()
  ...         bookings_db[next_id] = {
  ...         'name': name,
  ...         'place': place,
  ...         'phone': phone
  ...         }

В результате изменилась структура базы данных.

Теперь появилась необходимость во всей программе откорректировать
вызов метода `book_room` - добавить новый аргумент `phone`.  Если же
инкапсулировать данные о постояльце в объекте `guest`, и использовать
только его при регистрации, то указанные выше изменения будут
минимизированы или совсем будут не нужны.  Изменения в объекте
`guest`, например, добавление поля `phone` не вызовет необходимости в
тотальной корректировки кода.

В результате получилось следующее::

  >>> class FrontDesk(object):
  ...
  ...     def book_room(self, guest):
  ...         next_id = get_next_id()
  ...         bookings_db[next_id] = {
  ...         'name': guest.name,
  ...         'place': guest.place,
  ...         'phone': guest.phone
  ...         }

Не смотря на полученный результат, программный код все таки придется
корректировать, чтобы отразить изменяющиеся во времени требования
заказчика.  Этого избежать практически никогда невозможно.  Задача
разработчика состоит в том, чтобы создать такой дизайн программы,
который не требовал бы значительных изменения программного кода при
изменении требований.  Это свойство дизайна называется
`Ремонтопригодность` (maintainability).  Чем меньше нужно вносить
изменений тем выше ремонтопригодность.

.. note::

  В процессе реализации программы (кодирования) очень важно верить в
  то, что вносимые изменения не повлияют на рабостоспособность всего
  приложения.  Существует способ обретения такой уверенности -
  автоматизированное тестирование.  Если под рукой корректный и полный
  набор тестов, а также и система контроля версий можно бесстрашно
  изменять программный код.  Одним из рекомендуемых источников
  информации по этому вопросу явлется книга `Экстримальное
  программирование` Кента Бека (Издательство: Питер, 2002 г., 224
  стр. ISBN 5-94723-032-1).

Итак, добавление объекта `guest` сократило программный код, и, что
более важно, упростило программную систему.  Ее код теперь проще
понять, реструктурировать и поддерживать.

Шаблон проектирования `Адаптер`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В реальных приложениях объект `frontdesk` должен реализовывать еще и
другие функции, например, отмену и изменения бронирования.  В текущей
реализации необходимо передавать объект `guest` объекту `frontdesk`
всякий раз при запуске методов `cancel_booking` и `update_booking`.

Можно избавиться от этого ограничения, если передать объект `guest` в
конструктор FrontDesk.__init__(), и сделав объект `guest` атрибутом
нового экземпляра `FrontDesk`.

  >>> class FrontDeskNG(object):
  ...
  ...     def __init__(self, guest):
  ...         self.guest = guest
  ...
  ...     def book_room(self):
  ...         guest = self.guest
  ...         next_id = get_next_id()
  ...         bookings_db[next_id] = {
  ...         'name': guest.name,
  ...         'place': guest.place,
  ...         'phone': guest.phone
  ...         }
  ...
  ...     def cancel_booking(self):
  ...         guest = self.guest
  ...         #далее следует реализация отмены бронирования ...
  ...
  ...     def update_booking(self):
  ...         guest = self.guest
  ...         #далее следует реализация изменения бронирования ...


.. надо бы включить этот кусок в начало раздела `Адаптеры` когда я
    найду подходящее высказывание из книги о шаблонах, чтобы начать
    раздел `Интерфейсы`.

    Вариант решения, к которому мы пришли, - это известный шаблон
    проектирования `Адаптер` (`Adapter`).  Банда четырех (`Gang of
    Four`), написавших [#patternbook]_, дают такое определение
    адаптера::

    "... (?) Преобразовать интерфейс класса в другой интерфейс, который уже
    известен клиенту.  Адаптеры позволяют взаимодействовать друг с
    другом классам, которые первоначально не должны были из-за
    несовместимых интерфейсов."


Решение, к которому мы пришли, - это всем известный шаблон
проектирования *Адаптер* (*Adapter*). Большинство адаптеров *содержат*
в себе *адаптируемый объект* (*adaptee*)::

  >>> class Adapter(object):
  ...
  ...     def __init__(self, adaptee):
  ...         self.adaptee = adaptee

Этот шаблон чрезвычайно полезен в процессе реализации программного
кода в следствии

- изменений требований заказчика;
- требований к системе хранения данных (ZODB, RDBM, XML ...);
- трамбований к выводу результата (HTML, PDF, plain text ...);
- изменения способа представления исходного текста (ReST, Markdown,
  Textile ...).

В ZCA используются адаптеры, а также *регистраторы компонент*, которые
позволяют настраивать реализацию блоков программного кода на
основе *конфигураций* (*configuration*) компонентов.

Далее, в разделе об адаптерах ZCA, будет продемонстрированы
приемущества использования конфигурирования, в частности,

- возможность переключения между вариантами реализации;
- возможность при необходимости добавлять новые реализации;
- повышается степень использования повторного кода: как
  унаследованного, так и программного кода ZCA.

Кроме того, использование конфигурирования позволяет создавать гибкий,
масштабируемый программный код.  Хотя, конечно, поддержка регистров
компонент добавляет дополнительный уровень сложности приложения.  Если
же приложению никогда не потребуются перечисленные возможности, то,
вероятно, в этом случае ZCA будет мало полезным.

Итак, теперь можно начать изучение Zope Component
Architecture. Начнем с интерфейсов.

Интерфейсы
----------



Введение
~~~~~~~~

В файле README.txt [#readmes]_ в path/to/zope/interface интерфейсы
определяются следующим образом::

    Интерфейсы - это объекты, которые явным образом задают
    (документируют) спецификацию внешнего поведения группы
    объектов. Эти объекты, в свою очередь, `обеспечивают` (provide)
    данные интерфейсы. Интерфейс задает спецификацию поведения при
    помощи

    - Информативной документации в виде питоновских doc-строк;

    - Определений атрибутов и их свойств;

    - Инвариантов - условий, которые должны выполняться во всех
      объектах, обеспечивающих данный интерфейс.

В классической книге по инженерии программного обеспечения `Приемы
объектно-ориентированного проектирования.  Паттерны проектирования`
[#patternbook]_ известной `Банды Четырех` дана следующая рекомендация:
"Программируй, ориентируясь на интерфейс, а не на реализацию".  Определение
формального интерфейса помогает понимать всю систему.  Кроме того,
интерфейсы позволяют использовать все преимущества, предоставляемые
ZCA.

.. [#readmes] Дерево исходных кодов Zope заполнено текстовыми файлами
    README.txt, которые предстаялют собой замечательную документацию
.. [#patternbook] http://en.wikipedia.org/wiki/Design_Patterns

Интерфейс определяет (формально задает) все характеристики, поведение
и предоставляемые возможности объекта.  Интерфейсы описывают *что*
объект может делать, но чтобы узнать *как* он это делает необходимо
изучать уже его реализацию.

Интерфейсам соответствуют синонимы `контракт` и `эскиз` (`чертеж`),
которые задают правовые и архитектурные положения набора спецификаций.

В некоторых современных системах программирования, таких как Java, C#,
VB.NET и т.п., интерфейсы являются явными элементами их языка.  В
языке Python нет таких языковых конструкций, поэтому интерфейсы в ZCA
реализованы при помощи специальных метаклассов.  Интерфейс задается
при помощи наследования этих метаклассов.

Рассмотри пример в классическом стиле *hello world*::

  >>> class Host(object):
  ...
  ...     def goodmorning(self, name):
  ...         """Пожелаем доброго утра постояльцам"""
  ...
  ...         return "Доброе утро, %s!" % name

В классе `Host` определен метод `goodmorning`.  Если у объекта
(экземпляра данного класса) вызвать метод `goodmorning` на экран
выведется сообщение `Доброе утро, ...!` ::

  >>> host = Host()
  >>> host.goodmorning('Jack')
  'Доброе утро, Jack!'

Здесь, ``host`` - это объект (экземпляр), который можно использовать в
основной программе.  Чтобы увидеть детали реализации, необходимо
получить доступ к классу ``Host`` либо через исходный код, либо при
помощи инструментов документирования API [#api]_ .

.. [#api] http://en.wikipedia.org/wiki/Application_programming_interface

Самое время начать использовать интерфейсы ZCA.  Для класса `Host`
интерфейс можно задать следующим образом::

  >>> from zope.interface import Interface

  >>> class IHost(Interface):
  ...
  ...     def goodmorning(guest):
  ...         """Пожелаем доброго утра постояльцам"""

Как видно из примера, интерфейс `IHost` унаследован от
zope.interface.Interface.  На самом деле конструкция выглядит так же
как как питоновский класс, но он задает интерфейс в рамках ZCA.
Приставка ``I`` - это полезное соглашение о форме и способе задания
имен интерфейсов.

Декларация интерфейса
~~~~~~~~~~~~~~~~~~~~~

Мы изучили пример задания (декларации) интерфейса при помощи
``zope.interface`` в предыдущем разделе.  В этом разделе рассмотрим
основные правила более подробно.

Рассмотрим следующий пример декларации интерфейса::

  >>> from zope.interface import Interface
  >>> from zope.interface import Attribute

  >>> class IHost(Interface):
  ...     """Объект host"""
  ...
  ...     name = Attribute("""Название host""")
  ...
  ...     def goodmorning(guest):
  ...         """Пожелаем доброго утра постояльцам"""

Интерфейс ``IHost`` включает два атрибута ``name`` и ``goodmorning``.
Надо сказать, что в языке Python методы также являются атрибутами
класса.  Атрибут ``name`` декларируется при помощи класса
``zope.interface.Attribute``.  Сама декларация атрибута ``name`` в
интерфейсе ``IHost`` не устанавливает ему какого-либо начального
значения.  Идея состоит в том, чтобы указать, что все реализации
интерфейса ``IHost`` будут так или иначе использовать этот атрибут.
Более того, данная декларация никоим образом не задает тип атрибута!
В качестве первого аргумента ``Attribute`` передается строка,
документирующая описываемый атрибут.

Второй атрибут, ``goodmorning``, является методом и задается
синтаксически как функция.  Заметим, что параметр `self` в методе
интерфейса не используется, так как `self`, ссылка на экземпляр
класса, - это деталь реализации класса.  Теперь, если программный
модуль реализует интерфейс ``IHost``, то в его программном коде будут
использованы атрибут ``name`` и метод (функция) ``goodmorning``.
Методу ``goodmorning`` необходимо передавать ровно один параметр.

Теперь изучим как объединять тройку `интерфейс-класс-объект`.  Объект
- это реально функционирующая сущность, объекты являются экземплярами
классов.  Именно интерфейс определяет структуру и внешнее поведение
объекта, а классы - это лишь детали реализации.  Именно по этой
причине программный код реализуется, ориентируясь/задавая интерфейс, а
не на реализацию.

В излагаемой концепции присутствуют еще две терминологические
единицы.  Первая - `обеспечить` (`provide`), вторая - `реализовать`
(`implement`).  Объекты обеспечивают интерфейсы, а классы реализуют
интерфейсы.  Другими словами, объекты обеспечивают интерфейсы, которые
их классы реализуют.  В приведенном выше примере ``host`` (объект)
обеспечивает ``IHost`` (интерфейс), ``Host`` (класс) реализует
``IHost`` (интерфейс).  Один объект может обеспечить несколько
интерфейсов, также как класс может реализовывать несколько
интерфейсов.  Кроме того, в дополнение к реализациям интерфейса в
классе, объекты могут обеспечивать интерфейсы в обход
класса, "на прямую" (directly).

.. note::

  Классы - это детали реализации объектов.  В Python классы сами по
  себе являются исполняемыми (callable) объектами, так почему же не
  дать возможность другим исполняемым объектам реализовывать
  интерфейсы.  И это возможно.   Для любого исполняемого объекта
  можно сообщить ZCA интерфейс и, что этот объект порождает объекты,
  обеспечивающие данный интерфейс.  Такие исполняемые объекты, в общем
  случае, называются `фабриками`.  Функции также являются исполняемыми
  объектами, т.е. они тоже могут реализовывать интерфейсы.

Реализация интерфейсов
~~~~~~~~~~~~~~~~~~~~~~

Чтобы указать, что класс реализует некоторый интерфейс, используется
функция ``zope.interface.implements`` в определении класса.

Рассмотрим пример, здесь класс ``Host`` реализует интерфейс
``IHost``::

  >>> from zope.interface import implements

  >>> class Host(object):
  ...
  ...     implements(IHost)
  ...
  ...     name = u''
  ...
  ...     def goodmorning(self, guest):
  ...         """Пожелаем доброго утра постояльцам"""
  ...
  ...         return "Доброе утро, %s!" % guest

.. note::

  Если вам интересно как работает функция ``implements``, обратитесь в
  блог-пост Джеймса Хенстриджа (James Henstridge)
  (http://blogs.gnome.org/jamesh/2005/09/08/python-class-advisors/) .
  В разделе `adapter` находится функция ``adapts``, которая
  функционирует аналогично функции ``implements``.

Так как класс ``Host`` реализует интерфейс ``IHost``, то экземпляры
класса ``Host`` обеспечивают интерфейс ``IHost``.  В ZCA есть в ряд
средств для интроспекции имеющихся деклараций интерфейсов.  Кроме
того, декларации могут быть сделаны вне определения класса: если не
указывать ``implements(IHost)`` в приведенном выше примере, то после
определения класса ``Host`` данную декларацию можно сделать следующим
образом::

  >>> from zope.interface import classImplements
  >>> classImplements(Host, IHost)

Компонентный подход в рассматриваемом примере
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Итак, вернемся к нашему примеру приложения.  Рассмотрим определение
интерфейса объекта `стол регистрации` (frontdesk)::

  >>> from zope.interface import Interface

  >>> class IDesk(Interface):
  ...     """Стол регистрации, регистрирующий данные о постояльце"""
  ...
  ...     def register():
  ...         """Регистрируем данные постояльца"""
  ...

В начале импортируется класс ``Interface`` из модуля
``zope.interface``.  Каждый подкласс класса ``Interface`` с точки
зрения компонентной архитектуры Zope является определением интерфейса.
Интерфейсы реализуется при помощи классов или любых других исполняемых
(callable) объектов языка Python.

В примере задан интерфейс стола регистрации - ``IDesk``.  Строка,
которая находится сразу под определением интерфейса (строка
документирования), объясняет предназначение интерфейса.  Определение
метода в интерфейсе задает контрактное обязательство (contract)
компоненты - в ней будет реализован одноименный метод.  В определении
метода в интерфейсе не надо указывать первый аргумент `self`, так как
интерфейс не предназначен для порождения экземпляров, т.е. эти
декларации методов никогда не будут выполнены.  Главная задача
интерфейса - спецификация перечня атрибутов и методов, которые должны
быть определены классе, который обязался реализовать данный интерфейс.
Поэтому параметр `self` - это деталь реализации метода в классе, а в
интерфейсе его указывать нет необходимости.

Кроме методов ZCA разрешает в интерфейсе декларировать обычные
атрибуты::

  >>> from zope.interface import Interface
  >>> from zope.interface import Attribute

  >>> class IGuest(Interface):
  ...
  ...     name = Attribute("Имя постояльца")
  ...     place = Attribute("Место размещения постояльца")

Данный интерфейс сообщает, что соответствующие `guest`-объекты
включают два атрибута.  В ZCA в интерфейсах можно задавать
одновременно и атрибуты и методы.  Интерфейсы, как правило,
реализуются при помощи классов и модулей, но можно и при помощи других
объектов.  Например, функция, которая динамически создает и возвращает
компоненты, является таким нетипичным примером реализации интерфейса.

Итак, теперь вам известно, что такое интерфейс, как его задавать и
использовать.  В одном из следующих разделов рассмотрим использование
интерфейсов в спецификации и реализации компонент-адаптеров.

Интерфейсы-маркеры
~~~~~~~~~~~~~~~~~~

Интерфейсы в некоторых случаях используются для указания, что
некоторый объект принадлежит специальному типу или обладает некоторыми
специфическими свойствами.  Интерфейс, который не содержит определений
атрибутов и методов, называется `маркерным интерфейсом` (`marker
interface`).

Вот простой пример маркерного интерфейса::

  >>> from zope.interface import Interface

  >>> class ISpecialGuest(Interface):
  ...     """Особый гость"""


Интерфейс предназначен для указания, что помеченный объект - это не
просто `гость`, а `особый гость`.

Инварианты
~~~~~~~~~~

Иногда бывает необходимо явным образом указать, что атрибуты
компоненты связаны друг с другом некоторым логическим правилом или
ограничением.  Механизм задания таких правил и ограничений в ZCA
реализуется при помощи `инвариантов` (`invariants`).  Инварианты
задаются также в интерфейсах при помощи функций и объектов модуля ``zope.interface.invariant``.

Рассмотрим простой пример, пусть существует объект `person` (человек).
Его можно описать при помощи атрибутов `имя` (`name`), `email` и
`телефон` (`phone`).  Теперь можно задать ограничение, которое
требует, чтобы email или телефон были обязательно заданы у каждого
объекта person, требовать, чтобы оба этих атрибута были заданы, мы не
будем.

Ограничение проверяет специальный исполняемый объект (callable
object).  В качестве такого объекта выступает исполняемый экземпляр
некоторого класса или даже обычная функция, например такая::

  >>> def contacts_invariant(obj):
  ...
  ...     if not (obj.email or obj.phone):
  ...         raise Exception(
  ...             "Необходимо указать как минимум один вид контакта")

Затем надо определить интерфейс объекта `person`, используя функцию
``zope.interface.invariant``, предписывающую, что для компоненты
задается инвариант::

  >>> from zope.interface import Interface
  >>> from zope.interface import Attribute
  >>> from zope.interface import invariant

  >>> class IPerson(Interface):
  ...
  ...     name = Attribute("Имя")
  ...     email = Attribute("Email-адрес")
  ...     phone = Attribute("Номер телефона")
  ...
  ...     invariant(contacts_invariant)

Теперь при помощи метода `validateInvariants` можно проверять
(верифицировать) структуру объекта на непротиворечивость, содержащихся
в нем данных::

  >>> from zope.interface import implements

  >>> class Person(object):
  ...     implements(IPerson)
  ...
  ...     name = None
  ...     email = None
  ...     phone = None

  >>> jack = Person()
  >>> jack.email = u"jack@some.address.com"
  >>> IPerson.validateInvariants(jack)
  >>> jill = Person()
  >>> IPerson.validateInvariants(jill)
  Traceback (most recent call last):
  ...
  Exception: "Необходимо указать как минимум один вид контакта"

Из примера видно, что объект `jack` верифицирован успешно, и при этом
не возникло никаких исключений.  Объект `jill`, наоборот, не прошел
проверку ограничения, что привело к возникновению соответствующего
исключения.

Адаптеры
--------



Реализация
~~~~~~~~~~

Компонентная архитектора Zope, как можно было заметить, направлена на
продуктивное использование объектов Python.  Компоненты-адаптеры - это
одна из базовых концепций, используемых ZCA, реализуемые и
используемые для повышения продуктивности процесса программирования.
Как и прежде, адаптеры - это объекты Python, но со специальным образом
оформленным интерфейсом.

Для того, чтобы указать, что класс является адаптером, используется
функция `adapts`, которая находится в пакете ``zope.component``.  В
следующем примере в определении адаптера `FrontDeskNG` содержатся
декларация интерфейса, который реализует класс, и декларация
адаптируемого интерфейса::

  >>> from zope.interface import implements
  >>> from zope.component import adapts

  >>> class FrontDeskNG(object):
  ...
  ...     implements(IDesk)
  ...     adapts(IGuest)
  ...
  ...     def __init__(self, guest):
  ...         self.guest = guest
  ...
  ...     def register(self):
  ...         guest = self.guest
  ...         next_id = get_next_id()
  ...         bookings_db[next_id] = {
  ...         'name': guest.name,
  ...         'place': guest.place,
  ...         'phone': guest.phone
  ...         }


Итак, компонента `FrontDeskNG` задана как адаптер для интерфейса
`IGuest` к интерфейсу `IDesk`.  Это значит, что везде, где требуются
компоненты, обеспечивающие интерфейс `IDesk`, можно использовать
компоненты, обеспечивающие `IGuest`, но через компоненту-адаптер
`FrontDeskNG`.  Интерфейс `IDesk` реализуется в классе `FrontDeskNG`,
т.е., экземпляры этого класса обеспечивают интерфейс `IDesk`.

::

  >>> class Guest(object):
  ...
  ...     implements(IGuest)
  ...
  ...     def __init__(self, name, place):
  ...         self.name = name
  ...         self.place = place

  >>> jack = Guest("Jack", "Bangalore")
  >>> jack_frontdesk = FrontDeskNG(jack)

  >>> IDesk.providedBy(jack_frontdesk)
  True

Кроме адаптера `FrontDeskNG` можно разработать и другие адаптеры,
которые могут обрабатывать регистрацию новых постояльцев каким-либо
другим способом.

Регистрация адаптера
~~~~~~~~~~~~~~~~~~~~

Для того, чтобы использовать разработанную компоненту-адаптер,
необходимо ее сначала зарегистрировать в реестре компонент, который в
ZCA называется менеджером сайта (site manager).  Обычно менеджер сайта
ассоциируется с некоторым интернет-сайтом.  Такое название
компоненты-реестра унаследовано от программной системы Zope 3, которая
является средой для разработки динамических сайтов, основанной на ZCA.
К настоящему моменту важно только знать, что существует некий
глобальный сайт и его глобальный менеджер сайта, выполняющий функции
реестра.  Глобальный менеджер сайта располагается в оперативной
памяти, а локальные - в долговременной.

Для регистрации компоненты сначала надо добраться до глобального
менеджера сайта (глобального реестра)::

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()
  >>> gsm.registerAdapter(FrontDeskNG,
  ...                     (IGuest,), IDesk, 'ng')

Для того, чтобы найти глобальный реестр необходимо вызвать глобальную
функцию ``getGlobalSiteManager``, которая находится в модуле
``zope.component``.  Фактически, реестр доступен как атрибут
``globalSiteManager`` пакета ``zope.component``.  То есть, можно
просто использовать атрибут ``zope.component.globalSiteManager``.  Для
регистрации адаптера используется метод ``registerAdapter`` реестра
компонент.  Первым аргументом метода должны быть или класс,
реализующий адаптер, или какая-либо фабрика.  Вторым аргументом
выступает набор (tuple) интерфейсов компонент, которые адаптируются.
В приведенном примере адаптируется только компоненты, обеспечивающие
интерфейс `IGuest`.  Третьим аргументом является интерфейс,
реализуемый компонентой-адаптером.  Четвертый аргумент является
необязательным, он позволяет идентифицировать адаптеры со специальными
свойствами.  В примере такой идентификатор как раз и был использован,
в результате получился специальный поименованный адаптер (`named
adapter`).  Если название не задано, то по умолчанию оно совпадает с
пустой строкой ('').

В определении адаптера `FrontDeskNG` задаются и адаптируемый интерфейс
и интерфейс, к которому происходит адаптация.  То же самое задано и
при регистрации адаптера, что бессмысленно дублирует информацию.
Особой необходимости в этом нет, поэтому можно зарегистрировать
адаптер `FrontDeskNG` следующим упрощенным вызовом::

  >>> gsm.registerAdapter(FrontDeskNG, name='ng')

В ZCA остался устаревший API, выполняющий регистрацию, и его не
следует использовать.  Функции устаревшего API начинаются с `provide`,
например: ``provideAdapter``, ``provideUtility`` и т.д.  При
разработке приложений Zope 3 достаточно удобно использовать еще один
способ регистрации компонент - Язык разметки для конфигурирования Zope
(Zope configuration markup language, ZCML).  Локальные компоненты Zope
3, т.е. компоненты, которые сохраняются в долговременной памяти, можно
также регистрировать из Интерфейса управления Zope (Zope Management
Interface, ZMI), ну и первым способом, программно, регистрация тоже
может быть выполнена.

Адаптер `FrontDeskNG` зарегистрирован под названием `ng`.  Подобным же
образом можно регистрировать другие адаптеры для этой же комбинации
интерфейсов под другими именами.  Напомним, что если компонента
зарегистрирована без названия, то в качестве названия используется пустая
строка.

.. note::

  Локальные компоненты сохраняются в дисковой памяти, в отличие от
  глобальных, которые всегда хранятся в оперативной памяти.
  Глобальные компоненты, как правило, регистрируются в момент
  конфигурирования приложения.  Локальные компоненты загружаются в
  оперативную память из базы данных при загрузке приложения.

Запрос адаптера в реестре
~~~~~~~~~~~~~~~~~~~~~~~~~

Доступ к зарегистрированной компоненте из реестра компонент
осуществляется при помощи двух функций из пакета ``zope.component``.
Первая функция называется ``getAdapter``, а другая - ``queryAdapter``.
Обе функции принимают одни и те же параметры и возвращают требуемую
компоненту, если таковая была зарегистрирована.  Eсли поиск компоненты
в реестре завершился неудачей, то ``getAdapter`` создает
исключительную ситуацию ``ComponentLookupError``, ``queryAdapter``
просто возвратит `None`.

Импортирование этих функций выполняется следующим образом::

  >>> from zope.component import getAdapter
  >>> from zope.component import queryAdapter

В следующем примере нам понадобиться поименованная компонента для
адаптируемого объекта `guest`, который обеспечивает интерфейс `IDesk`.
Компонента была определена и зарегистрирована под именем 'ng' в
предыдущем разделе.  Объект `guest` с именем `jack` определен в первом
разделе этой главы.

Пример демонстрирует, как можно получать доступ к поименованной ('ng')
компоненте, адаптирующей интерфейс (`IGuest`) объекта `jack` и
обеспечивающей интерфейс `IDesk`.  Здесь функции ``getAdapter`` и
``queryAdapter`` исполняются одинаково::

  >>> getAdapter(jack, IDesk, 'ng') #doctest: +ELLIPSIS
  <FrontDeskNG object at ...>
  >>> queryAdapter(jack, IDesk, 'ng') #doctest: +ELLIPSIS
  <FrontDeskNG object at ...>

В вызове функции первый аргумент - адаптируемый объект, второй -
интерфейс, к которому необходимо этот объект адаптировать, и
последний - идентификатор адаптера.  Если попытаться получить доступ с
идентификатором, который не использовался ранее при регистрации
адаптеров таких же объектам к такому же интерфейсу, то по понятным
причинам это завершиться неудачей.  Теперь работе наших функций будет
заметна разница::

  >>> getAdapter(jack, IDesk, 'not-exists') #doctest: +ELLIPSIS
  Traceback (most recent call last):
  ...
  ComponentLookupError: ...
  >>> reg = queryAdapter(jack,
  ...           IDesk, 'not-exists') #doctest: +ELLIPSIS
  >>> reg is None
  True

Видно, что в результате неудачного доступа в ``getAdapter`` возникло
исключение ``ComponentLookupError``, но ``queryAdapter`` мирно вернул
`None`.  Если при получении доступа к компоненте не использовать ее
идентификатор, это означает, что он будет равен пустой строке.  И если
компоненты без идентификатора не было зарегистрировано, то получить
такой доступ тоже невозможно.  Как и прежде в ``getAdapter`` возникнет
исключение ``ComponentLookupError``, а ``queryAdapter`` вернет
`None`.  Вот пример такого неудачного доступа::

  >>> getAdapter(jack, IDesk) #doctest: +ELLIPSIS
  Traceback (most recent call last):
  ...
  ComponentLookupError: ...
  >>> reg = queryAdapter(jack, IDesk) #doctest: +ELLIPSIS
  >>> reg is None
  True

В этом разделе продемонстрировано как регистрируются простые адаптеры,
и как потом получать к ним доступ при помощи реестра компонент.
Простые адаптеры называются единичными адаптерами, так как адаптируют
только один объект.  Если компонента адаптирует более одного объекта,
то она называется мультиадаптером.


Получение доступа к адаптеру с использованием интерфейса
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Получить доступ к адаптеру можно, используя только интерфейс.  Этот
метод работает только для единичных непоименованных адаптеров.  Первый
аргумент - адаптируемый объект, второй аргумент, ключевое слово, -
объект, который возвращается, если доступ к компоненте оказывается
неудачным.

  >>> IDesk(jack, alternate='default-output')
  'default-output'

  Второй аргумент можно задавать и не в формате ключевого слова:

  >>> IDesk(jack, 'default-output')
  'default-output'

  Если второй аргумент совсем не задан, то неудачная попытка доступа
  порождает исключение `TypeError`:

  >>> IDesk(jack) #doctest: +NORMALIZE_WHITESPACE +ELLIPSIS
  Traceback (most recent call last):
  ...
  TypeError: ('Could not adapt',
    <Guest object at ...>,
    <InterfaceClass __builtin__.IDesk>)

  Зарегистрируем `FrontDeskNG` как непоименованный адаптер:

  >>> gsm.registerAdapter(FrontDeskNG)

  Теперь доступ должен быть удачно получен:

  >>> IDesk(jack, 'default-output') #doctest: +ELLIPSIS
  <FrontDeskNG object at ...>

В простых ситуациях можно спокойно использовать интерфейсы для
получения доступа к компонентам-адаптерам.

Шаблон проектирования `Adapter`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Концепция использования адаптеров в Zope Component Architecture и в
применении шаблона `Adapter` в классической книге "Шаблоны
проектирования" являются очень схожими.  Но приемы использования
адаптеров в ZCA обладают большей гибкостью и широтой применения по
сравнению с классическим шаблоном.  Шаблон `Adapter` задает лишь
преобразование некоторого класса в какой-то другой интерфейс, который
ожидает некоторый сервис от экземпляров данного класса.  Шаблон
позволяет разным классам взаимодействовать друг с другом, даже если
они до этого не могли это делать из-за несовместимости их интерфейсов.
В подразделе `Мотивация` книги "Шаблоны проектирования" авторы пишут:
"Часто адаптер отвечает за функциональность, которую не может
предоставить адаптируемый класс".  Адаптеры ZCA фокусируются больше
как раз на реализации новых функций, чем просто создание нового
интерфейса для адаптируемого объекта.  При этом адаптер в ZCA
расширяет функциональность за счет новых методов.  Будет, наверное,
интересным заметить, что `Adapter` в ранних версиях дизайна проекта
ZCA назывался `Feature`. [#feature]_

.. [#feature] Дискуссия по переименованию `Feature` в `Adapter` в
              списке рассылки:
   http://mail.zope.org/pipermail/zope3-dev/2001-December/000008.html

Упомянутая в предыдущем абзаце цитата из книги Банды четырех
заканчивается следующими словами: " ... которую не может предоставить
адаптируемый класс".  Но в следующем предложении абзаца использовано
словосочетание "адаптируемого объекта" вместо "адаптируемого класса",
так как авторы книги на самом деле пишут про два варианта адаптеров, в
зависимости от их реализации.  Первый вариант - это "Адаптер класса",
а другой - "Адаптер объекта".  Адаптер классов использует
множественное наследование для адаптации одного интерфейса к другому,
с другой стороны, адаптер объекта опирается на композицию объектов.
Адаптеры ZCA согласно книге Банды четырех следуют принципу адаптеру
объекта, который использует делегирование (агрегирование) в качестве
механизма композиции.  Второй принцип объектно-ориентированного
дизайна согласно Банде четырех выражается следующим образом:
"Предпочитайте объектную композицию наследованию классов".  Если
хотите более детально познакомиться с приемами адаптации, прочтите
книгу "Шаблоны проектирования".

Самой привлекательной стороной адаптеров ZCA - это явное использование
интерфейсов, в виде специальных объектов Python, во время исполнения
программы, а также реестра компонент.  Адаптеры ZCA регистрируются в
реестре компонент, через который клиентские объекты, затем, могут к
ним получить доступ, опять же при помощи интерфейсов и механизмов
поименования.

Утилиты
-------



Введение
~~~~~~~~

Вы уже знакомы с концепциями "интерфейс"", "адаптер" и "реестр
компонент".  Иногда удобно регистрировать и отдельные объекты, которые
ничего не адаптируют.  Примерами таких объектов выступают соединения с
базами данных, трансляторы XML, объекты, порождающие уникальные
идентификаторы.  Компоненты такого вида, существование которых
поддерживает ZCA, называются компонентами-``утилитами``.

Утилиты - это просто объекты, которые обеспечивают некоторый
интерфейс, и к которым модули программ получают доступ по этим
интерфейсам и регистрационным именам.  Такой подход, с пользованием
глобального реестра, позволяет регистрировать различные объекты и
получать к ним доступ из различных частей программы, и при этом нет
необходимости передавать эти объекты между модулями программы
каким-либо специальным образом.

В программе нет необходимости регистрировать все глобальные объекты,
смысл регистрации состоит в том, чтобы создать механизмы замены одних
объектов, реализующих некоторый сервис, на другие, которые делают это
как-то по-другому.

Простые утилиты
~~~~~~~~~~~~~~~

Утилиты могут быть зарегистрированы поименованными или нет.  Пример
поименованной утилиты рассмотрим в следующем разделе.  Перед тем, как
реализовать утилиту, как обычно, определим ее интерфейс.  Следующий
программный код определяет интерфейс `greeter` утилиты, которая будет
приветствовать постояльцев::

  >>> from zope.interface import Interface
  >>> from zope.interface import implements

  >>> class IGreeter(Interface):
  ...
  ...     def greet(name):
  ...         """Поприветствовать"""

Как и для адаптеров, для утилиты можно реализовать несколькими
способами.  Это классическая реализация при помощи класса::

  >>> class Greeter(object):
  ...
  ...     implements(IGreeter)
  ...
  ...     def greet(self, name):
  ...         return "Здравствуйте, " + name

На самом деле утилита - это экземпляр класса `Greeter`.  Чтобы
утилитой можно было пользоваться, необходимо ее зарегистрировать.  Для
этого пользуется также API ZCA.  Экземпляр класса, утилита
(`utility`), регистрируется при помощи метода реестра компонент
``registerUtility``::

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> greet = Greeter()
  >>> gsm.registerUtility(greet, IGreeter)

В этом примере утилита зарегистрирована как компонента, обеспечивающая
интерфейс `IGreeter`.  Доступ к утилите можно получить по запросу ее
интерфейса при помощи функций `queryUtility` или `getUtility`::

  >>> from zope.component import queryUtility
  >>> from zope.component import getUtility

  >>> queryUtility(IGreeter).greet('Jack')
  'Здравствуйте, Jack'

  >>> getUtility(IGreeter).greet('Jack')
  'Здравствуйте, Jack'

Теперь видно, что по аналогии с адаптерами, которые являются обычно
классами, утилиты являются обычно экземплярами классов.  Поэтому
экземпляры утилит создаются единожды, а экземпляры адаптеров - всякий
раз, как кто-то желает получить к ним доступ.

Поименованные утилиты
~~~~~~~~~~~~~~~~~~~~~

При регистрации компоненты-утилиты, как и адаптера, можно давать им
имена.  Утилита, зарегистрированная под каким-либо именем, называется
поименованной утилитой.

Приведем пример регистрации поименованной утилиты `greeter`::

  >>> greet = Greeter()
  >>> gsm.registerUtility(greet, IGreeter, 'new')

Экземпляр `greet` зарегистрирован как утилита, обеспечивающая
интерфейс `IGreeter`, под именем `new`.  Теперь можно получить к ней
доступ одной из функций `queryUtility` или `getUtility`::

  >>> from zope.component import queryUtility
  >>> from zope.component import getUtility

  >>> queryUtility(IGreeter, 'new').greet('Jill')
  'Здравствуйте, Jill'

  >>> getUtility(IGreeter, 'new').greet('Jill')
  'Здравствуйте, Jill'

Заметим, что для получения доступа необходимо использовать имя `name`
во втором аргументе функций.

Вызов функции `getUtility` без имени (второй аргумент) эквивалентно
вызову этой функции с пустой строкой в качестве второго аргумента, так
как это - значение по умолчанию.  Механизм обеспечения доступа
пытается найти компоненту, чье имя - пустая строка, но его попытка
завершается неуспехом.  Если компонента не найдена, то механизм
создает исключение ``ComponentLookupError``.  Механизм не будет вам
возвращать каки-то другие компоненты, зарегистрированные под другими
именами.  Функции получения доступа к адаптерам `getAdapter` и
`queryAdapter` функционируют аналогично.

Фабрики
~~~~~~~

Компоненты, называемые `фабриками` (``Factory``), - это утилиты,
обеспечивающие интерфейс ``IFactory``.

Чтобы создать фабрику, сначала необходимо определить интерфейс объекта::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface
  >>> from zope.interface import implements

  >>> class IDatabase(Interface):
  ...
  ...     def getConnection():
  ...         """Вернуть объект - соединение с базой данных"""

Вот пример заглушки, реализующей интерфейс `IDatabase`::

  >>> class FakeDb(object):
  ...
  ...     implements(IDatabase)
  ...
  ...     def getConnection(self):
  ...         return "connection"

Теперь можно создать фабрику при помощи
``zope.component.factory.Factory``::

  >>> from zope.component.factory import Factory

  >>> factory = Factory(FakeDb, 'FakeDb')

Регистрируем фабрику::

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> from zope.component.interfaces import IFactory
  >>> gsm.registerUtility(factory, IFactory, 'fakedb')

Для получения доступа, можно использовать следующий код::

  >>> from zope.component import queryUtility
  >>> queryUtility(IFactory, 'fakedb')() #doctest: +ELLIPSIS
  <FakeDb object at ...>

Кроме того, можно еще и удобную сокращенную версию запроса доступа::

  >>> from zope.component import createObject
  >>> createObject('fakedb') #doctest: +ELLIPSIS
  <FakeDb object at ...>

Дополнительные возможности адаптеров
------------------------------------

В этом разделе рассмотрим дополнительные возможности использования
адаптеров, в частности, использование `мультиадаптеров` (`multi
adapter`), `адаптеров-подписчиков` (`subscription adapter`) и
`обработчиков` (`handler`).

Мультиадаптеры
~~~~~~~~~~~~~~

Простые адаптеры адаптируют только один объект, но, в принципе,
компоненты могут адаптировать и несколько объектов.  Если компонента
адаптирует больше одного объекта, кто она называется `мультиадаптер`
(`multi-adapter`).

::

  >>> from zope.interface import Interface
  >>> from zope.interface import implements
  >>> from zope.component import adapts

  >>> class IAdapteeOne(Interface):
  ...     pass

  >>> class IAdapteeTwo(Interface):
  ...     pass

  >>> class IFunctionality(Interface):
  ...     pass

  >>> class MyFunctionality(object):
  ...     implements(IFunctionality)
  ...     adapts(IAdapteeOne, IAdapteeTwo)
  ...
  ...     def __init__(self, one, two):
  ...         self.one = one
  ...         self.two = two

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> gsm.registerAdapter(MyFunctionality)

  >>> class One(object):
  ...     implements(IAdapteeOne)

  >>> class Two(object):
  ...     implements(IAdapteeTwo)

  >>> one = One()
  >>> two = Two()

  >>> from zope.component import getMultiAdapter

  >>> getMultiAdapter((one,two), IFunctionality) #doctest: +ELLIPSIS
  <MyFunctionality object at ...>

  >>> myfunctionality = getMultiAdapter((one,two), IFunctionality)
  >>> myfunctionality.one #doctest: +ELLIPSIS
  <One object at ...>
  >>> myfunctionality.two #doctest: +ELLIPSIS
  <Two object at ...>

Адаптеры-подписчики
~~~~~~~~~~~~~~~~~~~

В отличие от обычных адаптеров, адаптеры-подписчики, еще их называют
просто `подписчиками`, используются, если есть необходимость
реализовать возможность выбора некоторого списка достаточно однотипных
компонент-адаптеров, адаптирующих объект к интерфейсу.  Полученный
список адаптеров, затем, можно поэлементно перебрать и выполнить одну
и ту же процедуру в каждом адаптере-подписчике.  Результаты волнения
процедур каким-либо образом объединяются и используются.

Рассмотрим задачу верификации объектов.  Дан набор объектов, и нам
требуется оценить их соответствие некоторым требованиям.  Определим
интерфейс верификатора::

  >>> from zope.interface import Interface
  >>> from zope.interface import Attribute
  >>> from zope.interface import implements

  >>> class IValidate(Interface):
  ...
  ...     def validate(ob):
  ...         """Определить соответствие объекта стандарту
  ...
  ...         Возвращает строку, характеризующую отклонение от
  ...         стандарта. Пустая строка обозначает, что объект
  ...         успешно прошел верификацию.
  ...         """

Определим объекты-документы::

  >>> class IDocument(Interface):
  ...
  ...     summary = Attribute("Document summary")
  ...     body = Attribute("Document text")

  >>> class Document(object):
  ...
  ...     implements(IDocument)
  ...
  ...     def __init__(self, summary, body):
  ...         self.summary, self.body = summary, body

Теперь можно определить разные правила верификации документов.
Например, можно потребовать, чтобы комспект-резюме документа был
текстом из одной строки::

  >>> from zope.component import adapts

  >>> class SingleLineSummary:
  ...
  ...     adapts(IDocument)
  ...     implements(IValidate)
  ...
  ...     def __init__(self, doc):
  ...         self.doc = doc
  ...
  ...     def validate(self):
  ...         if '\n' in self.doc.summary:
  ...             return 'Резюме должно состоять только из одной строки текста'
  ...         else:
  ...             return ''

Можно потребовать, чтобы основной текст документа состоял ка минимум
из 1000 символов::

  >>> class AdequateLength(object):
  ...
  ...     adapts(IDocument)
  ...     implements(IValidate)
  ...
  ...     def __init__(self, doc):
  ...         self.doc = doc
  ...
  ...     def validate(self):
  ...         if len(self.doc.body) < 1000:
  ...             return 'слишком короткий'
  ...         else:
  ...             return ''

Теперь надо зарегистрировать эти адаптеры-подписчики::

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> gsm.registerSubscriptionAdapter(SingleLineSummary)
  >>> gsm.registerSubscriptionAdapter(AdequateLength)

И теперь зарегистрированные подписчики можно использовать для
верификации объектов::

  >>> from zope.component import subscribers

  >>> doc = Document("A\nDocument", "lorum")
  >>> [adapter.validate()
  ...  for adapter in subscribers([doc], IValidate)
  ...  if adapter.validate()]
  ['Резюме должно состоять только из одной строки текста', 'слишком короткий']

  >>> doc = Document("A\nDocument", "ipsum" * 1000)
  >>> [adapter.validate()
  ...  for adapter in subscribers([doc], IValidate)
  ...  if adapter.validate()]
  ['Резюме должно состоять только из одной строки текста']

  >>> doc = Document("A Document", "dolor")
  >>> [adapter.validate()
  ...  for adapter in subscribers([doc], IValidate)
  ...  if adapter.validate()]
  ['слишком короткий']

Обработчики
~~~~~~~~~~~

Обработчики - это фабрики адаптеров-подписчиков, которые ничего не
возвращают.  Они выполняют свою работу, как только были запущены.
Основной вид использования обработчиков - это реализация реакции на
события.  Обработчики по своей сути являются подписчиками на события,
и их иногда называют `адаптеры, подписанные на события`.

Подписчики на события отличаются от других адаптеров-подписчиков тем,
что объект, вызывающий обработчика, не ожидает от него никакого
прямого взаимодействия.  Например, объект, инициирующий событие не
ожидает от обработчиков этого события каких-либо значений в ответ.
Подписчикам нет необходимости обеспечивать какой-либо API для
вызвавших их компонентов, поэтому более естественно реализовывать
подписчики при помощи функций, а не классов.  В системе управления
контентом, например, можно автоматизировать добавление времени
создания документа в виде поля этого документа::

  >>> import datetime

  >>> def documentCreated(event):
  ...     event.doc.created = datetime.datetime.utcnow()

Здесь определена функция, которая получает событие (`event`) и
выполняет процедуру обработки данных.  Результат, как видите, не
возвращается.  Обработчики - это частные случаи подписчиков, которые
адаптируют события к "ничто".  Вся работа выполняется, когда этот
адаптер-"фабрика" был вызван.  Для регистрации обработчиков в ZCA APIs
используются специальные функции.

Чтобы продемонстрировать регистрацию и использование вышеупомянутого
обработчика, сначала создадим событие `документ-создан` (`document-created`)::

  >>> from zope.interface import Interface
  >>> from zope.interface import Attribute
  >>> from zope.interface import implements

  >>> class IDocumentCreated(Interface):
  ...
  ...     doc = Attribute("Документ, который был создан")

  >>> class DocumentCreated(object):
  ...
  ...     implements(IDocumentCreated)
  ...
  ...     def __init__(self, doc):
  ...         self.doc = doc

Мы также немного дополним текст нашего обработчика::

  >>> from zope.component import adapter

  >>> @adapter(IDocumentCreated)
  ... def documentCreated(event):
  ...     event.doc.created = datetime.datetime.utcnow()

Добавленная конструкция помечает обработчик интерфейсом
`IDocumentCreated` компоненты-события `DocumentCreated`.

Теперь необходимо обработчик зарегистрировать::

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> gsm.registerHandler(documentCreated)

Теперь можно создать компоненту-событие и инициировать его обработку
функцией `handle`, которая вызовет все зарегистрированные обработчики
для данного события::

  >>> from zope.component import handle

  >>> handle(DocumentCreated(doc))
  >>> doc.created.__class__.__name__
  'datetime'

Как ZCA используется в Zope
---------------------------

Компонентная архитектура Zope используется как в Zope 3 и более новых
версиях, так и в Zope 2.  В этом разделе предложен обзор применения
ZCA в Zope.

ZCML
~~~~

Язык **Zope Configuration Markup Language (ZCML)** (Язык разметки для
конфигурирования Zope) - это язык задания конфигурации программной
системе, базирующийся на стандарте XML.  Вместо того, чтобы
использовать API Python для регистрации компонент, можно использовать
язык ZCML.  Но для этого сначала надо установить несколько пакетов, от
которых зависит функционирование средств этого языка.

Необходимые зависимости догружаются во время установки пакета
``zope.component`` в варианте с поддержкой ZCML.  Загрузка пакетов
выполняется утилитой командной строки easy_install следующим образом::

  $ easy_install "zope.component [zcml]"

Всякий файл конфигурации программ и регистрации компонент ZCML должен
начиняться с директивы (тега) ``configure`` с соответствующей
декларацией пространства имен::

  <configure xmlns="http://namespaces.zope.org/zope">
  ...
  </configure>

Директива `adapter` предназначена для регистрации адаптеров::

  <adapter
      factory=".company.EmployeeSalary"
      provides=".interfaces.ISalary"
      for=".interfaces.IEmployee"
      />

Атрибуты `provides` и `for` являются необязательными, если необходимая
информация представлена в реализации::

  <adapter
      factory=".company.EmployeeSalary"
      />

Для того, чтобы зарегистрировать компоненту как поименованный адаптер
надо использовать атрибут `name`::

  <adapter
      factory=".company.EmployeeSalary"
      name="salary"
      />

Утилиты регистрируются директивой `utility`.  Для этого используется
следующая конструкция::

  <utility
      component=".database.connection"
      provides=".interfaces.IConnection"
      />

Атрибут `provides` не является обязательным, если необходимая
информация представлена в реализации::

  <configure xmlns="http://namespaces.zope.org/zope">

  <utility
      component=".database.connection"
      />

Поименованные утилиты регистрируются также, только необходимо
использовать атрибут `name`::

  <utility
      component=".database.connection"
      name="db_connection"
      />

Вместо регистрации утилиты как объекта (экземпляра) можно
зарегистрировать его фабрику::

  <utility
      factory=".database.Connection"
      />

Замещения
~~~~~~~~~

При регистрации компонент методами ``register*`` API Python
реализуется следующее правило: компонента, которая была
зарегистрирована последней заменяет (замещает) собой ранее зарегистрированную
компоненту, если они обе зарегистрированы с одним и тем же набором
аргументов функций-регистраторов.  Рассмотрим следующий пример::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface

  >>> class IA(Interface):
  ...     pass

  >>> class IP(Interface):
  ...     pass

  >>> from zope.interface import implements
  >>> from zope.component import adapts

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> class AP(object):
  ...
  ...     implements(IP)
  ...     adapts(IA)
  ...
  ...     def __init__(self, context):
  ...         self.context = context

  >>> class AP2(object):
  ...
  ...     implements(IP)
  ...     adapts(IA)
  ...
  ...     def __init__(self, context):
  ...         self.context = context

  >>> class A(object):
  ...
  ...     implements(IA)

  >>> a = A()
  >>> ap = AP(a)

  >>> gsm.registerAdapter(AP)

  >>> getAdapter(a, IP) #doctest: +ELLIPSIS
  <AP object at ...>

Теперь, если зарегистрировать еще один адаптер, то уже существующий
будет заменен::

  >>> gsm.registerAdapter(AP2)

  >>> getAdapter(a, IP) #doctest: +ELLIPSIS
  <AP2 object at ...>

Но вот, если регистрировать компоненты при помощи ZCML, то вторая
регистрация создаст конфликт, что проявится в виде исключения.  Этот
принцип позволяет контролировать ситуации, когда нужный
зарегистрированный адаптер по ошибке замещается каким-то другим.  В
результате удается избегать необходимости отслеживать ошибки в работе
проектируемой программной системы.  Получается, что использование ZCML
способствует даже упрощению разработки.

Иногда, все-таки, необходимо заменять существующие регистрации.  Для
этого в ZCML есть директива ``includeOverrides``.  Используя эту
директиву можно указывать, что в отдельном файле (атрибут `file`)
находятся регистрации, замещающие собой имеющиеся::

  <includeOverrides file="overrides.zcml" />

Адаптер NameChooser
~~~~~~~~~~~~~~~~~~~

Пакет: `zope.app.container.contained.NameChooser`

Адаптер NameChooser - это адаптер, который подбирает уникальное имя
для некоторого объекта внутри контейнера.

Регистрация такого адаптера выглядит следующим образом::

  <adapter
      provides=".interfaces.INameChooser"
      for="zope.app.container.interfaces.IWriteContainer"
      factory=".contained.NameChooser"
      />

Из данной конструкции видно, что адаптируемый объект обеспечивает
``IWriteContainer``, а адаптер - ``INameChooser``.

Адаптер NameChooser очень удобен программистам Zope.  Реализация
``IWriteContainer`` в Zope 3 распределена, в основном, между классами
пакетов ``zope.app.container.BTreeContainer`` и
``zope.app.folder.Folder``.  Обычно в своих программах надо
наследовать от данных классов их функции для создания собственных
классов-контейнеров.  Если бы разработчики ранее не реализовали
интерфейс ``INameChooser`` и адаптер ``NameChooser``, тогда вам
пришлось бы вновь создавать их для каждой реализации отдельно.

Адаптер LocationPhysicallyLocatable
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Пакет: ``zope.location.traversing.LocationPhysicallyLocatable``

Этот адаптер достаточно часто используется при программировании
приложений в среде Zope 3, но вызывается обычно при помощи
специального API в пакете ``zope.traversing.api``.  (Редкий старый код
до сих пор использует функции ``zope.app.zapi``, которые добавляют еще
один слой косвенных вызовов для этого адаптера)

Регистрация данного адаптера выполняется следующим образом::

  <adapter
      factory="zope.location.traversing.LocationPhysicallyLocatable"
      />

Интерфейс, который обеспечивает компонента и адаптируемый интерфейс
задаются в реализации, начало которой выглядит вот так::

  class LocationPhysicallyLocatable(object):
      """Обеспечить информацию о местоположении объектов
      """
      zope.component.adapts(ILocation)
      zope.interface.implements(IPhysicallyLocatable)
      ...

Как правило, все объекты, хранимые в базах данных, в приложении Zope 3
обеспечивают интерфейс ``ILocation``.  У этого интерфейса есть только
два атрибута, ``__parent__`` и ``__name__``.  Атрибут ``__parent__``
соответствует родительскому узлу в иерархии местоположений, а
``__name__`` - это название объекта, которое уникально среди множества
объектов с одним родительским узлом.

Интерфейс ``IPhysicallyLocatable`` содержит четыре метода:
``getRoot``, ``getPath``, ``getName``, и ``getNearestSite``.

- ``getRoot`` - функция, которая возвращает объект, соответствующий
  корневому узлу.

- ``getPath`` возвращает физический путь к объекту в виде строки.

- ``getName`` возвращает последний сегмент физического пути.

- ``getNearestSite`` возвращает объект-сайт, в котором содержится
  адаптируемый объект, как правило это регистратор компонент,
  привязанный к конкретному сайту (интернет-приложению, реализованному
  на одном сервере Zope 3); если он сам является сайтом, то сам он и
  возвращается.

Если вы решите заняться изучением среды Zope 3, вы увидите, что
компоненты, о которых идет сейчас речь, являются важными сущностями, и
они используются очень и очень часто.  Для осознания красоты такого
подхода вам необходимо будет познакомиться, как в системе Zope 2
осуществляется поиск корневого объекта и как это реализовано: почти в
каждом объекте-контейнере есть метод ``getPhysicalRoot``.

Адаптер DefaultSized
~~~~~~~~~~~~~~~~~~~~

Пакет: ``zope.size.DefaultSized``

Этот адаптер - просто реализация интерфейса ``ISized`` по умолчанию.
Адаптер "знает" как адаптировать все виды объектов,
т.е. зарегистрирован как адаптер всех объектов.  Если вам потребуется
зарегистрировать этот адаптер для какого-либо интерфейса, то придется
уже существующую регистрацию замещать новой.

Регистрация этого адаптера в Zope сделана следующим образом::

  <adapter
      for="*"
      factory="zope.size.DefaultSized"
      provides="zope.size.interfaces.ISized"
      permission="zope.View"
      />

Здесь видно, что адаптируемый интерфейс задан как `*`,
т.е. `DefaultSized` адаптирует любые разновидности объектов.

Интерфейс ``ISized`` очень прост и включает спецификации всего двух методов::

  class ISized(Interface):

      def sizeForSorting():
          """Возвращает двойку (basic_unit, amount).

          Используется для сортировки разнородных объектов,
          характеризующихся некоторым размером. Значение 'amount'
          требуется только для сортировки объектов с одной и той же
          единицей измерения 'basic_unit'."""

      def sizeForDisplay():
          """Возвращает строку, представляющую размер объекта.
          """

Пример специально зарегистрированного адаптера ``ISized`` для
интерфейса ``IZPTPage`` можно посмотреть в пакете ``zope.app.zptpage``.

Утилита ZopeVersionUtility
~~~~~~~~~~~~~~~~~~~~~~~~~~

Пакет: ``zope.app.applicationcontrol.ZopeVersionUtility``

Утилита сообщает версию выполняющегося процесса Zope.

Регистрация выполняется следующим образом::

  <utility
      component=".zopeversion.ZopeVersionUtility"
      provides=".interfaces.IZopeVersion" />

Интерфейс, который обеспечивает эта утилита, называется
``IZopeVersion``, он специфицирует только один метод, называемый
``getZopeVersion``.  Этот метод возвращает строку, характеризующую
версию программного обеспечения среды Zope, включая всевозможную
информацию, например, версию исходного кода в репозитарии Subversion.

Реализация утилиты по умолчанию, ``ZopeVersionUtility``, получает
информацию о версии Zope из файла ``version.txt`` в директории
`zope/app`.  Если система Zope была запущена в слепке (checkout)
сервера Subversion, то утилита покажет последний номер ревизии.  Если
ни того ни другого источника информации не удалось найти, утилита
вернет строку `Development/Unknown`.

Пример приложения
-----------------

.. note::

  Эта часть не еще не завершена.  Автор принимает предложения к ее развитию !

Введение
~~~~~~~~

В этом разделе мы продемонстрируем проектирование оконного приложения,
используя библиотеку PyGTK для реализации интерфейса пользователя
совместно с ZCA.  Приложение будет использовать два различных
механизма постоянного хранения объектов.  Первый - это
объектно-ориентированная база данных ZODB, а вторая - реляционная база
данных SQLite.  Однако, при установке конкретного приложения только
одна база данных будет использоваться.  Причина использования двух
механизмов постоянного хранения объектов - продемонстрировать
как ZCA собирает компоненты и связывает их в единое приложение.  В
сходном коде приложения преобладает реализация интерфейса пользователя
на основе библиотеки PyGTK.

При разработке больших приложений удобно использовать ZCA, так как он
при обеспечении управляемости процессом разаботки комплексных
приложений обеспечивает возможность расширения набора функций
приложения, встраивания и замену (pluggablity) компонент.
Непосредственное использование объектов Python может и не обеспечить
такого свойства вашей разработке.

Вообще ZCA может с одинаковым успехом использоваться как для
разработки ВЕБ-, так и для оконных и других приложений или сред
разработки (frameworks).  В каждом приложении необходимо определиться
с принципом организации регистрации компонент: в каком модуле какие
компоненты будут регистрироваться.  В данном приложении принято
указывать функции регистрации компонент в отдельных модулях, и, затем, через импорт
этих модулей производить собственно регистрацию.  Главный
регистрирующий модуль компоненты - `register.py`.

Исходный код готового приложения находится по следующему адресу:
http://www.muthukadan.net/downloads/zcalib.tar.bz2

Функции приложения
~~~~~~~~~~~~~~~~~~

Приложение, от котором идет речь - это система управления библиотекой
с некоторым минимальным набором функций.  Основные требования к
приложению пусть будут такие:

- Добавление читателей, идентифицируя их уникальным номером и именем.

- Добавление книг, помечая их баркодом, и указывая автора и название.

- Выдача книг на руки читателям.

- Учет книг, возвращенных читателями.

Дизайн интерфейса пользователя сделаем таким, чтобы основные функции
были доступны из одного окна.  Основное окно пусть будет следующего вида:

.. image:: mainwindow.png
   :align: center

Также будет специальное окно для управления читателями.  Оно должно
реализовывать *добавление*, *обновление* данных читателя и *удаление*
читателя как показано на рисунке:

.. image:: memberwindow.png
   :align: center

Аналогично предыдущему, окно управления базой данных книг должно
позволять *добавлять*, *редактировать* данные и *удалять* книги:

.. image:: catalogwindow.png
   :align: center

Окно управления книжным фондом должно реализовывать функции *выдачи* и
*возврата* книг читателями:

.. image:: circulationwindow.png
   :align: center

Обзор кода PyGTK
~~~~~~~~~~~~~~~~

Почти все приложение - это программный код, использующий PyGTK.
Структура программ реализации всех окон схожа, общий вид окон и
приложения разрабатываются при помощи дизайнера оконных интерфейсов
Glade GUI builder.  Чтобы использовать разработанный интерфейс в
программном коде необходимо основным элементам управления задать
названия.  В главном меню все пункты поименованы следующим образом:
"circulation", "catalog", "member", "quit" и "about".

Класс ``gtk.glade.XML`` используется для трансляции и интерпретации
файлов glade, в результате его деятельности создаются элементы
управления интерфейса пользователя.  Вот пример трансляции и получения
доступа к элементу управления::

  import gtk.glade
  xmlobj = gtk.glade.XML('/path/to/file.glade')
  widget = xmlobj.get_widget('widget_name')

В модуле mainwindow.py находится код, подобный следующему::

  curdir = os.path.abspath(os.path.dirname(__file__))
  xml = os.path.join(curdir, 'glade', 'mainwindow.glade')
  xmlobj = gtk.glade.XML(xml)

  self.mainwindow = xmlobj.get_widget('mainwindow')

Название элемента управления, соответствующего главному окну, -
`mainwindow`.  Аналогичным образом можно получать доступ и к другим
элементам управления::

  circulation = xmlobj.get_widget('circulation')
  member = xmlobj.get_widget('member')
  quit = xmlobj.get_widget('quit')
  catalog = xmlobj.get_widget('catalog')
  about = xmlobj.get_widget('about')

Затем с элементами управления связываются обработчики возникающих событий::

  self.mainwindow.connect('delete_event', self.delete_event)
  quit.connect('activate', self.delete_event)
  circulation.connect('activate', self.on_circulation_activate)
  member.connect('activate', self.on_member_activate)
  catalog.connect('activate', self.on_catalog_activate)
  about.connect('activate', self.on_about_activate)

Событие `delete_event` возникает, когда пользователь пытается закрыть
окно при помощи кнопки закрытия окна.  Событие `activate`
инициируется, когда пользователь выбрал какой-либо пункт меню.  В
качестве обработчиков событий выступают функции, вызываемые в момент
возникновения события.

В приведенном фрагменте кода видно, что событие `delete_event`
главного окна соединено с методом `on_delete_event`.  Событие
`activate` элемента `quit` также соединено с этим же методом::

    def on_delete_event(self, *args):
        gtk.main_quit()

Функция `on_delete_event` просто вызывает функцию `main_quit`.

Исходный код приложения
~~~~~~~~~~~~~~~~~~~~~~~

Модуль `zcalib.py`::

  import registry
  import mainwindow

  if __name__ == '__main__':
      registry.initialize()
      try:
          mainwindow.main()
      except KeyboardInterrupt:
          import sys
          sys.exit(1)

В тексте импортируются модули `registry` и `mainwindow`.  Затем модуль
`registry` инициализируется и вызывается функция `main` модуля
`mainwindow`.  Если пользователь попытается завершить программу при
помощи комбинации клавиш `Ctrl+C`, программа закончит свое исполнение.
Чтобы не дать ей так везти себя перехватим исключение
`KeyboardInterrupt`.

Модуль `registry.py`::

  import sys
  from zope.component import getGlobalSiteManager

  from interfaces import IMember
  from interfaces import IBook
  from interfaces import ICirculation
  from interfaces import IDbOperation


  def initialize_rdb():
      from interfaces import IRelationalDatabase
      from relationaldatabase import RelationalDatabase
      from member import MemberRDbOperation
      from catalog import BookRDbOperation
      from circulation import CirculationRDbOperation

      gsm = getGlobalSiteManager()
      db = RelationalDatabase()
      gsm.registerUtility(db, IRelationalDatabase)

      gsm.registerAdapter(MemberRDbOperation,
                          (IMember,),
                          IDbOperation)

      gsm.registerAdapter(BookRDbOperation,
                          (IBook,),
                          IDbOperation)

      gsm.registerAdapter(CirculationRDbOperation,
                          (ICirculation,),
                          IDbOperation)

  def initialize_odb():
      from interfaces import IObjectDatabase
      from objectdatabase import ObjectDatabase
      from member import MemberODbOperation
      from catalog import BookODbOperation
      from circulation import CirculationODbOperation

      gsm = getGlobalSiteManager()
      db = ObjectDatabase()
      gsm.registerUtility(db, IObjectDatabase)

      gsm.registerAdapter(MemberODbOperation,
                          (IMember,),
                          IDbOperation)

      gsm.registerAdapter(BookODbOperation,
                          (IBook,),
                          IDbOperation)

      gsm.registerAdapter(CirculationODbOperation,
                          (ICirculation,),
                          IDbOperation)

  def check_use_relational_db():
      use_rdb = False
      try:
          arg = sys.argv[1]
          if arg == '-r':
              return True
      except IndexError:
          pass
      return use_rdb

  def initialize():
      use_rdb = check_use_relational_db()
      if use_rdb:
          initialize_rdb()
      else:
          initialize_odb()

Обратите внимание на функцию `initialize`, которая вызывается в
главном модуле `zcalib.py`.  Функция сначала проверяет, какую базу
данных надо использовать: реляционную (RDB) или объектную (ODB).
Проверка осуществляется в функции `check_use_relational_db`.  Если в
командной строке задать опцию `-r`, будет запущена `initialize_rdb`,
иначе - `initialize_odb`.  Если выбрана RDB, то будут установлены
компоненты, реализующие механизм  RDB.  В обратном случае - компоненты
для ODB.

Модуль `mainwindow.py`::

  import os
  import gtk
  import gtk.glade

  from circulationwindow import circulationwindow
  from catalogwindow import catalogwindow
  from memberwindow import memberwindow

  class MainWindow(object):

      def __init__(self):
          curdir = os.path.abspath(os.path.dirname(__file__))
          xml = os.path.join(curdir, 'glade', 'mainwindow.glade')
          xmlobj = gtk.glade.XML(xml)

          self.mainwindow = xmlobj.get_widget('mainwindow')
          circulation = xmlobj.get_widget('circulation')
          member = xmlobj.get_widget('member')
          quit = xmlobj.get_widget('quit')
          catalog = xmlobj.get_widget('catalog')
          about = xmlobj.get_widget('about')

          self.mainwindow.connect('delete_event', self.delete_event)
          quit.connect('activate', self.delete_event)

          circulation.connect('activate', self.on_circulation_activate)
          member.connect('activate', self.on_member_activate)
          catalog.connect('activate', self.on_catalog_activate)
          about.connect('activate', self.on_about_activate)

      def delete_event(self, *args):
          gtk.main_quit()

      def on_circulation_activate(self, *args):
          circulationwindow.show_all()

      def on_member_activate(self, *args):
          memberwindow.show_all()

      def on_catalog_activate(self, *args):
          catalogwindow.show_all()

      def on_about_activate(self, *args):
          pass

      def run(self):
          self.mainwindow.show_all()

  def main():
      mainwindow = MainWindow()
      mainwindow.run()
      gtk.main()


Функция `main` создает экземпляр класса `MainWindow`, который
инициализирует все элементы управления.

Модуль `memberwindow.py`::

  import os
  import gtk
  import gtk.glade

  from zope.component import getAdapter

  from components import Member
  from interfaces import IDbOperation


  class MemberWindow(object):

      def __init__(self):
          curdir = os.path.abspath(os.path.dirname(__file__))
          xml = os.path.join(curdir, 'glade', 'memberwindow.glade')
          xmlobj = gtk.glade.XML(xml)

          self.memberwindow = xmlobj.get_widget('memberwindow')
          self.number = xmlobj.get_widget('number')
          self.name = xmlobj.get_widget('name')
          add = xmlobj.get_widget('add')
          update = xmlobj.get_widget('update')
          delete = xmlobj.get_widget('delete')
          close = xmlobj.get_widget('close')
          self.treeview = xmlobj.get_widget('treeview')

          self.memberwindow.connect('delete_event', self.on_delete_event)
          add.connect('clicked', self.on_add_clicked)
          update.connect('clicked', self.on_update_clicked)
          delete.connect('clicked', self.on_delete_clicked)
          close.connect('clicked', self.on_delete_event)

          self.initialize_list()

      def show_all(self):
          self.populate_list_store()
          self.memberwindow.show_all()

      def populate_list_store(self):
          self.list_store.clear()
          member = Member()
          memberdboperation = getAdapter(member, IDbOperation)
          members = memberdboperation.get()
          for member in members:
              number = member.number
              name = member.name
              self.list_store.append((member, number, name,))

      def on_delete_event(self, *args):
          self.memberwindow.hide()
          return True

      def initialize_list(self):
          self.list_store = gtk.ListStore(object, str, str)
          self.treeview.set_model(self.list_store)
          tvcolumn = gtk.TreeViewColumn('Member Number')
          self.treeview.append_column(tvcolumn)

          cell = gtk.CellRendererText()
          tvcolumn.pack_start(cell, True)
          tvcolumn.add_attribute(cell, 'text', 1)

          tvcolumn = gtk.TreeViewColumn('Member Name')
          self.treeview.append_column(tvcolumn)

          cell = gtk.CellRendererText()
          tvcolumn.pack_start(cell, True)
          tvcolumn.add_attribute(cell, 'text', 2)

      def on_add_clicked(self, *args):
          number = self.number.get_text()
          name = self.name.get_text()
          member = Member()
          member.number = number
          member.name = name
          self.add(member)
          self.list_store.append((member, number, name,))

      def add(self, member):
          memberdboperation = getAdapter(member, IDbOperation)
          memberdboperation.add()

      def on_update_clicked(self, *args):
          number = self.number.get_text()
          name = self.name.get_text()
          treeselection = self.treeview.get_selection()
          model, iter = treeselection.get_selected()
          if not iter:
              return
          member = self.list_store.get_value(iter, 0)
          member.number = number
          member.name = name
          self.update(member)
          self.list_store.set(iter, 1, number, 2, name)

      def update(self, member):
          memberdboperation = getAdapter(member, IDbOperation)
          memberdboperation.update()

      def on_delete_clicked(self, *args):
          treeselection = self.treeview.get_selection()
          model, iter = treeselection.get_selected()
          if not iter:
              return
          member = self.list_store.get_value(iter, 0)
          self.delete(member)
          self.list_store.remove(iter)

      def delete(self, member):
          memberdboperation = getAdapter(member, IDbOperation)
          memberdboperation.delete()

  memberwindow = MemberWindow()

Модуль `components.py`::

  from zope.interface import implements

  from interfaces import IBook
  from interfaces import IMember
  from interfaces import ICirculation

  class Book(object):

      implements(IBook)

      barcode = ""
      title = ""
      author = ""

  class Member(object):

      implements(IMember)

      number = ""
      name = ""

  class Circulation(object):

      implements(ICirculation)

      book = Book()
      member = Member()

Модуль `interfaces.py`::

  from zope.interface import Interface
  from zope.interface import Attribute


  class IBook(Interface):

      barcode = Attribute("Barcode")
      author = Attribute("Author of book")
      title = Attribute("Title of book")


  class IMember(Interface):

      number = Attribute("ID number")
      name = Attribute("Name of member")


  class ICirculation(Interface):

      book = Attribute("A book")
      member = Attribute("A member")


  class IRelationalDatabase(Interface):

      def commit():
          pass

      def rollback():
          pass

      def cursor():
          pass

      def get_next_id():
          pass


  class IObjectDatabase(Interface):

      def commit():
          pass

      def rollback():
          pass

      def container():
          pass

      def get_next_id():
          pass


  class IDbOperation(Interface):

      def get():
          pass

      def add():
          pass

      def update():
          pass

      def delete():
          pass

Модуль `member.py`::

  from zope.interface import implements
  from zope.component import getUtility
  from zope.component import adapts

  from components import Member

  from interfaces import IRelationalDatabase
  from interfaces import IObjectDatabase
  from interfaces import IMember
  from interfaces import IDbOperation


  class MemberRDbOperation(object):

      implements(IDbOperation)
      adapts(IMember)

      def __init__(self, member):
          self.member = member

      def get(self):
          db = getUtility(IRelationalDatabase)
          cr = db.cursor()
          number = self.member.number
          if number:
              cr.execute("""SELECT
                              id,
                              number,
                              name
                            FROM members
                            WHERE number = ?""",
                         (number,))
          else:
              cr.execute("""SELECT
                              id,
                              number,
                              name
                            FROM members""")
          rst = cr.fetchall()
          cr.close()
          members = []
          for record in rst:
              id = record['id']
              number = record['number']
              name = record['name']
              member = Member()
              member.id = id
              member.number = number
              member.name = name
              members.append(member)
          return members

      def add(self):
          db = getUtility(IRelationalDatabase)
          cr = db.cursor()
          next_id = db.get_next_id("members")
          number = self.member.number
          name = self.member.name
          cr.execute("""INSERT INTO members
                          (id, number, name)
                        VALUES (?, ?, ?)""",
                     (next_id, number, name))
          cr.close()
          db.commit()
          self.member.id = next_id

      def update(self):
          db = getUtility(IRelationalDatabase)
          cr = db.cursor()
          number = self.member.number
          name = self.member.name
          id = self.member.id
          cr.execute("""UPDATE members
                          SET
                             number = ?,
                             name = ?
                        WHERE id = ?""",
                     (number, name, id))
          cr.close()
          db.commit()

      def delete(self):
          db = getUtility(IRelationalDatabase)
          cr = db.cursor()
          id = self.member.id
          cr.execute("""DELETE FROM members
                        WHERE id = ?""",
                     (id,))
          cr.close()
          db.commit()


  class MemberODbOperation(object):

      implements(IDbOperation)
      adapts(IMember)

      def __init__(self, member):
          self.member = member

      def get(self):
          db = getUtility(IObjectDatabase)
          zcalibdb = db.container()
          members = zcalibdb['members']
          return members.values()

      def add(self):
          db = getUtility(IObjectDatabase)
          zcalibdb = db.container()
          members = zcalibdb['members']
          number = self.member.number
          if number in [x.number for x in members.values()]:
              db.rollback()
              raise Exception("Duplicate key")
          next_id = db.get_next_id('members')
          self.member.id = next_id
          members[next_id] = self.member
          db.commit()

      def update(self):
          db = getUtility(IObjectDatabase)
          zcalibdb = db.container()
          members = zcalibdb['members']
          id = self.member.id
          members[id] = self.member
          db.commit()

      def delete(self):
          db = getUtility(IObjectDatabase)
          zcalibdb = db.container()
          members = zcalibdb['members']
          id = self.member.id
          del members[id]
          db.commit()

PySQLite
~~~~~~~~



ZODB
~~~~



Заключение
~~~~~~~~~~



Справочник
----------



adaptedBy
~~~~~~~~~

Функция возвращает перечень интерфейсов, адаптируемых
объектом-адаптером.

- Модуль: ``zope.component``

- Сигнатура: `adaptedBy(object)`

Пример::

  >>> from zope.interface import implements
  >>> from zope.component import adapts
  >>> from zope.component import adaptedBy

  >>> class FrontDeskNG(object):
  ...
  ...     implements(IDesk)
  ...     adapts(IGuest)
  ...
  ...     def __init__(self, guest):
  ...         self.guest = guest

  >>> adaptedBy(FrontDeskNG)
  (<InterfaceClass __builtin__.IGuest>,)

adapter
~~~~~~~

Адаптерами выступают любые вызываемые (callable) объекты.  Существует
специальный декоратор `adapter`, который позволяет декларировать
вызываемые объекты как адаптеры, адаптирующие заданные интерфейсы (или
классы).

- Модуль: ``zope.component``

- Спецификация: `adapter(*interfaces)`

Пример::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface
  >>> from zope.interface import implementer
  >>> from zope.component import adapter
  >>> from zope.interface import implements

  >>> class IJob(Interface):
  ...     """A job"""

  >>> class Job(object):
  ...     implements(IJob)

  >>> class IPerson(Interface):
  ...
  ...     name = Attribute("Name")
  ...     job = Attribute("Job")

  >>> class Person(object):
  ...     implements(IPerson)
  ...
  ...     name = None
  ...     job = None

  >>> @implementer(IJob)
  ... @adapter(IPerson)
  ... def personJob(person):
  ...     return person.job

  >>> jack = Person()
  >>> jack.name = "Jack"
  >>> jack.job = Job()
  >>> personJob(jack) #doctest: +ELLIPSIS
  <Job object at ...>

adapts
~~~~~~

Функция, которая определяет класс как адаптер.

- Модуль: ``zope.component``

- Спецификация: `adapts(*interfaces)`

Пример::

  >>> from zope.interface import implements
  >>> from zope.component import adapts

  >>> class FrontDeskNG(object):
  ...
  ...     implements(IDesk)
  ...     adapts(IGuest)
  ...
  ...     def __init__(self, guest):
  ...         self.guest = guest
  ...
  ...     def register(self):
  ...         next_id = get_next_id()
  ...         bookings_db[next_id] = {
  ...         'name': guest.name,
  ...         'place': guest.place,
  ...         'phone': guest.phone
  ...         }

alsoProvides
~~~~~~~~~~~~

Задает объекту перечень интерфейсов, которые он оснащает, в дополнение
к ранее декларированным.  Параметры функции, следующие за объектом, -
перечень интерфейсов (один или больше).

- Модуль: ``zope.interface``

- Спецификация: `alsoProvides(object, *interfaces)`

Пример::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface
  >>> from zope.interface import implements
  >>> from zope.interface import alsoProvides

  >>> class IPerson(Interface):
  ...
  ...     name = Attribute("Name of person")

  >>> class IStudent(Interface):
  ...
  ...     college = Attribute("Name of college")

  >>> class Person(object):
  ...
  ...     implements(IDesk)
  ...     name = u""

  >>> jack = Person()
  >>> jack.name = "Jack"
  >>> jack.college = "New College"
  >>> alsoProvides(jack, IStudent)

  You can test it like this:

  >>> from zope.interface import providedBy
  >>> IStudent in providedBy(jack)
  True

Attribute
~~~~~~~~~

Класс, предназначенный для определения атрибутов в интерфейсе.

- Модуль: ``zope.interface``

- Спецификация: `Attribute(name, doc='')`

- Смотри также: `Interface`_

Пример::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface

  >>> class IPerson(Interface):
  ...
  ...     name = Attribute("Name of person")
  ...     email = Attribute("Email Address")

classImplements
~~~~~~~~~~~~~~~

Задает дополнительные интерфейсы классы, которые он в системе будет
реализовывать.  Перечень аргументов, следующих за классом -
декларируемые интерфейсы, которые добавляются к списку ранее
декларированных интерфейсов.

- Модуль: ``zope.interface``

- Спецификация: `classImplements(cls, *interfaces)`

Пример::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface
  >>> from zope.interface import implements
  >>> from zope.interface import classImplements

  >>> class IPerson(Interface):
  ...
  ...     name = Attribute("Имя человека")

  >>> class IStudent(IPerson):
  ...
  ...     college = Attribute("Название колледжа")

  >>> class Person(object):
  ...
  ...     implements(IDesk)
  ...     name = u""
  ...     college = u""

  >>> classImplements(Person, IStudent)
  >>> ganes = Person()
  >>> ganes.name = "Баролби Гейнс"
  >>> ganes.college = "Саус-хермондский институт технологий"

  Результат тестируется следующим образом:

  >>> from zope.interface import providedBy
  >>> IStudent in providedBy(ganes)
  True

classImplementsOnly
~~~~~~~~~~~~~~~~~~~

Задает классу набор реализуемых им интерфейсов.  Перечень аргументов
после класса - задаваемые интерфейсы.  Ранее декларированные
интерфейсы заменяются данным перечнем.

 - Модуль: ``zope.interface``

 - Спецификация: `classImplementsOnly(cls, *interfaces)`

Пример::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface
  >>> from zope.interface import implements
  >>> from zope.interface import classImplementsOnly

  >>> class IPerson(Interface):
  ...
  ...     name = Attribute("Name of person")

  >>> class IStudent(Interface):
  ...
  ...     college = Attribute("Name of college")

  >>> class Person(object):
  ...
  ...     implements(IPerson)
  ...     college = u""

  >>> classImplementsOnly(Person, IStudent)
  >>> jack = Person()
  >>> jack.college = "New College"

  Результат тестируется следующим образом:

  >>> from zope.interface import providedBy
  >>> IPerson in providedBy(jack)
  False
  >>> IStudent in providedBy(jack)
  True

classProvides
~~~~~~~~~~~~~

Обычно если класс реализует определенный интерфейс, то его экземпляры
оснащают этот интерфейс.  Но когда надо, чтобы именно класс оснащал
некоторый интерфейс, то это реализуется функцией ``classProvides``.

- Модуль: ``zope.interface``

- Спецификация: `classProvides(*interfaces)`

Пример::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface
  >>> from zope.interface import classProvides

  >>> class IPerson(Interface):
  ...
  ...     name = Attribute("Name of person")

  >>> class Person(object):
  ...
  ...     classProvides(IPerson)
  ...     name = u"Jack"

  Результат тестируется следующим образом:

  >>> from zope.interface import providedBy
  >>> IPerson in providedBy(Person)
  True

ComponentLookupError
~~~~~~~~~~~~~~~~~~~~

Исключение, которое инициируется, если поиск компоненты не удался.

Пример::

  >>> class IPerson(Interface):
  ...
  ...     name = Attribute("Name of person")

  >>> person = object()
  >>> getAdapter(person, IPerson, 'not-exists') #doctest: +ELLIPSIS
  Traceback (most recent call last):
  ...
  ComponentLookupError: ...

createObject
~~~~~~~~~~~~

Создает объект, используя фабрику.

Производит поиск поименованной фабрики в текущем регистраторе
компонент (менеджере сайта) и запускает ее с заданными аргументами.
Если такой фабрики не удается найти, инициируется исключение
``ComponentLookupError``.  Возвращает созданный объект.

При помощи ключевого слова `context` в аргументе функции позволяет
задавать контекст, где следует искать фабрику, если не в текущем
регистраторе.  Ограничения технологии не позволяют передавать аргумент
по ключу "context" как аргумент фабрики.

- Модуль: ``zope.component``

- Спецификация: `createObject(factory_name, *args, **kwargs)`

Пример::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface
  >>> from zope.interface import implements

  >>> class IDatabase(Interface):
  ...
  ...     def getConnection():
  ...         """Return connection object"""

  >>> class FakeDb(object):
  ...
  ...     implements(IDatabase)
  ...
  ...     def getConnection(self):
  ...         return "connection"

  >>> from zope.component.factory import Factory

  >>> factory = Factory(FakeDb, 'FakeDb')

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> from zope.component.interfaces import IFactory
  >>> gsm.registerUtility(factory, IFactory, 'fakedb')

  >>> from zope.component import createObject
  >>> createObject('fakedb') #doctest: +ELLIPSIS
  <FakeDb object at ...>

Declaration
~~~~~~~~~~~

Непосредственно не запускается.

directlyProvidedBy
~~~~~~~~~~~~~~~~~~

Возвращает список интерфейсов, которые непосредственно оснащаются
объектом, переданным в параметре.

- Модуль: ``zope.interface``

- Спецификация: `directlyProvidedBy(object)`

Пример::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface

  >>> class IPerson(Interface):
  ...
  ...     name = Attribute("Name of person")

  >>> class IStudent(Interface):
  ...
  ...     college = Attribute("Name of college")

  >>> class ISmartPerson(Interface):
  ...     pass

  >>> class Person(object):
  ...
  ...     implements(IPerson)
  ...     name = u""

  >>> jack = Person()
  >>> jack.name = u"Jack"
  >>> jack.college = "New College"
  >>> alsoProvides(jack, ISmartPerson, IStudent)

  >>> from zope.interface import directlyProvidedBy

  >>> jack_dp = directlyProvidedBy(jack)
  >>> IPerson in jack_dp.interfaces()
  False
  >>> IStudent in jack_dp.interfaces()
  True
  >>> ISmartPerson in jack_dp.interfaces()
  True

directlyProvides
~~~~~~~~~~~~~~~~

Непосредственно задает перечень интерфейсов, оснащаемых объектом.
Аргументы, непосредственно следующие за объектом - перечень
декларируемых интерфейсов.  Заданные интерфейсы заменяют
декларированные ранее.

 - Модуль: ``zope.interface``

 - Спецификация: `directlyProvides(object, *interfaces)`

Пример::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface

  >>> class IPerson(Interface):
  ...
  ...     name = Attribute("Name of person")

  >>> class IStudent(Interface):
  ...
  ...     college = Attribute("Name of college")

  >>> class ISmartPerson(Interface):
  ...     pass

  >>> class Person(object):
  ...
  ...     implements(IPerson)
  ...     name = u""

  >>> jack = Person()
  >>> jack.name = u"Jack"
  >>> jack.college = "New College"
  >>> alsoProvides(jack, ISmartPerson, IStudent)

  >>> from zope.interface import directlyProvidedBy

  >>> jack_dp = directlyProvidedBy(jack)
  >>> ISmartPerson in jack_dp.interfaces()
  True
  >>> IPerson in jack_dp.interfaces()
  False
  >>> IStudent in jack_dp.interfaces()
  True
  >>> from zope.interface import providedBy

  >>> ISmartPerson in providedBy(jack)
  True

  >>> from zope.interface import directlyProvides
  >>> directlyProvides(jack, IStudent)

  >>> jack_dp = directlyProvidedBy(jack)
  >>> ISmartPerson in jack_dp.interfaces()
  False
  >>> IPerson in jack_dp.interfaces()
  False
  >>> IStudent in jack_dp.interfaces()
  True

  >>> ISmartPerson in providedBy(jack)
  False

getAdapter
~~~~~~~~~~

Возвращает поименованный адаптер к заданному интерфейсу для заданного
объекта.  Если подходящего адаптера не получается найти, создается
исключительная ситуация ``ComponentLookupError``.

- Модуль: ``zope.interface``

- Спецификация: `getAdapter(object, interface=Interface, name=u'', context=None)`

Пример::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface

  >>> class IDesk(Interface):
  ...     """A frontdesk will register object's details"""
  ...
  ...     def register():
  ...         """Register object's details"""
  ...

  >>> from zope.interface import implements
  >>> from zope.component import adapts

  >>> class FrontDeskNG(object):
  ...
  ...     implements(IDesk)
  ...     adapts(IGuest)
  ...
  ...     def __init__(self, guest):
  ...         self.guest = guest
  ...
  ...     def register(self):
  ...         next_id = get_next_id()
  ...         bookings_db[next_id] = {
  ...         'name': guest.name,
  ...         'place': guest.place,
  ...         'phone': guest.phone
  ...         }

  >>> class Guest(object):
  ...
  ...     implements(IGuest)
  ...
  ...     def __init__(self, name, place):
  ...         self.name = name
  ...         self.place = place

  >>> jack = Guest("Jack", "Bangalore")
  >>> jack_frontdesk = FrontDeskNG(jack)

  >>> IDesk.providedBy(jack_frontdesk)
  True

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()
  >>> gsm.registerAdapter(FrontDeskNG,
  ...                     (IGuest,), IDesk, 'ng')

  >>> getAdapter(jack, IDesk, 'ng') #doctest: +ELLIPSIS
  <FrontDeskNG object at ...>

getAdapterInContext
~~~~~~~~~~~~~~~~~~~

Вместо этой функции следует использовать аргумент `context` функции `getAdapter`_.

- Модуль: ``zope.component``

- Спецификация: `getAdapterInContext(object, interface, context)`

- Смотри также: `queryAdapterInContext`_

Пример::

  >>> from zope.component.globalregistry import BaseGlobalComponents
  >>> from zope.component import IComponentLookup
  >>> sm = BaseGlobalComponents()

  >>> class Context(object):
  ...     def __init__(self, sm):
  ...         self.sm = sm
  ...     def __conform__(self, interface):
  ...         if interface.isOrExtends(IComponentLookup):
  ...             return self.sm

  >>> context = Context(sm)

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface

  >>> class IDesk(Interface):
  ...     """A frontdesk will register object's details"""
  ...
  ...     def register():
  ...         """Register object's details"""
  ...

  >>> from zope.interface import implements
  >>> from zope.component import adapts

  >>> class FrontDeskNG(object):
  ...
  ...     implements(IDesk)
  ...     adapts(IGuest)
  ...
  ...     def __init__(self, guest):
  ...         self.guest = guest
  ...
  ...     def register(self):
  ...         next_id = get_next_id()
  ...         bookings_db[next_id] = {
  ...         'name': guest.name,
  ...         'place': guest.place,
  ...         'phone': guest.phone
  ...         }

  >>> class Guest(object):
  ...
  ...     implements(IGuest)
  ...
  ...     def __init__(self, name, place):
  ...         self.name = name
  ...         self.place = place

  >>> jack = Guest("Jack", "Bangalore")
  >>> jack_frontdesk = FrontDeskNG(jack)

  >>> IDesk.providedBy(jack_frontdesk)
  True

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()
  >>> sm.registerAdapter(FrontDeskNG,
  ...                     (IGuest,), IDesk)

  >>> from zope.component import getAdapterInContext

  >>> getAdapterInContext(jack, IDesk, sm) #doctest: +ELLIPSIS
  <FrontDeskNG object at ...>

getAdapters
~~~~~~~~~~~

Осуществляет поиск всех подходящих адаптеров к заданному интерфейсу и
заданным объектам.  Возвращает список адаптеров.  Если в списке есть
поименованный адаптер, то выдается наиболее специфический адаптер с
заданным именем.

- Модуль: ``zope.component``

- Спецификация: `getAdapters(objects, provided, context=None)`

Пример::

  >>> from zope.interface import implements
  >>> from zope.component import adapts

  >>> class FrontDeskNG(object):
  ...
  ...     implements(IDesk)
  ...     adapts(IGuest)
  ...
  ...     def __init__(self, guest):
  ...         self.guest = guest
  ...
  ...     def register(self):
  ...         next_id = get_next_id()
  ...         bookings_db[next_id] = {
  ...         'name': guest.name,
  ...         'place': guest.place,
  ...         'phone': guest.phone
  ...         }

  >>> jack = Guest("Jack", "Bangalore")
  >>> jack_frontdesk = FrontDeskNG(jack)

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> gsm.registerAdapter(FrontDeskNG, name='ng')

  >>> from zope.component import getAdapters
  >>> list(getAdapters((jack,), IDesk)) #doctest: +ELLIPSIS
  [(u'ng', <FrontDeskNG object at ...>)]

getAllUtilitiesRegisteredFor
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Возвращает все зарегистрированные утилиты для заданного интерфейса, в
том числе и те, которые были заменены (overridden).  По возвращаемому
значению можно осуществлять итерацию, где каждый элемент - это утилита.

- Модуль: ``zope.component``

- Спецификация: `getAllUtilitiesRegisteredFor(interface)`

Пример::

  >>> from zope.interface import Interface
  >>> from zope.interface import implements

  >>> class IGreeter(Interface):
  ...     def greet(name):
  ...         "say hello"

  >>> class Greeter(object):
  ...
  ...     implements(IGreeter)
  ...
  ...     def greet(self, name):
  ...         print "Hello", name

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> greet = Greeter()
  >>> gsm.registerUtility(greet, IGreeter)

  >>> from zope.component import getAllUtilitiesRegisteredFor

  >>> getAllUtilitiesRegisteredFor(IGreeter) #doctest: +ELLIPSIS
  [<Greeter object at ...>]

getFactoriesFor
~~~~~~~~~~~~~~~

Возвращает список двоек (name, factory) зарегистрированных фабрик
классов, реализующих заданный интерфейс.

 - Модуль: ``zope.component``

 - Спецификация: `getFactoriesFor(interface, context=None)`

Пример::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface
  >>> from zope.interface import implements

  >>> class IDatabase(Interface):
  ...
  ...     def getConnection():
  ...         """Return connection object"""

  >>> class FakeDb(object):
  ...
  ...     implements(IDatabase)
  ...
  ...     def getConnection(self):
  ...         return "connection"

  >>> from zope.component.factory import Factory

  >>> factory = Factory(FakeDb, 'FakeDb')

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> from zope.component.interfaces import IFactory
  >>> gsm.registerUtility(factory, IFactory, 'fakedb')

  >>> from zope.component import getFactoriesFor

  >>> list(getFactoriesFor(IDatabase))
  [(u'fakedb', <Factory for <class 'FakeDb'>>)]

getFactoryInterfaces
~~~~~~~~~~~~~~~~~~~~

Возвращает перечень интерфейсов, реализуемых фабрикой.  Производит
поиск по заданному имени фабрики, которая находится в ближайшем
контексте, затем возвращает либо ее интерфейс, либо n-ку (tuple)
интерфейсов, которые будут оснащать объекты, создаваемые данной
фабрикой.

- Модуль: ``zope.component``

- Спецификация: `getFactoryInterfaces(name, context=None)`

Пример::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface
  >>> from zope.interface import implements

  >>> class IDatabase(Interface):
  ...
  ...     def getConnection():
  ...         """Return connection object"""

  >>> class FakeDb(object):
  ...
  ...     implements(IDatabase)
  ...
  ...     def getConnection(self):
  ...         return "connection"

  >>> from zope.component.factory import Factory

  >>> factory = Factory(FakeDb, 'FakeDb')

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> from zope.component.interfaces import IFactory
  >>> gsm.registerUtility(factory, IFactory, 'fakedb')

  >>> from zope.component import getFactoryInterfaces

  >>> getFactoryInterfaces('fakedb')
  <implementedBy __builtin__.FakeDb>

getGlobalSiteManager
~~~~~~~~~~~~~~~~~~~~

Функция возвращает глобальный регистратор компонент (глобальный
менеджер сайта).  Эта функция не должна а принципе при выполнении
терпеть неуспех.  Возвращаемый объект оснащает интерфейс
`IGlobalSiteManager`

- Модуль: ``zope.component``

- Спецификация: `getGlobalSiteManager()`

Пример::

  >>> from zope.component import getGlobalSiteManager
  >>> from zope.component import globalSiteManager
  >>> gsm = getGlobalSiteManager()
  >>> gsm is globalSiteManager
  True

getMultiAdapter
~~~~~~~~~~~~~~~

Осуществляет поиск мультиадаптера (multi-adapter) к заданному
интерфейсу и набору адаптируемых объектов.  Возвращает мультиадаптер,
который способен адаптировать эти объекты к указанному интерфейсу.
Если такого адаптера найти не удается, то создается исключение
`ComponentLookupError`.  Пустое имя адаптера зарезервировано для
непоименнованных адаптеров.  Функции, реализующие поиск
непоименнованных адаптеров, - это функции поиска адаптеров, где в
качестве имени адаптера задается пустая строка.

- Модуль: ``zope.component``

- Спецификация: `getMultiAdapter(objects, interface=Interface, name='',
  context=None)`

- Смотри также: `queryMultiAdapter`_

Пример::

  >>> from zope.interface import Interface
  >>> from zope.interface import implements
  >>> from zope.component import adapts

  >>> class IAdapteeOne(Interface):
  ...     pass

  >>> class IAdapteeTwo(Interface):
  ...     pass

  >>> class IFunctionality(Interface):
  ...     pass

  >>> class MyFunctionality(object):
  ...     implements(IFunctionality)
  ...     adapts(IAdapteeOne, IAdapteeTwo)
  ...
  ...     def __init__(self, one, two):
  ...         self.one = one
  ...         self.two = two

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> gsm.registerAdapter(MyFunctionality)

  >>> class One(object):
  ...     implements(IAdapteeOne)

  >>> class Two(object):
  ...     implements(IAdapteeTwo)

  >>> one = One()
  >>> two = Two()

  >>> from zope.component import getMultiAdapter

  >>> getMultiAdapter((one,two), IFunctionality) #doctest: +ELLIPSIS
  <MyFunctionality object at ...>

  >>> myfunctionality = getMultiAdapter((one,two), IFunctionality)
  >>> myfunctionality.one #doctest: +ELLIPSIS
  <One object at ...>
  >>> myfunctionality.two #doctest: +ELLIPSIS
  <Two object at ...>

getSiteManager
~~~~~~~~~~~~~~

Возвращает регистратор компонент (менеджер сайта), который является
наиближайщем в заданном контексте. Если параметр `context` равен
`None`, то возвращается глобальный регистратор.  Если параметр
`context` не равен `None`, то предполагается, что найдется какой-либо
адаптер из `context`-а `IComponentLookup`.  Если же найти такой
адаптер на самом деле не удалось, создается исключение
`ComponentLookupError`.

- Модуль: ``zope.component``

- Спецификация: `getSiteManager(context=None)`

Example 1::

  >>> from zope.component.globalregistry import BaseGlobalComponents
  >>> from zope.component import IComponentLookup
  >>> sm = BaseGlobalComponents()

  >>> class Context(object):
  ...     def __init__(self, sm):
  ...         self.sm = sm
  ...     def __conform__(self, interface):
  ...         if interface.isOrExtends(IComponentLookup):
  ...             return self.sm

  >>> context = Context(sm)

  >>> from zope.component import getSiteManager

  >>> lsm = getSiteManager(context)
  >>> lsm is sm
  True

Example 2::

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> sm = getSiteManager()
  >>> gsm is sm
  True

getUtilitiesFor
~~~~~~~~~~~~~~~

Look up the registered utilities that provide an interface.  Returns
an iterable of name-utility pairs.

- Модуль: ``zope.component``

- Спецификация: `getUtilitiesFor(interface)`

Пример::

  >>> from zope.interface import Interface
  >>> from zope.interface import implements

  >>> class IGreeter(Interface):
  ...     def greet(name):
  ...         "say hello"

  >>> class Greeter(object):
  ...
  ...     implements(IGreeter)
  ...
  ...     def greet(self, name):
  ...         print "Hello", name

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> greet = Greeter()
  >>> gsm.registerUtility(greet, IGreeter)

  >>> from zope.component import getUtilitiesFor

  >>> list(getUtilitiesFor(IGreeter)) #doctest: +ELLIPSIS
  [(u'', <Greeter object at ...>)]

getUtility
~~~~~~~~~~

Get the utility that provides interface.  Returns the nearest utility
to the context that implements the specified interface.  If one is not
found, raises ``ComponentLookupError``.

- Модуль: ``zope.component``

- Спецификация: `getUtility(interface, name='', context=None)`

Пример::

  >>> from zope.interface import Interface
  >>> from zope.interface import implements

  >>> class IGreeter(Interface):
  ...     def greet(name):
  ...         "say hello"

  >>> class Greeter(object):
  ...
  ...     implements(IGreeter)
  ...
  ...     def greet(self, name):
  ...         return "Hello " + name

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> greet = Greeter()
  >>> gsm.registerUtility(greet, IGreeter)

  >>> from zope.component import getUtility

  >>> getUtility(IGreeter).greet('Jack')
  'Hello Jack'

handle
~~~~~~

Call all of the handlers for the given objects.  Handlers are
subscription adapter factories that don't produce anything.  They do
all of their work when called.  Handlers are typically used to handle
events.

- Модуль: ``zope.component``

- Спецификация: `handle(*objects)`

Пример::

  >>> import datetime

  >>> def documentCreated(event):
  ...     event.doc.created = datetime.datetime.utcnow()

  >>> from zope.interface import Interface
  >>> from zope.interface import Attribute
  >>> from zope.interface import implements

  >>> class IDocumentCreated(Interface):
  ...     doc = Attribute("The document that was created")

  >>> class DocumentCreated(object):
  ...     implements(IDocumentCreated)
  ...
  ...     def __init__(self, doc):
  ...         self.doc = doc


  >>> def documentCreated(event):
  ...     event.doc.created = datetime.datetime.utcnow()

  >>> from zope.component import adapter

  >>> @adapter(IDocumentCreated)
  ... def documentCreated(event):
  ...     event.doc.created = datetime.datetime.utcnow()


  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> gsm.registerHandler(documentCreated)

  >>> from zope.component import handle

  >>> handle(DocumentCreated(doc))
  >>> doc.created.__class__.__name__
  'datetime'

implementedBy
~~~~~~~~~~~~~

Return the interfaces implemented for a class' instances.

- Модуль: ``zope.interface``

- Спецификация: `implementedBy(class_)`

Example 1::

  >>> from zope.interface import Interface
  >>> from zope.interface import implements

  >>> class IGreeter(Interface):
  ...     def greet(name):
  ...         "say hello"

  >>> class Greeter(object):
  ...
  ...     implements(IGreeter)
  ...
  ...     def greet(self, name):
  ...         print "Hello", name

  >>> from zope.interface import implementedBy
  >>> implementedBy(Greeter)
  <implementedBy __builtin__.Greeter>

Example 2::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface
  >>> from zope.interface import implements

  >>> class IPerson(Interface):
  ...     name = Attribute("Name of person")

  >>> class ISpecial(Interface):
  ...     pass

  >>> class Person(object):
  ...     implements(IPerson)
  ...     name = u""

  >>> from zope.interface import classImplements
  >>> classImplements(Person, ISpecial)

  >>> from zope.interface import implementedBy

  To get a list of all interfaces implemented by that class::

  >>> [x.__name__ for x in implementedBy(Person)]
  ['IPerson', 'ISpecial']

implementer
~~~~~~~~~~~

Create a decorator for declaring interfaces implemented by a factory.
A callable is returned that makes an implements declaration on objects
passed to it.

- Модуль: ``zope.interface``

- Спецификация: `implementer(*interfaces)`

Пример::

  >>> from zope.interface import implementer
  >>> class IFoo(Interface):
  ...     pass
  >>> class Foo(object):
  ...     implements(IFoo)

  >>> @implementer(IFoo)
  ... def foocreator():
  ...     foo = Foo()
  ...     return foo
  >>> list(implementedBy(foocreator))
  [<InterfaceClass __builtin__.IFoo>]

implements
~~~~~~~~~~

Declare interfaces implemented by instances of a class This function
is called in a class definition.  The arguments are one or more
interfaces.  The interfaces given are added to any interfaces
previously declared.  Previous declarations include declarations for
base classes unless implementsOnly was used.

- Модуль: ``zope.interface``

- Спецификация: `implements(*interfaces)`

Пример::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface
  >>> from zope.interface import implements

  >>> class IPerson(Interface):
  ...
  ...     name = Attribute("Name of person")

  >>> class Person(object):
  ...
  ...     implements(IPerson)
  ...     name = u""

  >>> jack = Person()
  >>> jack.name = "Jack"

  You can test it like this:

  >>> from zope.interface import providedBy
  >>> IPerson in providedBy(jack)
  True

implementsOnly
~~~~~~~~~~~~~~

Declare the only interfaces implemented by instances of a class.  This
function is called in a class definition.  The arguments are one or
more interfaces.  Previous declarations including declarations for
base classes are overridden.

- Модуль: ``zope.interface``

- Спецификация: `implementsOnly(*interfaces)`

Пример::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface
  >>> from zope.interface import implements
  >>> from zope.interface import implementsOnly

  >>> class IPerson(Interface):
  ...
  ...     name = Attribute("Name of person")

  >>> class IStudent(Interface):
  ...
  ...     college = Attribute("Name of college")

  >>> class Person(object):
  ...
  ...     implements(IPerson)
  ...     name = u""

  >>> class NewPerson(Person):
  ...     implementsOnly(IStudent)
  ...     college = u""

  >>> jack = NewPerson()
  >>> jack.college = "New College"

  You can test it like this:

  >>> from zope.interface import providedBy
  >>> IPerson in providedBy(jack)
  False
  >>> IStudent in providedBy(jack)
  True

Interface
~~~~~~~~~

Using this class, you can define an interface.  To define an
interface, just inherit from ``Interface`` class.

- Модуль: ``zope.interface``

- Спецификация: `Interface(name, doc='')`

Example 1::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface

  >>> class IPerson(Interface):
  ...
  ...     name = Attribute("Name of person")
  ...     email = Attribute("Email Address")


Example 2::

  >>> from zope.interface import Interface

  >>> class IHost(Interface):
  ...
  ...     def goodmorning(guest):
  ...         """Say good morning to guest"""

moduleProvides
~~~~~~~~~~~~~~

Declare interfaces provided by a module.  This function is used in a
module definition.  The arguments are one or more interfaces.  The
given interfaces are used to create the module's direct-object
interface specification.  An error will be raised if the module
already has an interface specification.  In other words, it is an
error to call this function more than once in a module definition.

This function is provided for convenience.  It provides a more
convenient way to call ``directlyProvides`` for a module.

- Модуль: ``zope.interface``

- Спецификация: `moduleProvides(*interfaces)`

- Смотри также: `directlyProvides`_

You can see an example usage in `zope.component` source itself.  The
`__init__.py` file has a statement like this::

  moduleProvides(IComponentArchitecture,
                 IComponentRegistrationConvenience)

So, the `zope.component` provides two interfaces:
`IComponentArchitecture` and `IComponentRegistrationConvenience`.

noLongerProvides
~~~~~~~~~~~~~~~~

Remove an interface from the list of an object's directly provided
interfaces.

- Модуль: ``zope.interface``

- Спецификация: `noLongerProvides(object, interface)`

Пример::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface
  >>> from zope.interface import implements
  >>> from zope.interface import classImplements

  >>> class IPerson(Interface):
  ...
  ...     name = Attribute("Name of person")

  >>> class IStudent(Interface):
  ...
  ...     college = Attribute("Name of college")

  >>> class Person(object):
  ...
  ...     implements(IPerson)
  ...     name = u""

  >>> jack = Person()
  >>> jack.name = "Jack"
  >>> jack.college = "New College"
  >>> directlyProvides(jack, IStudent)

  You can test it like this:

  >>> from zope.interface import providedBy
  >>> IPerson in providedBy(jack)
  True
  >>> IStudent in providedBy(jack)
  True
  >>> from zope.interface import noLongerProvides
  >>> noLongerProvides(jack, IStudent)
  >>> IPerson in providedBy(jack)
  True
  >>> IStudent in providedBy(jack)
  False

provideAdapter
~~~~~~~~~~~~~~

It is recommended to use `registerAdapter`_ .

provideHandler
~~~~~~~~~~~~~~

It is recommended to use `registerHandler`_ .

provideSubscriptionAdapter
~~~~~~~~~~~~~~~~~~~~~~~~~~

It is recommended to use `registerSubscriptionAdapter`_ .

provideUtility
~~~~~~~~~~~~~~

It is recommended to use `registerUtility`_ .

providedBy
~~~~~~~~~~

Test whether the interface is implemented by the object.  Return true
if the object asserts that it implements the interface, including
asserting that it implements an extended interface.

- Модуль: ``zope.interface``

- Спецификация: `providedBy(object)`

Example 1::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface
  >>> from zope.interface import implements

  >>> class IPerson(Interface):
  ...
  ...     name = Attribute("Name of person")

  >>> class Person(object):
  ...
  ...     implements(IPerson)
  ...     name = u""

  >>> jack = Person()
  >>> jack.name = "Jack"

  You can test it like this:

  >>> from zope.interface import providedBy
  >>> IPerson in providedBy(jack)
  True

Example 2::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface
  >>> from zope.interface import implements

  >>> class IPerson(Interface):
  ...     name = Attribute("Name of person")

  >>> class ISpecial(Interface):
  ...     pass

  >>> class Person(object):
  ...     implements(IPerson)
  ...     name = u""

  >>> from zope.interface import classImplements
  >>> classImplements(Person, ISpecial)
  >>> from zope.interface import providedBy
  >>> jack = Person()
  >>> jack.name = "Jack"

  To get a list of all interfaces provided by that object::

  >>> [x.__name__ for x in providedBy(jack)]
  ['IPerson', 'ISpecial']

queryAdapter
~~~~~~~~~~~~

Look for a named adapter to an interface for an object.  Returns an
adapter that can adapt object to interface.  If a matching adapter
cannot be found, returns the default.

- Модуль: ``zope.component``

- Спецификация: `queryAdapter(object, interface=Interface, name=u'',
  default=None, context=None)`

Пример::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface

  >>> class IDesk(Interface):
  ...     """A frontdesk will register object's details"""
  ...
  ...     def register():
  ...         """Register object's details"""
  ...

  >>> from zope.interface import implements
  >>> from zope.component import adapts

  >>> class FrontDeskNG(object):
  ...
  ...     implements(IDesk)
  ...     adapts(IGuest)
  ...
  ...     def __init__(self, guest):
  ...         self.guest = guest
  ...
  ...     def register(self):
  ...         next_id = get_next_id()
  ...         bookings_db[next_id] = {
  ...         'name': guest.name,
  ...         'place': guest.place,
  ...         'phone': guest.phone
  ...         }

  >>> class Guest(object):
  ...
  ...     implements(IGuest)
  ...
  ...     def __init__(self, name, place):
  ...         self.name = name
  ...         self.place = place

  >>> jack = Guest("Jack", "Bangalore")
  >>> jack_frontdesk = FrontDeskNG(jack)

  >>> IDesk.providedBy(jack_frontdesk)
  True

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()
  >>> gsm.registerAdapter(FrontDeskNG,
  ...                     (IGuest,), IDesk, 'ng')

  >>> queryAdapter(jack, IDesk, 'ng') #doctest: +ELLIPSIS
  <FrontDeskNG object at ...>

queryAdapterInContext
~~~~~~~~~~~~~~~~~~~~~

Look for a special adapter to an interface for an object.

NOTE: This method should only be used if a custom context needs to be
provided to provide custom component lookup. Otherwise, call the
interface, as in::

  interface(object, default)

Returns an adapter that can adapt object to interface.  If a matching
adapter cannot be found, returns the default.

Context is adapted to IServiceService, and this adapter's 'Adapters'
service is used.

If the object has a __conform__ method, this method will be called
with the requested interface.  If the method returns a non-None value,
that value will be returned. Otherwise, if the object already
implements the interface, the object will be returned.

- Модуль: ``zope.component``

- Спецификация: `queryAdapterInContext(object, interface, context,
  default=None)`

- Смотри также: `getAdapterInContext`_

Пример::

  >>> from zope.component.globalregistry import BaseGlobalComponents
  >>> from zope.component import IComponentLookup
  >>> sm = BaseGlobalComponents()

  >>> class Context(object):
  ...     def __init__(self, sm):
  ...         self.sm = sm
  ...     def __conform__(self, interface):
  ...         if interface.isOrExtends(IComponentLookup):
  ...             return self.sm

  >>> context = Context(sm)

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface

  >>> class IDesk(Interface):
  ...     """A frontdesk will register object's details"""
  ...
  ...     def register():
  ...         """Register object's details"""
  ...

  >>> from zope.interface import implements
  >>> from zope.component import adapts

  >>> class FrontDeskNG(object):
  ...
  ...     implements(IDesk)
  ...     adapts(IGuest)
  ...
  ...     def __init__(self, guest):
  ...         self.guest = guest
  ...
  ...     def register(self):
  ...         next_id = get_next_id()
  ...         bookings_db[next_id] = {
  ...         'name': guest.name,
  ...         'place': guest.place,
  ...         'phone': guest.phone
  ...         }

  >>> class Guest(object):
  ...
  ...     implements(IGuest)
  ...
  ...     def __init__(self, name, place):
  ...         self.name = name
  ...         self.place = place

  >>> jack = Guest("Jack", "Bangalore")
  >>> jack_frontdesk = FrontDeskNG(jack)

  >>> IDesk.providedBy(jack_frontdesk)
  True

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()
  >>> sm.registerAdapter(FrontDeskNG,
  ...                     (IGuest,), IDesk)

  >>> from zope.component import queryAdapterInContext

  >>> queryAdapterInContext(jack, IDesk, sm) #doctest: +ELLIPSIS
  <FrontDeskNG object at ...>

queryMultiAdapter
~~~~~~~~~~~~~~~~~

Look for a multi-adapter to an interface for objects.  Returns a
multi-adapter that can adapt objects to interface.  If a matching
adapter cannot be found, returns the default.  The name consisting of
an empty string is reserved for unnamed adapters.  The unnamed adapter
methods will often call the named adapter methods with an empty string
for a name.

- Модуль: ``zope.component``

- Спецификация: `queryMultiAdapter(objects, interface=Interface,
  name=u'', default=None, context=None)`

- Смотри также: `getMultiAdapter`_

Пример::

  >>> from zope.interface import Interface
  >>> from zope.interface import implements
  >>> from zope.component import adapts

  >>> class IAdapteeOne(Interface):
  ...     pass

  >>> class IAdapteeTwo(Interface):
  ...     pass

  >>> class IFunctionality(Interface):
  ...     pass

  >>> class MyFunctionality(object):
  ...     implements(IFunctionality)
  ...     adapts(IAdapteeOne, IAdapteeTwo)
  ...
  ...     def __init__(self, one, two):
  ...         self.one = one
  ...         self.two = two

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> gsm.registerAdapter(MyFunctionality)

  >>> class One(object):
  ...     implements(IAdapteeOne)

  >>> class Two(object):
  ...     implements(IAdapteeTwo)

  >>> one = One()
  >>> two = Two()

  >>> from zope.component import queryMultiAdapter

  >>> getMultiAdapter((one,two), IFunctionality) #doctest: +ELLIPSIS
  <MyFunctionality object at ...>

  >>> myfunctionality = queryMultiAdapter((one,two), IFunctionality)
  >>> myfunctionality.one #doctest: +ELLIPSIS
  <One object at ...>
  >>> myfunctionality.two #doctest: +ELLIPSIS
  <Two object at ...>

queryUtility
~~~~~~~~~~~~

This function is used to look up a utility that provides an interface.
If one is not found, returns default.

- Модуль: ``zope.component``

- Спецификация: `queryUtility(interface, name='', default=None)`

Пример::

  >>> from zope.interface import Interface
  >>> from zope.interface import implements

  >>> class IGreeter(Interface):
  ...     def greet(name):
  ...         "say hello"

  >>> class Greeter(object):
  ...
  ...     implements(IGreeter)
  ...
  ...     def greet(self, name):
  ...         return "Hello " + name

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> greet = Greeter()
  >>> gsm.registerUtility(greet, IGreeter)

  >>> from zope.component import queryUtility

  >>> queryUtility(IGreeter).greet('Jack')
  'Hello Jack'

registerAdapter
~~~~~~~~~~~~~~~

This function is used to register an adapter factory.

- Модуль: ``zope.component - IComponentRegistry``

- Спецификация: `registerAdapter(factory, required=None, provided=None,
  name=u'', info=u'')`

- Смотри также: `unregisterAdapter`_

Пример::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface

  >>> class IDesk(Interface):
  ...     """A frontdesk will register object's details"""
  ...
  ...     def register():
  ...         """Register object's details"""
  ...

  >>> from zope.interface import implements
  >>> from zope.component import adapts

  >>> class FrontDeskNG(object):
  ...
  ...     implements(IDesk)
  ...     adapts(IGuest)
  ...
  ...     def __init__(self, guest):
  ...         self.guest = guest
  ...
  ...     def register(self):
  ...         next_id = get_next_id()
  ...         bookings_db[next_id] = {
  ...         'name': guest.name,
  ...         'place': guest.place,
  ...         'phone': guest.phone
  ...         }

  >>> class Guest(object):
  ...
  ...     implements(IGuest)
  ...
  ...     def __init__(self, name, place):
  ...         self.name = name
  ...         self.place = place

  >>> jack = Guest("Jack", "Bangalore")
  >>> jack_frontdesk = FrontDeskNG(jack)

  >>> IDesk.providedBy(jack_frontdesk)
  True

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()
  >>> gsm.registerAdapter(FrontDeskNG,
  ...                     (IGuest,), IDesk, 'ng')

  You can test it like this:

  >>> queryAdapter(jack, IDesk, 'ng') #doctest: +ELLIPSIS
  <FrontDeskNG object at ...>

registeredAdapters
~~~~~~~~~~~~~~~~~~

Return an iterable of `IAdapterRegistrations`.  These registrations
describe the current adapter registrations in the object.

- Модуль: ``zope.component - IComponentRegistry``

- Спецификация: `registeredAdapters()`

Пример::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface

  >>> class IDesk(Interface):
  ...     """A frontdesk will register object's details"""
  ...
  ...     def register():
  ...         """Register object's details"""
  ...

  >>> from zope.interface import implements
  >>> from zope.component import adapts

  >>> class FrontDeskNG(object):
  ...
  ...     implements(IDesk)
  ...     adapts(IGuest)
  ...
  ...     def __init__(self, guest):
  ...         self.guest = guest
  ...
  ...     def register(self):
  ...         next_id = get_next_id()
  ...         bookings_db[next_id] = {
  ...         'name': guest.name,
  ...         'place': guest.place,
  ...         'phone': guest.phone
  ...         }

  >>> class Guest(object):
  ...
  ...     implements(IGuest)
  ...
  ...     def __init__(self, name, place):
  ...         self.name = name
  ...         self.place = place

  >>> jack = Guest("Jack", "Bangalore")
  >>> jack_frontdesk = FrontDeskNG(jack)

  >>> IDesk.providedBy(jack_frontdesk)
  True

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()
  >>> gsm.registerAdapter(FrontDeskNG,
  ...                     (IGuest,), IDesk, 'ng2')


  >>> reg_adapter = list(gsm.registeredAdapters())
  >>> 'ng2' in [x.name for x in reg_adapter]
  True

registeredHandlers
~~~~~~~~~~~~~~~~~~

Return an iterable of `IHandlerRegistrations`.  These registrations
describe the current handler registrations in the object.

- Модуль: ``zope.component - IComponentRegistry``

- Спецификация: `registeredHandlers()`

Пример::

  >>> import datetime

  >>> def documentCreated(event):
  ...     event.doc.created = datetime.datetime.utcnow()

  >>> from zope.interface import Interface
  >>> from zope.interface import Attribute
  >>> from zope.interface import implements

  >>> class IDocumentCreated(Interface):
  ...     doc = Attribute("The document that was created")

  >>> class DocumentCreated(object):
  ...     implements(IDocumentCreated)
  ...
  ...     def __init__(self, doc):
  ...         self.doc = doc


  >>> def documentCreated(event):
  ...     event.doc.created = datetime.datetime.utcnow()

  >>> from zope.component import adapter

  >>> @adapter(IDocumentCreated)
  ... def documentCreated(event):
  ...     event.doc.created = datetime.datetime.utcnow()


  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> gsm.registerHandler(documentCreated, info='ng3')

  >>> reg_adapter = list(gsm.registeredHandlers())
  >>> 'ng3' in [x.info for x in reg_adapter]
  True

  >>> gsm.registerHandler(documentCreated, name='ng4')
  Traceback (most recent call last):
  ...
  TypeError: Named handlers are not yet supported

registeredSubscriptionAdapters
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Return an iterable of `ISubscriptionAdapterRegistrations`.  These
registrations describe the current subscription adapter registrations
in the object.

- Модуль: ``zope.component - IComponentRegistry``

- Спецификация: `registeredSubscriptionAdapters()`

Пример::

  >>> from zope.interface import Interface
  >>> from zope.interface import Attribute
  >>> from zope.interface import implements

  >>> class IValidate(Interface):
  ...     def validate(ob):
  ...         """Determine whether the object is valid
  ...
  ...         Return a string describing a validation problem.
  ...         An empty string is returned to indicate that the
  ...         object is valid.
  ...         """

  >>> class IDocument(Interface):
  ...     summary = Attribute("Document summary")
  ...     body = Attribute("Document text")

  >>> class Document(object):
  ...     implements(IDocument)
  ...     def __init__(self, summary, body):
  ...         self.summary, self.body = summary, body

  >>> from zope.component import adapts

  >>> class AdequateLength(object):
  ...
  ...     adapts(IDocument)
  ...     implements(IValidate)
  ...
  ...     def __init__(self, doc):
  ...         self.doc = doc
  ...
  ...     def validate(self):
  ...         if len(self.doc.body) < 1000:
  ...             return 'too short'
  ...         else:
  ...             return ''

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> gsm.registerSubscriptionAdapter(AdequateLength, info='ng4')

  >>> reg_adapter = list(gsm.registeredSubscriptionAdapters())
  >>> 'ng4' in [x.info for x in reg_adapter]
  True

registeredUtilities
~~~~~~~~~~~~~~~~~~~

This function return an iterable of `IUtilityRegistrations`.  These
registrations describe the current utility registrations in the
object.

- Модуль: ``zope.component - IComponentRegistry``

- Спецификация: `registeredUtilities()`

Пример::

  >>> from zope.interface import Interface
  >>> from zope.interface import implements

  >>> class IGreeter(Interface):
  ...     def greet(name):
  ...         "say hello"

  >>> class Greeter(object):
  ...
  ...     implements(IGreeter)
  ...
  ...     def greet(self, name):
  ...         print "Hello", name

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> greet = Greeter()
  >>> gsm.registerUtility(greet, info='ng5')

  >>> reg_adapter = list(gsm.registeredUtilities())
  >>> 'ng5' in [x.info for x in reg_adapter]
  True

registerHandler
~~~~~~~~~~~~~~~

This function is used to register a handler.  A handler is a
subscriber that doesn't compute an adapter but performs some function
when called.

- Модуль: ``zope.component - IComponentRegistry``

- Спецификация: `registerHandler(handler, required=None, name=u'', info='')`

- Смотри также: `unregisterHandler`_

Note: In the current implementation of ``zope.component`` doesn't
support `name` attribute.

Пример::

  >>> import datetime

  >>> def documentCreated(event):
  ...     event.doc.created = datetime.datetime.utcnow()

  >>> from zope.interface import Interface
  >>> from zope.interface import Attribute
  >>> from zope.interface import implements

  >>> class IDocumentCreated(Interface):
  ...     doc = Attribute("The document that was created")

  >>> class DocumentCreated(object):
  ...     implements(IDocumentCreated)
  ...
  ...     def __init__(self, doc):
  ...         self.doc = doc


  >>> def documentCreated(event):
  ...     event.doc.created = datetime.datetime.utcnow()

  >>> from zope.component import adapter

  >>> @adapter(IDocumentCreated)
  ... def documentCreated(event):
  ...     event.doc.created = datetime.datetime.utcnow()


  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> gsm.registerHandler(documentCreated)

  >>> from zope.component import handle

  >>> handle(DocumentCreated(doc))
  >>> doc.created.__class__.__name__
  'datetime'

registerSubscriptionAdapter
~~~~~~~~~~~~~~~~~~~~~~~~~~~

This function is used to register a subscriber factory.

- Модуль: ``zope.component - IComponentRegistry``

- Спецификация: `registerSubscriptionAdapter(factory, required=None,
  provides=None, name=u'', info='')`

- Смотри также: `unregisterSubscriptionAdapter`_

Пример::

  >>> from zope.interface import Interface
  >>> from zope.interface import Attribute
  >>> from zope.interface import implements

  >>> class IValidate(Interface):
  ...     def validate(ob):
  ...         """Determine whether the object is valid
  ...
  ...         Return a string describing a validation problem.
  ...         An empty string is returned to indicate that the
  ...         object is valid.
  ...         """

  >>> class IDocument(Interface):
  ...     summary = Attribute("Document summary")
  ...     body = Attribute("Document text")

  >>> class Document(object):
  ...     implements(IDocument)
  ...     def __init__(self, summary, body):
  ...         self.summary, self.body = summary, body

  >>> from zope.component import adapts

  >>> class AdequateLength(object):
  ...
  ...     adapts(IDocument)
  ...     implements(IValidate)
  ...
  ...     def __init__(self, doc):
  ...         self.doc = doc
  ...
  ...     def validate(self):
  ...         if len(self.doc.body) < 1000:
  ...             return 'too short'
  ...         else:
  ...             return ''

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> gsm.registerSubscriptionAdapter(AdequateLength)

registerUtility
~~~~~~~~~~~~~~~

This function is used to register a utility.

- Модуль: ``zope.component - IComponentRegistry``

- Спецификация: `registerUtility(component, provided=None, name=u'',
  info=u'')`

- Смотри также: `unregisterUtility`_

Пример::

  >>> from zope.interface import Interface
  >>> from zope.interface import implements

  >>> class IGreeter(Interface):
  ...     def greet(name):
  ...         "say hello"

  >>> class Greeter(object):
  ...
  ...     implements(IGreeter)
  ...
  ...     def greet(self, name):
  ...         print "Hello", name

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> greet = Greeter()
  >>> gsm.registerUtility(greet)

subscribers
~~~~~~~~~~~

This function is used to get subscribers.  Subscribers are returned
that provide the provided interface and that depend on and are
computed from the sequence of required objects.

- Модуль: ``zope.component - IComponentRegistry``

- Спецификация: `subscribers(required, provided, context=None)`

Пример::

  >>> from zope.interface import Interface
  >>> from zope.interface import Attribute
  >>> from zope.interface import implements

  >>> class IValidate(Interface):
  ...     def validate(ob):
  ...         """Determine whether the object is valid
  ...
  ...         Return a string describing a validation problem.
  ...         An empty string is returned to indicate that the
  ...         object is valid.
  ...         """

  >>> class IDocument(Interface):
  ...     summary = Attribute("Document summary")
  ...     body = Attribute("Document text")

  >>> class Document(object):
  ...     implements(IDocument)
  ...     def __init__(self, summary, body):
  ...         self.summary, self.body = summary, body

  >>> from zope.component import adapts

  >>> class SingleLineSummary:
  ...     adapts(IDocument)
  ...     implements(IValidate)
  ...
  ...     def __init__(self, doc):
  ...         self.doc = doc
  ...
  ...     def validate(self):
  ...         if '\n' in self.doc.summary:
  ...             return 'Summary should only have one line'
  ...         else:
  ...             return ''

  >>> class AdequateLength(object):
  ...     adapts(IDocument)
  ...     implements(IValidate)
  ...
  ...     def __init__(self, doc):
  ...         self.doc = doc
  ...
  ...     def validate(self):
  ...         if len(self.doc.body) < 1000:
  ...             return 'too short'
  ...         else:
  ...             return ''

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> gsm.registerSubscriptionAdapter(SingleLineSummary)
  >>> gsm.registerSubscriptionAdapter(AdequateLength)

  >>> from zope.component import subscribers

  >>> doc = Document("A\nDocument", "blah")
  >>> [adapter.validate()
  ...  for adapter in subscribers([doc], IValidate)
  ...  if adapter.validate()]
  ['Summary should only have one line', 'too short']

  >>> doc = Document("A\nDocument", "blah" * 1000)
  >>> [adapter.validate()
  ...  for adapter in subscribers([doc], IValidate)
  ...  if adapter.validate()]
  ['Summary should only have one line']

  >>> doc = Document("A Document", "blah")
  >>> [adapter.validate()
  ...  for adapter in subscribers([doc], IValidate)
  ...  if adapter.validate()]
  ['too short']

unregisterAdapter
~~~~~~~~~~~~~~~~~

This function is used to unregister an adapter factory.  A boolean is
returned indicating whether the registry was changed.  If the given
component is None and there is no component registered, or if the
given component is not None and is not registered, then the function
returns False, otherwise it returns True.

- Модуль: ``zope.component - IComponentRegistry``

- Спецификация: `unregisterAdapter(factory=None, required=None,
  provided=None, name=u'')`

- Смотри также: `registerAdapter`_

Пример::

  >>> from zope.interface import Attribute
  >>> from zope.interface import Interface

  >>> class IDesk(Interface):
  ...     """A frontdesk will register object's details"""
  ...
  ...     def register():
  ...         """Register object's details"""
  ...

  >>> from zope.interface import implements
  >>> from zope.component import adapts

  >>> class FrontDeskNG(object):
  ...
  ...     implements(IDesk)
  ...     adapts(IGuest)
  ...
  ...     def __init__(self, guest):
  ...         self.guest = guest
  ...
  ...     def register(self):
  ...         next_id = get_next_id()
  ...         bookings_db[next_id] = {
  ...         'name': guest.name,
  ...         'place': guest.place,
  ...         'phone': guest.phone
  ...         }

  >>> class Guest(object):
  ...
  ...     implements(IGuest)
  ...
  ...     def __init__(self, name, place):
  ...         self.name = name
  ...         self.place = place

  >>> jack = Guest("Jack", "Bangalore")
  >>> jack_frontdesk = FrontDeskNG(jack)

  >>> IDesk.providedBy(jack_frontdesk)
  True

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()
  >>> gsm.registerAdapter(FrontDeskNG,
  ...                     (IGuest,), IDesk, 'ng6')

  You can test it like this:

  >>> queryAdapter(jack, IDesk, 'ng6') #doctest: +ELLIPSIS
  <FrontDeskNG object at ...>

  Now unregister:

  >>> gsm.unregisterAdapter(FrontDeskNG, name='ng6')
  True

  After unregistration:

  >>> print queryAdapter(jack, IDesk, 'ng6')
  None

unregisterHandler
~~~~~~~~~~~~~~~~~

This function is used for unregistering a handler.  A handler is a
subscriber that doesn't compute an adapter but performs some function
when called.  A boolean is returned indicating whether the registry
was changed.

- Модуль: ``zope.component - IComponentRegistry``

- Спецификация: `unregisterHandler(handler=None, required=None,
  name=u'')`

- Смотри также: `registerHandler`_

Пример::

  >>> from zope.interface import Interface
  >>> from zope.interface import Attribute
  >>> from zope.interface import implements

  >>> class IDocument(Interface):
  ...
  ...     summary = Attribute("Document summary")
  ...     body = Attribute("Document text")

  >>> class Document(object):
  ...
  ...     implements(IDocument)
  ...     def __init__(self, summary, body):
  ...         self.summary, self.body = summary, body

  >>> doc = Document("A\nDocument", "blah")

  >>> class IDocumentAccessed(Interface):
  ...     doc = Attribute("The document that was accessed")

  >>> class DocumentAccessed(object):
  ...     implements(IDocumentAccessed)
  ...
  ...     def __init__(self, doc):
  ...         self.doc = doc
  ...         self.doc.count = 0

  >>> from zope.component import adapter

  >>> @adapter(IDocumentAccessed)
  ... def documentAccessed(event):
  ...     event.doc.count = event.doc.count + 1

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> gsm.registerHandler(documentAccessed)

  >>> from zope.component import handle

  >>> handle(DocumentAccessed(doc))
  >>> doc.count
  1

  Now unregister:

  >>> gsm.unregisterHandler(documentAccessed)
  True

  After unregistration:

  >>> handle(DocumentAccessed(doc))
  >>> doc.count
  0

unregisterSubscriptionAdapter
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This function is used to unregister a subscriber factory.  A boolean
is returned indicating whether the registry was changed.  If the given
component is None and there is no component registered, or if the
given component is not None and is not registered, then the function
returns False, otherwise it returns True.

- Модуль: ``zope.component - IComponentRegistry``

- Спецификация: `unregisterSubscriptionAdapter(factory=None,
  required=None, provides=None, name=u'')`

- Смотри также: `registerSubscriptionAdapter`_

Пример::

  >>> from zope.interface import Interface
  >>> from zope.interface import Attribute
  >>> from zope.interface import implements

  >>> class IValidate(Interface):
  ...     def validate(ob):
  ...         """Determine whether the object is valid
  ...
  ...         Return a string describing a validation problem.
  ...         An empty string is returned to indicate that the
  ...         object is valid.
  ...         """

  >>> class IDocument(Interface):
  ...     summary = Attribute("Document summary")
  ...     body = Attribute("Document text")

  >>> class Document(object):
  ...     implements(IDocument)
  ...     def __init__(self, summary, body):
  ...         self.summary, self.body = summary, body

  >>> from zope.component import adapts

  >>> class AdequateLength(object):
  ...
  ...     adapts(IDocument)
  ...     implements(IValidate)
  ...
  ...     def __init__(self, doc):
  ...         self.doc = doc
  ...
  ...     def validate(self):
  ...         if len(self.doc.body) < 1000:
  ...             return 'too short'
  ...         else:
  ...             return ''

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> gsm.registerSubscriptionAdapter(AdequateLength)

  >>> from zope.component import subscribers

  >>> doc = Document("A\nDocument", "blah")
  >>> [adapter.validate()
  ...  for adapter in subscribers([doc], IValidate)
  ...  if adapter.validate()]
  ['too short']

  Теперь отменяем регистрацию:

  >>> gsm.unregisterSubscriptionAdapter(AdequateLength)
  True

  После отмены регистрации:

  >>> [adapter.validate()
  ...  for adapter in subscribers([doc], IValidate)
  ...  if adapter.validate()]
  []

unregisterUtility
~~~~~~~~~~~~~~~~~

[Переписать на русский!!!]Эта функция используется для отмены регичтрации утилиты.  Функция
возвращает логическое значение, в зависимости от того, произошло
изменение реестра или нет.  Если значение параметра `component` - None и
ранее не было зарегистрировано никаких компонент, или же если
сзначение этого параметна не None и такой компоненты ранее не было
зарегистрировано, то функция возвращает False. В других случаях
функция возвращает True.

- Расположение: ``zope.component - IComponentRegistry``

- Сигнатура: `unregisterUtility(component=None, provided=None,
  name=u'')`

- Смотри также: `registerUtility`_

Пример::

  >>> from zope.interface import Interface
  >>> from zope.interface import implements

  >>> class IGreeter(Interface):
  ...     def greet(name):
  ...         "say hello"

  >>> class Greeter(object):
  ...
  ...     implements(IGreeter)
  ...
  ...     def greet(self, name):
  ...         return "Hello " + name

  >>> from zope.component import getGlobalSiteManager
  >>> gsm = getGlobalSiteManager()

  >>> greet = Greeter()
  >>> gsm.registerUtility(greet)

  >>> queryUtility(IGreeter).greet('Jack')
  'Hello Jack'

  Теперь отменяем регистрацию:

  >>> gsm.unregisterUtility(greet)
  True

  После отмены регистрации:

  >>> print queryUtility(IGreeter)
  None

..

   Local Variables:
   eval: (rst-mode)
   End:
