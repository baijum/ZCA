<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p><span> Министерство образования и науки Российской федерации<br />
Иркутский национальный исследовательский технический университет<br />
Учреждение Российской академии наук<br />
&lt;&lt;Институт динамики систем и теории управления им. В. М. Матросова<br />
Сибирского отделения РАН&gt;&gt; </span> to<br />
<strong>Иркутск 2016</strong></p>
<p>УДК 681.3.06 (075.8)<br />
ББК 32.973-01я73<br />
Ч-48</p>
<p>Рекомендовано к изданию редакционно-издательским советом ИРНИТУ<br />
</p>
<p><strong>Рецензенты:</strong><br />
зав. лаб. 4.1. ИДСТУ СО РАН, канд. техн. наук <span><em>А. Е. Хмельнов</em></span>,<br />
ст. преп. каф. ИС. ИМЭИ ИГУ, канд. физ.-мат. наук <span><em>И. А. Казаков</em></span></p>
<p><br />
Ч-48</p>
<p><span><strong>Черкашин Е. А.</strong></span></p>
<p>Компонентное программирование в Python: учеб. пособие/ Е. А. Черкашин, М. Байджу – Иркутск: Изд&quot;=во ИРНИТУ, 2016. –  c.</p>
<p><span><strong><span>ISBN 978-5-9624-ХХХ-Х</span></strong></span></p>
<p>В пособии представлены материалы лекций и задания лабораторных работ по курсу &lt;&lt;Сетевые операционные системы&gt;&gt; Института кибернетики им. Е. И. Попова Иркутского государственного технического университета, тема «Компонентное проектирование распределенных систем», направление подготовки магистра – 09.04.01. Задача курса состоит в развитии навыков проектирования сложных программных комплексов на основе формального описания его компонент, их регистрации в репозитории компонент, конфигурировании программной системы.</p>
<p>Предполагаемая аудитория пособия: студенты, магистранты, аспиранты и молодые специалисты инженерных специальностей, связанных с программированием распределенных систем, серверов, сетей распределенной обработки информации, прикладных пакетов. Материал пособия адаптируем к курсам &lt;&lt;Технологии программирования&gt;&gt;, &lt;&lt;Открытые системы&gt;&gt;.</p>
<p>УДК 681.3.06 (075.8)<br />
ББК 32.973-01я73</p>
<p><span>ISBN 978-5-9624-ХХХХ-Х</span></p>
<ul>
<li><p>Черкашин Е. А., Байджу М., 2016</p></li>
<li><p>ФГБОУ ВПО ИРНИТУ, 2016</p></li>
<li><p>ФГБУН ИДСТУ СО РАН, 2016</p></li>
</ul>
<p>[contents]</p>
<section id="введение-id1" class="level1">
<h1><span class="header-section-number">1</span> Введение [id1]</h1>
<p>Разработка больших программных систем практически всегда является сложным и трудоемким занятием, где объектно“=ориентированный подход к анализу, проектированию и реализации (программированию) достаточно хорошо себя зарекомендовал. Проектирование и разработка программного обеспечения, использующая компонентный подход, становятся все более и более популярным методом проектирования. Компонентный подход и unit”=тестирование позволяет достаточно просто разрабатывать и поддерживать программные системы. Существует много различных программных инфраструктур и инструментариев разработчика (framework), реализующих компонентное проектирование для разных языков программирования и их средах, некоторые даже не зависят от какой&quot;=либо конкретной среды разработки. Примерами выступают COM, разработанный Microsoft, и XPCOM - Mozilla.</p>
<p><strong>Компонентная архитектура Zope (Zope Component Architecture, ZCA)</strong> – это одна из таких инфраструктур, разработанная для среды программирования Python, реализующая компонентный подход к проектированию и программированию. Он позволяет проектировать большие программные системы в среде программирования Python. И делает это совсем не плохо. Компонентная архитектура ZCA не требует для своего использования сервера приложений Zope, ZCA может использоваться в разработке любого Python&quot;=приложения. Справедливо было бы назвать ZCA <span><em>компонентной архитектурой Python</em></span> (Python Component Architecture).</p>
<p>ZCA позволяет использовать объекты Python эффективно. <span><em>Компоненты</em></span> – это объекты, которые легко использовать повторно, а к интерфейсам этих компонент можно получить полный доступ во время исполнения программы (introspection). <span><em>Интерфейс</em></span> – это объект, который описывает как следует взаимодействовать с конкретной компонентой. Другими словами, компонента <span><em>обслуживает сервисы</em></span> (provides)<span> </span>, определенные в интерфейсе. Компонента <span><em>реализуется</em></span> (implemented) в виде класса (class) или другого исполняемого объекта (callable object). И не важно, как реализована эта компонента, а вот что важно – это то, что она соответствует <span><em>требованиям</em></span>, определенным в интерфейсе (interface contract). При помощи ZCA сложность системы распределяется между множеством кооперирующихся компонент. Механизм такой кооперации обеспечивается двумя базовыми разновидностями компонент в ZCA: <span><em>адаптером</em></span> (adapter) и <span><em>утилитой</em></span> (utility).</p>
<blockquote>

</blockquote>
<p>ZCA распределен между тремя базовыми пакетами:</p>
<blockquote>
<ul>
<li><p><code>zope.interface</code>, используемый для определения (задания) интерфейсов компонент.</p></li>
<li><p><code>zope.event</code>, поддерживающий базовый механизм порождения и обработки событий.</p></li>
<li><p><code>zope.component</code>, обеспечивающий порождение и регистрацию компонент, а также их предоставление приложению по запросу.</p></li>
</ul>
</blockquote>
<p>Обращаю внимание, что ZCA сам по себе не является компонентой и не состоит из них, ZCA скорее механизм и библиотека для создания, регистрации и обеспечения доступа из программного кода приложения к зарегистрированным компонентам. В продолжение к предыдущему замечанию, <span><em>Адаптер</em></span> – это, как правило, обычный класс Python или фабрика классов (factory), а <span><em>утилита</em></span> – это обычный запускаемый объект в среде исполнения Python.</p>
<p>Среда ZCA разрабатывается как одна из задач проекта Zope 3. Как сказано выше ZCA является чисто питоновским фреймворком, и может использоваться в любых приложениях Python. В настоящее время ZCA активно используется в проектах Zope 3, Zope 2 и Grok. Существуют и другие приложения, в т. ч. и неинтернет&quot;=приложения, использующие ZCA<span> </span>.</p>
<section id="краткая-история-проекта-id5" class="level2">
<h2><span class="header-section-number">1.1</span> Краткая история проекта [id5]</h2>
<p>Проект ZCA начался в 2001 году и являлся частью проекта Zope 3. Причиной появления Zope 3 послужил анализ опыта, полученного при разработке комплексных программных систем на основе Zope 2. Джим Фултон (Jim Fulton) стал лидером проекта. Сообщество разработчиков, внесших свой вклад в дизайн и реализацию ZCA, возглавляется известными инженерами: Стефаном Рихтером (Stephan Richter), Филиппом фон Вайтершаусеном (Philipp von Weitershausen), Гвидо ван Россумом (Guido van Rossum), известным также как <em>Python BDFL</em>, Тресом Сивером (Tres Seaver), Филиппом Дж Эби (Phillip J Eby) и Мартином Фаассеном (and Martijn Faassen).</p>
<p>В начале проекта Zope 3 в ZCA существовали дополнительные компоненты – <span><em>сервисы</em></span> (services) и <span><em>представления</em></span> (views), но в процессе разработки оказалось, что <span><em>утилиты</em></span> заменяют полностью сервисы, а <span><em>мультиадаптеры</em></span> – представления. В настоящее время ZCA включает в себя небольшой набор базовых компонент: <span><em>утилиты</em></span>, <span><em>адаптеры</em></span>, <span><em>подписчики</em></span> (subscribers) и <span><em>обработчики</em></span> (handlers). На самом деле <span><em>подписчики</em></span> и <span><em>обработчики</em></span> – это два особых вида адаптеров.</p>
<p>В процессе подготовки версии Zope 3.2 Джим Фултон предложил значительно упростить среду компонентного программирования ZCA<span> </span>. В результате этого появился новый общий интерфейс <span><em>IComponentRegistry</em></span>, позволяющий регистрировать как локальные так и глобальные компоненты.</p>
<p>В результате от пакета <code>zope.component</code> перестал зависеть достаточно длинный список других пакетов, при этом оставшиеся зависимости не относились напрямую к разработке приложений Zope 3. На конференции PyCon 2007 Джим Фултон предложил включить в пакет <span><em>setuptools</em></span> функцию <span><em>extras_require</em></span>, чтобы усилить уровень изолированности базового набора функций ZCA от вспомогательных функций<span> </span>.</p>
<p>В марте 2009, Трес Сивер окончательно устранил зависимости пакета от <code>zope.deferredimport</code> и <code>zope.proxy</code>.</p>
<p>Теперь проект ZCA является независимым со своим собственным планом выпусков и репозиторием Subversion. Проект как и прежде является составляющей частью среды разработки интернет&quot;=приложений Zope<span> </span>. При этом ошибки и недочеты, выявляемые в ZCA, все еще публикуются на сайте системы отслеживания ошибок проекта Zope 3<span> </span>. Кроме того, основной список рассылки <span><em>zope&quot;=dev</em></span> все еще используется для информационного обмена разработчиками ZCA<span> </span>. Существует также список рассылки, предназначенный для пользователей Zope 3, <span><em>zope3&quot;=users</em></span>, в котором можно получить ответы на вопросы о ZCA<span> </span>.</p>
</section>
<section id="установка-id12" class="level2">
<h2><span class="header-section-number">1.2</span> Установка [id12]</h2>
<p>Пакеты <code>zope.component</code>, <code>zope.interface</code> и <code>zope.event</code> являются ядром Компонентной архитектуры Zope. Они содержат технические средства для определения, регистрации и поиска компонент. Пакет <code>zope.component</code> и пакеты, зависящие от него, доступны в формате egg на сайте Python Package Index (PyPI)<span> </span>.</p>
<p>Проще всего устанавливать <code>zope.component</code> и его зависимые пакеты при помощи программы <span><em>easy_install</em></span><span> </span></p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="ex">easy_install</span> zope.component</code></pre></div>
<p>Программ загружает <code>zope.component</code>, его зависимые пакеты с сайта PyPI и устанавливает все как библиотеки интерпретатора Python.</p>
<p>С другой стороны, можно загрузить <code>zope.component</code> и зависящие от него пакеты с сайта PyPI и, затем, самостоятельно установить их. Установку пакетов следует производить в порядке, описанном ниже. В операционной системе Windows необходимо загрузить двоичные сборки следующих пакетов.</p>
<blockquote>
<p><span>.</span> <span> </span></p>
<p><code>zope.interface</code>;</p>
<p><code>zope.event</code>;</p>
<p><code>zope.component</code>.</p>
</blockquote>
<p>Для установки загруженных пакетов можно, как и раньше, использовать команду <code>easy_install</code>, при этом передавая в качестве параметра устанавливаемые пакеты, аналогично двоичным egg&quot;=пакетам. Команда позволяет все пакеты указывать одновременно в одной командной строке.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="ex">easy_install</span> /path/to/zope.interface-3.x.x.tar.gz
$ <span class="ex">easy_install</span> /path/to/zope.event-3.x.x.tar.gz
$ <span class="ex">easy_install</span> /path/to/zope.component-3.x.x.tar.gz</code></pre></div>
<p>Кроме того, все пакеты можно разархивировать и установить по одному, например:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="fu">tar</span> zxvf /path/to/zope.interface-3.x.x.tar.gz
$ <span class="bu">cd</span> zope.interface-3.x.x
$ <span class="ex">python</span> setup.py build
$ <span class="ex">python</span> setup.py install</code></pre></div>
<p>В результате исполнения этих команд ZCA устанавливается как общесистемная библиотека Python в директорий <code>site&quot;=packages</code>, что, иногда, создает некоторые проблемы. Джим Фултон в списке рассылки Zope 3 не рекомендовал устанавливать пакеты в общесистемном директории Python<span> </span>. Их рекомендуется устанавливать в виртуальное окружение, создаваемое помощи программы <code>virtualenv</code>, или пакета <code>zc.buildout</code>. Такой подход предоставляет возможности для проведения экспериментов с пакетами Python. Кроме того, в виртуальном окружении удобно развертывать уже готовые приложения.</p>
</section>
<section id="подготовка-виртуального-окружения-id16" class="level2">
<h2><span class="header-section-number">1.3</span> Подготовка виртуального окружения [id16]</h2>
<p>Существует множество популярных подходов к настройке изолированного виртуального окружения для среды программирования Python, удобного для разработки приложений. Наиболее популярные – это пакет <code>virtualenv</code>, разработанный Яном Бикингом (Ian Biking) и пакет <code>zc.buildout</code>, разработанный Джимом Фултоном. Оба этих пакета можно использовать и одновременно.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">virtualenv</span></code></pre></div>
<p>Пакет <code>virtualenv</code> устанавливается при помощи команды <code>easy_install</code>:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="ex">easy_install</span> virtualenv</code></pre></div>
<p>Затем создается новое окружение:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="ex">virtualenv</span> --no-site-packages myve</code></pre></div>
<p>Команда <code>easy_install</code> создает новое окружение в директории <code>myve</code>. Теперь в этот директорий можно установить <code>zope.component</code> и пакеты, которые от него зависят. Команду необходимо запускать с использованием префикса <code>myve/bin</code></p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="bu">cd</span> myve
$ <span class="ex">./bin/easy_install</span> zope.component</code></pre></div>
<p>Теперь можно попробовать импортировать пакеты <code>zope.interface</code> и <code>zope.component</code> из командной строки интерпретатора <code>python</code>, который находится в директории <code>myve/bin</code>:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="ex">./bin/python</span></code></pre></div>
<p>После запуска Python выведет на экран его стандартное приглашение для ввода команд и выражений. В командной строке будем выполнять программный код, приводимый в книге.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">zc.buildout</span></code></pre></div>
<p>При помощи пакета <code>zc.buildout</code> и <span><em>рецепта</em></span> (recipe) <code>zc.recipe.egg</code> создаются специализированные версии интерпретатора Python с встроенными egg&quot;=пакетами. Для этого необходимо установить пакет <code>zc.buildout</code> при помощи команды <code>easy_install</code>, имеет смысл установить этот пакет также внутри виртуального окружения.</p>
<p>Чтобы создать новое buildout“=окружение для проведения экспериментов с egg”=пакетами Python, сначала создайте для него новый директорий, и, затем, создайте в нем так называемое buildout&quot;=окружение при помощи команды <code>buildout init</code>:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="fu">mkdir</span> mybuildout
$ <span class="bu">cd</span> mybuildout
$ <span class="ex">buildout</span> init</code></pre></div>
<p>Теперь директорий <code>mybuildout</code> – новое buildout&quot;=окружение. Настройки окружения по умолчанию хранятся в файле <span><em>buildout.cfg</em></span>. Сначала в нем содержится следующий текст:</p>
<div class="sourceCode"><pre class="sourceCode ini"><code class="sourceCode ini"><span class="kw">[buildout]</span>
<span class="dt">chapters </span><span class="ot">=</span></code></pre></div>
<p>Надо внести в настройки следующие изменения:</p>
<div class="sourceCode"><pre class="sourceCode ini"><code class="sourceCode ini"><span class="kw">[buildout]</span>
<span class="dt">chapters </span><span class="ot">=</span><span class="st"> py</span>

<span class="kw">[py]</span>
<span class="dt">recipe </span><span class="ot">=</span><span class="st"> zc.recipe.egg</span>
<span class="dt">interpreter </span><span class="ot">=</span><span class="st"> python</span>
<span class="dt">eggs </span><span class="ot">=</span><span class="st"> zope.component</span></code></pre></div>
<p>Запуск команды <code>buildout</code> из директория <code>mybuildout/bin</code> (без аргументов) создаст копию интерпретатора Python в директории <code>mybuildout/bin</code>:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="ex">./bin/buildout</span>
$ <span class="ex">./bin/python</span></code></pre></div>
<p>Последняя команда выведет на экран приглашение Python, в котором будем запускать приводимый далее в книге программный код.</p>
</section>
</section>
<section id="пример-задачи-id17" class="level1">
<h1><span class="header-section-number">2</span> Пример задачи [id17]</h1>
<p>Рассмотрим приложение, предназначенное для регистрации постояльцев в гостинице. В среде Python его можно реализовать множеством способов. Сначала кратко рассмотрим процедурный подход, затем перейдем к объектно“=ориентированному программированию. После анализа результатов дизайна и реализации задачи при помощи объектно”=ориентированного подхода, рассмотрим как данная задача решается при помощи классических шаблонов проектирования (паттернов проектирования, design patterns) <span><em>адаптер</em></span> и <span><em>интерфейс</em></span>. Таким образом у вас появится начальное представление о возможностях Компонентой архитектуры Zope.</p>
<section id="процедурный-подход-id19" class="level2">
<h2><span class="header-section-number">2.1</span> Процедурный подход [id19]</h2>
<p>Модуль хранения данных – очень важный момент в разработке приложений. В рассматриваемом примере будем использовать словарь (dictionary) языка Python в качестве такой системы хранения. Каждой записи соответствует сгенерированный уникальный ключ (ID). Ключ ассоциируется со значением, которое тоже будет словарем и будет содержать данные о бронировании комнаты в гостинице.</p>
<div class="sourceCode"><pre class="sourceCode ex"><code class="sourceCode elixir">    bookings_db <span class="op">=</span> {} <span class="co">#key - уникальный идентификатор (ID), value - данные брони</span></code></pre></div>
<p>В реализации системы нужна, как минимум, функция, которой передаются данные о бронировании, и функция, которая генерирует уникальное значение ID ключа для ассоциации с данными брони.</p>
<p>Сгенерировать значение ключа можно следующим образом:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">def</span> get_next_id():
        db_keys <span class="op">=</span> bookings_db.keys()
        <span class="cf">if</span> db_keys <span class="op">==</span> []:
            next_id <span class="op">=</span> <span class="dv">1</span>
        <span class="cf">else</span>:
            next_id <span class="op">=</span> <span class="bu">max</span>(db_keys) <span class="op">+</span> <span class="dv">1</span>
        <span class="cf">return</span> next_id</code></pre></div>
<p>Как видно из программы, реализация функции <span><em>get_next_id</em></span> достаточно проста. Функция получает из словаря список ключей. Если список пуст, то это значит, что произошло первое бронирование комнаты в гостинице, функция возвращает <span><em>1</em></span>. Если список не пуст, то добавить <span><em>1</em></span> к максимальному значению ключей и вернуть полученное значение.</p>
<p>Теперь созданную выше функцию встроим в программный код, создающий записи в словаре bookings_db:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">def</span> book_room(name, place):
        next_id <span class="op">=</span> get_next_id()
        bookings_db[next_id] <span class="op">=</span> {
        <span class="st">&#39;name&#39;</span>: name,
        <span class="st">&#39;room&#39;</span>: place
        }</code></pre></div>
<p>В хранилище необходимо учесть, что может потребоваться сохранять и другие данные, такие как</p>
<ul>
<li><p>номер телефонов,</p></li>
<li><p>требования к бронированию,</p></li>
<li><p>способ платежа клиентом,</p></li>
<li><p>...</p></li>
</ul>
<p>Необходимо реализовать следующие функции:</p>
<ul>
<li><p>отмена бронирования,</p></li>
<li><p>уточнение бронирования,</p></li>
<li><p>оплата проживания,</p></li>
<li><p>постоянное хранение данных и доступ к ним,</p></li>
<li><p>обеспечение защиты информации в хранилище,</p></li>
<li><p>...</p></li>
</ul>
<p>Процедурная реализация данного примера требует создания большого числа функций, обменивающихся информацией друг с другом. Изменения требований к дизайну и реализации, добавление новых функций, создает условия к усложнению процесса поддержки программного кода. Кроме того, становится сложнее выявлять и исправлять ошибки.</p>
<p>На этом закончим обсуждение процедурного подхода. Обеспечивать постоянное хранение данных, гибкость дизайна и возможность тестирования программного кода, как правило, проще, используя объекты.</p>
</section>
<section id="объектно-ориентированный-подход-id20" class="level2">
<h2><span class="header-section-number">2.2</span> Объектно-ориентированный подход [id20]</h2>
<p>DUadmonitionsystem-messageDUadmonitionsystem-message</p>
<p>а) “о создании объекта, обрабатывающего регистрацию” или же б) “о создании класса, обрабатывающего регистрацию”?</p>
<p>В объектно&quot;=ориентированном подходе появляются <span><em>классы</em></span>, которые служат для инкапсуляции данных и программного кода, обрабатывающего эти данные в рамках одного абстрактного типа данных.</p>
<p>Основным классом в рассматриваемом примере является <code>FrontDesk</code>. Класс <code>FrontDesk</code>, а также другие классы, с которыми он взаимодействует, обеспечивают моделирование бизнес“=процессов отеля и соответствующую обработку данных. При помощи <span><em>экземпляров</em></span> класса <code>FrontDesk</code> моделируется конкретный бизнес”=процесс в конкретном отеле.</p>
<p>Как правило, консолидация программного кода и данных в объектах приводит в конечном счете к такому дизайну программной системы, который является более понятным, а программный кода проще тестировать и изменять.</p>
<p>Рассмотрим детали реализации класса <code>FrontDesk</code>:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">class</span> FrontDesk(<span class="bu">object</span>):

        <span class="kw">def</span> book_room(<span class="va">self</span>, name, place):
            next_id <span class="op">=</span> get_next_id()
            bookings_db[next_id] <span class="op">=</span> {
            <span class="st">&#39;name&#39;</span>: name,
            <span class="st">&#39;place&#39;</span>: place
            }</code></pre></div>
<p>Далее, задачей объекта <span><em>frontdesk</em></span> (экземпляра класса <span><em>FrontDesk</em></span>) является обработка заявок на бронирование. Его используют следующим образом:</p>
<div class="sourceCode"><pre class="sourceCode ex"><code class="sourceCode elixir">    frontdesk <span class="op">=</span> <span class="cn">FrontDesk</span>()
    frontdesk<span class="op">.</span>book_room(<span class="st">&quot;Jack&quot;</span>, <span class="st">&quot;Bangalore&quot;</span>)</code></pre></div>
<p>В реальности в каждый проект необходимо вносить изменения. Например, если руководство отеля решило, что каждый клиент должен при бронировании сообщать свой номер телефона, то программый код класса необходимо изменить.</p>
<p>Требование руководства можно удовлетворить добавив еще один аргумет к методу <span><em>book_room</em></span>, кроме того, новое ключевое значение добавляется к словарю:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">class</span> FrontDesk(<span class="bu">object</span>):

        <span class="kw">def</span> book_room(<span class="va">self</span>, name, place, phone):
            next_id <span class="op">=</span> get_next_id()
            bookings_db[next_id] <span class="op">=</span> {
            <span class="st">&#39;name&#39;</span>: name,
            <span class="st">&#39;place&#39;</span>: place,
            <span class="st">&#39;phone&#39;</span>: phone
            }</code></pre></div>
<p>В результате изменилась и структура базы данных.</p>
<p>Теперь появилась необходимость во всей программе скорректировать вызов метода <span><em>book_room</em></span> – добавить новый аргумент <span><em>phone</em></span>. Если же инкапсулировать данные о постояльце в объекте <span><em>guest</em></span>, и передавать этот объект в качестве единственного аргумента функции регистрации, то указанные выше изменения будут минимизированы или вовсе не нужны. Изменения в объекте <span><em>guest</em></span>, например, добавление поля <span><em>phone</em></span> не вызовет необходимости в тотальной корректировки кода.</p>
<p>В результате получилось следующая реализация функции регистрации:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">class</span> FrontDesk(<span class="bu">object</span>):

        <span class="kw">def</span> book_room(<span class="va">self</span>, guest):
            next_id <span class="op">=</span> get_next_id()
            bookings_db[next_id] <span class="op">=</span> {
            <span class="st">&#39;name&#39;</span>: guest.name,
            <span class="st">&#39;place&#39;</span>: guest.place,
            <span class="st">&#39;phone&#39;</span>: guest.phone
            }</code></pre></div>
<p>Не смотря на полученный результат, программный код все&quot;=таки придется корректировать, чтобы отразить изменяющиеся во времени требования заказчика. Этого избежать практически никогда невозможно. Задача разработчика состоит в том, чтобы создать такой дизайн программы, который не требовал бы значительных изменений программного кода при изменении требований. Это свойство дизайна называется <span><em>Способность к сопровождению</em></span> (maintainability). Чем меньше нужно вносить изменений тем выше способность к сопровождению.</p>
<p>DUadmonitionnoteDUadmonitionnote</p>
<p>Итак, добавление объекта <span><em>guest</em></span> сократило программный код, и, что более важно, упростило программную систему. Программный код теперь проще понять, реструктурировать и поддерживать.</p>
</section>
<section id="шаблон-проектирования-адаптер-id22" class="level2">
<h2><span class="header-section-number">2.3</span> Шаблон проектирования <span><em>Адаптер</em></span> [id22]</h2>
<p>В реальных приложениях объект <span><em>frontdesk</em></span> должен выполнять еще и другие функции, например, отмену и изменения бронирования. В текущей реализации необходимо передавать объект <span><em>guest</em></span> объекту <span><em>frontdesk</em></span> всякий раз при запуске методов <span><em>cancel_booking</em></span> и <span><em>update_booking</em></span>.</p>
<p>Можно избавиться от этого ограничения, если передать объект <span><em>guest</em></span> в конструктор FrontDesk.__init__(), сделав объект <span><em>guest</em></span> атрибутом нового экземпляра <span><em>FrontDesk</em></span>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">class</span> FrontDeskNG(<span class="bu">object</span>):

        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, guest):
            <span class="va">self</span>.guest <span class="op">=</span> guest

        <span class="kw">def</span> book_room(<span class="va">self</span>):
            guest <span class="op">=</span> <span class="va">self</span>.guest
            next_id <span class="op">=</span> get_next_id()
            bookings_db[next_id] <span class="op">=</span> {
            <span class="st">&#39;name&#39;</span>: guest.name,
            <span class="st">&#39;place&#39;</span>: guest.place,
            <span class="st">&#39;phone&#39;</span>: guest.phone
            }

        <span class="kw">def</span> cancel_booking(<span class="va">self</span>):
            guest <span class="op">=</span> <span class="va">self</span>.guest
            <span class="co"># далее следует реализация отмены бронирования</span>

        <span class="kw">def</span> update_booking(<span class="va">self</span>):
            guest <span class="op">=</span> <span class="va">self</span>.guest
            <span class="co"># далее следует реализация изменения бронирования</span></code></pre></div>
<p>Решение, к которому мы пришли, – это всем известный шаблон проектирования <em>Адаптер</em> (<em>Adapter</em>). Большинство адаптеров <em>содержат</em> в себе <em>адаптируемый объект</em> (<em>adaptee</em>):</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">class</span> Adapter(<span class="bu">object</span>):

        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, adaptee):
            <span class="va">self</span>.adaptee <span class="op">=</span> adaptee</code></pre></div>
<p>Этот шаблон чрезвычайно полезен в процессе реализации программного кода в следствии изменения</p>
<ul>
<li><p>требований заказчика к набору реализуемых функций программы;</p></li>
<li><p>требований к системе хранения данных (ZODB, RDBM, XML ...);</p></li>
<li><p>требований к выводу результата (HTML, PDF, plain text ...);</p></li>
<li><p>способа представления исходного текста (ReST, Markdown, Textile ...).</p></li>
</ul>
<p>В ZCA используются адаптеры, а также <em>регистраторы компонент</em>, которые позволяют настраивать реализацию блоков программного кода на основе <em>конфигураций</em> (<em>configuration</em>) компонентов.</p>
<p>Далее, в разделе об адаптерах ZCA, будет продемонстрированы приемущества использования конфигурирования, в частности,</p>
<ul>
<li><p>возможность переключения между вариантами реализации;</p></li>
<li><p>возможность при необходимости добавлять новые реализации;</p></li>
<li><p>повышается степень использования повторного кода: как унаследованного, так и программного кода ZCA.</p></li>
</ul>
<p>Кроме того, использование конфигурирования позволяет создавать гибкий, масштабируемый программный код. Хотя, конечно, поддержка регистров компонент добавляет дополнительный уровень сложности приложения. Если же приложению в будущем не потребуются перечисленные возможности, то от ZCA будет мало пользы.</p>
<p>Теперь можно начать изучение Zope Component Architecture. Начнем с интерфейсов.</p>
</section>
</section>
<section id="интерфейсы-id23" class="level1">
<h1><span class="header-section-number">3</span> Интерфейсы [id23]</h1>
<p>В файле README.txt<span> </span> в path/to/zope/interface интерфейсы определяются следующим образом:</p>
<pre class="text"><code>Интерфейсы~-- это объекты, которые явным образом задают
(документируют) спецификацию внешнего поведения группы объектов.
Эти объекты, в свою очередь, `обслуживают` (provide) данные
интерфейсы.  Интерфейс задает спецификацию поведения при помощи

- Информативной документации в виде doc-строк питона;

- Определений атрибутов и их свойств;

- Инвариантов, т. е. условий, которые должны выполняться во всех
  объектах, обслуживающих данный интерфейс.</code></pre>
<p>В классической книге по инженерии программного обеспечения <span><em>Приемы объектно&quot;=ориентированного проектирования. Паттерны проектирования</em></span><span> </span> известной <span><em>Банды Четырех</em></span> дана следующая рекомендация: “Программируй, ориентируясь на интерфейс, а не на реализацию”. Формальная спецификация интерфейса формирует понимание системы в целом. Кроме того, интерфейсы позволяют использовать все преимущества, предоставляемые ZCA.</p>
<p>Интерфейс определяет (формально задает) все характеристики, поведение и предоставляемые возможности объекта. Интерфейсы описывают <em>что</em> объект может делать, но чтобы узнать <em>как</em> он это делает необходимо изучать его реализации.</p>
<p>Интерфейсам соответствуют синонимы <span><em>контракт</em></span> и <span><em>эскиз</em></span> (<span><em>чертеж</em></span>), которые задают правовые и архитектурные положения набора спецификаций.</p>
<p>В некоторых современных системах программирования, таких как Java, C#, VB.NET и т. п., интерфейсы являются синтаксическими элементами языка. В языке Python нет таких языковых конструкций, поэтому интерфейсы в ZCA реализованы при помощи специальных метаклассов. Интерфейс задается при помощи наследования этих метаклассов.</p>
<p>Рассмотри пример в классическом стиле <em>hello world</em>:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">class</span> Host(<span class="bu">object</span>):

        <span class="kw">def</span> goodmorning(<span class="va">self</span>, name):
            <span class="co">&quot;&quot;&quot;Пожелаем доброго утра постояльцам&quot;&quot;&quot;</span>

            <span class="cf">return</span> <span class="st">&quot;Доброе утро, </span><span class="sc">%s</span><span class="st">!&quot;</span> <span class="op">%</span> name</code></pre></div>
<p>В классе <span><em>Host</em></span> определен метод <span><em>goodmorning</em></span>. Если у объекта (экземпляра данного класса) вызвать метод <span><em>goodmorning</em></span> на экран выведется сообщение <span><em>Доброе утро, …!</em></span></p>
<div class="sourceCode"><pre class="sourceCode ex"><code class="sourceCode elixir">    host <span class="op">=</span> <span class="cn">Host</span>()
    host<span class="op">.</span>goodmorning(<span class="vs">&#39;Jack&#39;</span>)
<span class="vs">&#39;Доброе утро, Jack!&#39;</span></code></pre></div>
<p>Здесь, <code>host</code> – это объект, который является частью исполняющегося приложения. Чтобы увидеть его детали реализации, необходимо получить доступ к классу <code>Host</code> либо через исходный код, либо при помощи инструментов документирования API<span> </span> .</p>
<p>Самое время начать использовать интерфейсы ZCA. Для класса <span><em>Host</em></span> интерфейс задается следующим образом:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Interface

    <span class="kw">class</span> IHost(Interface):

        <span class="kw">def</span> goodmorning(guest):
            <span class="co">&quot;&quot;&quot;Пожелаем доброго утра постояльцу&quot;&quot;&quot;</span></code></pre></div>
<p>Как видно из примера, интерфейс <span><em>IHost</em></span> унаследован от zope.interface.Interface. На самом деле конструкция выглядит так же как как питоновский класс, но он задает интерфейс в рамках среды ZCA. Приставка <code>I</code> – это полезное соглашение о форме и способе задания имен интерфейсов.</p>
<section id="декларация-интерфейса-id28" class="level2">
<h2><span class="header-section-number">3.1</span> Декларация интерфейса [id28]</h2>
<p>В предыдущем разделе представлен пример декларации интерфейса при помощи <code>zope.interface</code>. Здесь рассмотрим основные правила спецификаций интерфейсов более подробно.</p>
<p>Рассмотрим следующий пример определения интерфейса:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Interface
    <span class="im">from</span> zope.interface <span class="im">import</span> Attribute

    <span class="kw">class</span> IHost(Interface):
        <span class="co">&quot;&quot;&quot;Объект host&quot;&quot;&quot;</span>

        name <span class="op">=</span> Attribute(<span class="st">&quot;&quot;&quot;Имя владельца отеля&quot;&quot;&quot;</span>)

        <span class="kw">def</span> goodmorning(guest):
            <span class="co">&quot;&quot;&quot;Пожелаем доброго утра постояльцу&quot;&quot;&quot;</span></code></pre></div>
<p>Интерфейс <code>IHost</code> включает два атрибута <code>name</code> и <code>goodmorning</code>. Надо сказать, что в языке Python методы также являются атрибутами класса. Атрибут <code>name</code> декларируется при помощи класса <code>zope.interface.Attribute</code>. Сама декларация атрибута <code>name</code> в интерфейсе <code>IHost</code> не устанавливает ему какого&quot;=либо начального значения. Идея состоит в том, чтобы указать, что все реализации интерфейса <code>IHost</code> будут так или иначе использовать этот атрибут. Более того, данная декларация никоим образом не задает тип атрибута! В качестве первого аргумента <code>Attribute</code> передается строка, документирующая описываемый атрибут.</p>
<p>Второй атрибут, <code>goodmorning</code>, является методом и задается синтаксически как функция. Заметим, что параметр <span><em>self</em></span> в методах, определяющих интерфейс, не используется, так как <span><em>self</em></span>, ссылка на экземпляр класса, – это деталь реализации класса. Теперь, если программный модуль реализует интерфейс <code>IHost</code>, то в его программном коде будут использованы атрибут <code>name</code> и метод <code>goodmorning</code>. Методу <code>goodmorning</code> передается ровно один параметр.</p>
<p>Теперь изучим как объединять тройку <span><em>интерфейс&quot;=класс-объект</em></span>. Объект – это реально функционирующая сущность, объекты являются экземплярами классов. Именно интерфейс определяет структуру и внешнее поведение объекта, а классы – это лишь детали реализации. Именно по этой причине программный код реализуется, ориентируясь на спецификацию интерфейса.</p>
<p>В излагаемой концепции присутствуют еще две терминологические единицы. Первая – <span><em>обслуживать</em></span> (<span><em>provide</em></span>), вторая – <span><em>реализовать</em></span> (<span><em>implement</em></span>). Объекты обслуживают интерфейсы, а классы реализуют интерфейсы. Другими словами, объекты обслуживают интерфейсы, которые их классы реализуют. В приведенном выше примере объект <code>host</code> обслуживает интерфейс <code>IHost</code>, класс <code>Host</code> реализует интерфейс <code>IHost</code>. Один объект может обслуживать несколько интерфейсов, также как класс может реализовывать несколько интерфейсов. Кроме того, в дополнение к реализациям интерфейса в классе, объекты могут обслуживать интерфейсы в обход класса, т. е., непосредственно (directly).</p>
<p>DUadmonitionnoteDUadmonitionnote</p>
</section>
<section id="реализация-интерфейсов-id29" class="level2">
<h2><span class="header-section-number">3.2</span> Реализация интерфейсов [id29]</h2>
<p>Чтобы указать, что класс реализует некоторый интерфейс, используется функция <code>zope.interface.implements</code> в определении класса.</p>
<p>Рассмотрим пример, здесь класс <code>Host</code> реализует интерфейс <code>IHost</code>:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> implements

    <span class="kw">class</span> Host(<span class="bu">object</span>):

        implements(IHost)

        name <span class="op">=</span> <span class="st">u&#39;&#39;</span>

        <span class="kw">def</span> goodmorning(<span class="va">self</span>, guest):
            <span class="co">&quot;&quot;&quot;Пожелаем доброго утра постояльцу&quot;&quot;&quot;</span>

            <span class="cf">return</span> <span class="st">&quot;Доброе утро, </span><span class="sc">%s</span><span class="st">!&quot;</span> <span class="op">%</span> guest</code></pre></div>
<p>DUadmonitionnoteDUadmonitionnote</p>
<p>Так как класс <code>Host</code> реализует интерфейс <code>IHost</code>, то экземпляры класса <code>Host</code> обслуживают интерфейс <code>IHost</code>. В ZCA есть в ряд средств для интроспекции имеющихся деклараций интерфейсов. Кроме того, декларации могут быть сделаны вне определения класса: если не указывать <code>implements(IHost)</code> в приведенном выше примере, то после определения класса <code>Host</code> данную декларацию можно сделать следующим образом:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> classImplements
    classImplements(Host, IHost)</code></pre></div>
</section>
<section id="компонентный-подход-в-рассматриваемом-примере-id30" class="level2">
<h2><span class="header-section-number">3.3</span> Компонентный подход в рассматриваемом примере [id30]</h2>
<p>Итак, вернемся к нашему примеру приложения. Рассмотрим определение интерфейса объекта <span><em>стол регистрации</em></span> (frontdesk):</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Interface

    <span class="kw">class</span> IDesk(Interface):
        <span class="co">&quot;&quot;&quot;Стол регистрации, регистрирующий данные о постояльце&quot;&quot;&quot;</span>

        <span class="kw">def</span> register():
            <span class="co">&quot;&quot;&quot;Регистрируем данные постояльца&quot;&quot;&quot;</span></code></pre></div>
<p>В начале импортируется класс <code>Interface</code> из модуля <code>zope.interface</code>. Каждый подкласс класса <code>Interface</code> с точки зрения компонентной архитектуры Zope является определением интерфейса. Интерфейсы реализуются при помощи классов или любых других исполняемых (callable) объектов языка Python.</p>
<p>В примере задан интерфейс стола регистрации – <code>IDesk</code>. Строка, которая находится сразу под определением интерфейса (строка документирования), объясняет предназначение интерфейса. Определение метода в интерфейсе задает контрактное обязательство компоненты – в ней будет обслуживаться одноименный метод. В определении метода в интерфейсе не надо указывать первый аргумент <span><em>self</em></span>, так как интерфейс не предназначен для порождения экземпляров, т. е. эти декларации методов никогда не будут выполнены. Главная задача интерфейса – спецификация перечня атрибутов и методов, которые должны быть определены классе, вязавшем на себя обязательства реализовать данный интерфейс. Поэтому параметр <span><em>self</em></span> – это деталь реализации метода в классе, а в интерфейсе его указывать нет необходимости.</p>
<p>Кроме методов ZCA разрешает в интерфейсе декларировать обычные атрибуты:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Interface
    <span class="im">from</span> zope.interface <span class="im">import</span> Attribute

    <span class="kw">class</span> IGuest(Interface):

        name <span class="op">=</span> Attribute(<span class="st">&quot;Имя постояльца&quot;</span>)
        place <span class="op">=</span> Attribute(<span class="st">&quot;Место размещения постояльца&quot;</span>)</code></pre></div>
<p>Данный интерфейс сообщает, что соответствующие <span><em>guest</em></span>-объекты включают два атрибута. В ZCA в интерфейсах можно задавать одновременно и атрибуты и методы. Интерфейсы, как правило, реализуются при помощи классов и модулей, но можно и при помощи других объектов. Например, функция, которая динамически создает и возвращает компоненты, является таким нетипичным примером реализации интерфейса.</p>
<p>Итак, теперь вам известно, что такое интерфейс, как его задавать и использовать. В одном из следующих разделов рассмотрим использование интерфейсов в спецификации и реализации компонент&quot;=адаптеров.</p>
</section>
<section id="интерфейсы-маркеры-id31" class="level2">
<h2><span class="header-section-number">3.4</span> Интерфейсы-маркеры [id31]</h2>
<p>В некоторых случаях интерфейсы используются для указания, что некоторый объект принадлежит специальному типу или обладает некоторыми специфическими свойствами. Такие интерфейсы обычно не содержат определений атрибутов и методов и называется <span><em>маркерным интерфейсом</em></span> (<span><em>marker interface</em></span>).</p>
<p>Вот простой пример маркерного интерфейса:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Interface

    <span class="kw">class</span> ISpecialGuest(Interface):
        <span class="co">&quot;&quot;&quot;Особый гость&quot;&quot;&quot;</span></code></pre></div>
<p>Данный интерфейс указывает, что помеченный объект – это не просто <span><em>гость</em></span>, а <span><em>особый гость</em></span>.</p>
</section>
<section id="инварианты-id32" class="level2">
<h2><span class="header-section-number">3.5</span> Инварианты [id32]</h2>
<p>Иногда бывает необходимо явным образом указать, что атрибуты компоненты связаны друг с другом некоторым логическим правилом или ограничением. Механизм задания таких правил и ограничений в ZCA реализуется при помощи <span><em>инвариантов</em></span> (<span><em>invariants</em></span>). Инварианты задаются также в интерфейсах при помощи функций и объектов модуля <code>zope.interface.invariant</code>.</p>
<p>Рассмотрим простой пример, пусть существует объект <span><em>person</em></span> (человек). Его можно описать при помощи атрибутов <span><em>имя</em></span> (<span><em>name</em></span>), <span><em>email</em></span> и <span><em>телефон</em></span> (<span><em>phone</em></span>). Теперь можно задать ограничение, которое требует, чтобы email или телефон были обязательно заданы у каждого объекта person, однако требовать, чтобы оба этих атрибута были заданы, мы не будем.</p>
<p>Ограничение проверяет специальный исполняемый объект. В качестве такого объекта выступает исполняемый экземпляр некоторого класса или даже обычная функция, например такая:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">def</span> contacts_invariant(obj):

        <span class="cf">if</span> <span class="kw">not</span> (obj.email <span class="kw">or</span> obj.phone):
            <span class="cf">raise</span> <span class="pp">Exception</span>(
                <span class="st">&quot;Необходимо указать как минимум один вид контакта&quot;</span>)</code></pre></div>
<p>Затем надо определить интерфейс объекта <span><em>person</em></span>, используя функцию <code>zope.interface.invariant</code>, предписывающую, что для компоненты задается инвариант:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Interface
    <span class="im">from</span> zope.interface <span class="im">import</span> Attribute
    <span class="im">from</span> zope.interface <span class="im">import</span> invariant

    <span class="kw">class</span> IPerson(Interface):

        name <span class="op">=</span> Attribute(<span class="st">&quot;Имя&quot;</span>)
        email <span class="op">=</span> Attribute(<span class="st">&quot;Email-адрес&quot;</span>)
        phone <span class="op">=</span> Attribute(<span class="st">&quot;Номер телефона&quot;</span>)

        invariant(contacts_invariant)</code></pre></div>
<p>Теперь при помощи метода <span><em>validateInvariants</em></span> можно проверять (верифицировать) структуру объекта на непротиворечивость содержащихся в нем данных:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> implements

    <span class="kw">class</span> Person(<span class="bu">object</span>):
        implements(IPerson)

        name <span class="op">=</span> <span class="va">None</span>
        email <span class="op">=</span> <span class="va">None</span>
        phone <span class="op">=</span> <span class="va">None</span>

    jack <span class="op">=</span> Person()
    jack.email <span class="op">=</span> <span class="st">u&quot;jack@some.address.com&quot;</span>
    IPerson.validateInvariants(jack)
    jill <span class="op">=</span> Person()
    IPerson.validateInvariants(jill)
Traceback (most recent call last):

<span class="pp">Exception</span>: <span class="st">&quot;Необходимо указать как минимум один вид контакта&quot;</span></code></pre></div>
<p>Из примера видно, что объект <span><em>jack</em></span> верифицирован успешно, и при этом не возникло никаких исключений. Объект <span><em>jill</em></span>, наоборот, не прошел проверку ограничения, что привело к возникновению соответствующего исключения.</p>
</section>
</section>
<section id="адаптеры-id33" class="level1">
<h1><span class="header-section-number">4</span> Адаптеры [id33]</h1>
<section id="реализация-id34" class="level2">
<h2><span class="header-section-number">4.1</span> Реализация [id34]</h2>
<p>Компонентная архитектора Zope, как уже неоднократно говорилось, направлена на продуктивное использование объектов Python. Компоненты&quot;=адаптеры – это одна из базовых концепций ZCA, реализуемая и используемая для повышения продуктивности процесса программирования. Как и прежде, адаптеры – это объекты Python, но со специальным образом оформленным интерфейсом.</p>
<p>Для того, чтобы указать, что класс является адаптером, используется функция <span><em>adapts</em></span>, которая находится в пакете <code>zope.component</code>. В следующем примере в тексте определения адаптера <span><em>FrontDeskNG</em></span> включена декларация интерфейса, который реализует класс, и декларация адаптируемого интерфейса:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> implements
    <span class="im">from</span> zope.component <span class="im">import</span> adapts

    <span class="kw">class</span> FrontDeskNG(<span class="bu">object</span>):

        implements(IDesk)
        adapts(IGuest)

        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, guest):
            <span class="va">self</span>.guest <span class="op">=</span> guest

        <span class="kw">def</span> register(<span class="va">self</span>):
            guest <span class="op">=</span> <span class="va">self</span>.guest
            next_id <span class="op">=</span> get_next_id()
            bookings_db[next_id] <span class="op">=</span> {
            <span class="st">&#39;name&#39;</span>: guest.name,
            <span class="st">&#39;place&#39;</span>: guest.place,
            <span class="st">&#39;phone&#39;</span>: guest.phone
            }</code></pre></div>
<p>Итак, компонента <span><em>FrontDeskNG</em></span> – адаптер интерфейса <span><em>IGuest</em></span> к интерфейсу <span><em>IDesk</em></span>. Это значит, что везде, где требуются компоненты, обслуживающие интерфейс <span><em>IDesk</em></span>, можно использовать компоненты, обслуживающие <span><em>IGuest</em></span>, но через компоненту&quot;=адаптер <span><em>FrontDeskNG</em></span>. Интерфейс <span><em>IDesk</em></span> реализуется в классе <span><em>FrontDeskNG</em></span>, т. е., экземпляры этого класса обслуживают интерфейс <span><em>IDesk</em></span>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">class</span> Guest(<span class="bu">object</span>):

        implements(IGuest)

        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, name, place):
            <span class="va">self</span>.name <span class="op">=</span> name
            <span class="va">self</span>.place <span class="op">=</span> place

    jack <span class="op">=</span> Guest(<span class="st">&quot;Jack&quot;</span>, <span class="st">&quot;Bangalore&quot;</span>)
    jack_frontdesk <span class="op">=</span> FrontDeskNG(jack)

    IDesk.providedBy(jack_frontdesk)
<span class="va">True</span></code></pre></div>
<p>Можно разработать и другие адаптеры, регистрирующие новых постояльцев каким-либо другим способом.</p>
</section>
<section id="регистрация-адаптера-id35" class="level2">
<h2><span class="header-section-number">4.2</span> Регистрация адаптера [id35]</h2>
<p>Для того, чтобы использовать компоненту“=адаптер, необходимо ее сначала зарегистрировать в реестре компонент, который в ZCA называется менеджером сайта (site manager). Обычно реестр компонент ассоциируется с некоторым интернет”=сайтом. Такое название компоненты&quot;=реестра унаследовано от программной системы Zope 3, являющейся средой для разработки динамических сайтов, основанной на ZCA. Сейчас важно только знать, что в приложении есть некий глобальный сайт и его глобальный менеджер сайта, выполняющий функции реестра. Глобальный менеджер сайта располагается в оперативной памяти, а локальные – в долговременной.</p>
<p>Для регистрации компоненты сначала надо получить ссылку на глобальный реестр.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.component <span class="im">import</span> getGlobalSiteManager
    gsm <span class="op">=</span> getGlobalSiteManager()
    gsm.registerAdapter(FrontDeskNG,
                        (IGuest,), IDesk, <span class="st">&#39;ng&#39;</span>)</code></pre></div>
<p>Для того, чтобы найти глобальный реестр, необходимо вызвать функцию <code>getGlobalSiteManager</code>, которая находится в модуле <code>zope.component</code>. Фактически, реестр доступен как атрибут <code>globalSiteManager</code> пакета <code>zope.component</code>. То есть, можно просто использовать ссылку <code>zope.component.globalSiteManager</code>. Для регистрации адаптера используется метод <code>registerAdapter</code> реестра компонент. Первым аргументом метода должен быть либо класс, реализующий адаптер, либо какая“=либо фабрика. Вторым аргументом выступает набор (tuple) адаптируемых интерфейсов компонент. В приведенном примере адаптируются только компоненты, обслуживающие интерфейс <span><em>IGuest</em></span>. Третьим аргументом является интерфейс, обслуживаемый компонентой”=адаптером. Четвертый аргумент является необязательным, он позволяет идентифицировать адаптеры со специальными свойствами. В примере такой идентификатор как раз и был использован, в результате получился специальный поименованный адаптер (<span><em>named adapter</em></span>). Если название адаптеру не задано, то по умолчанию оно является пустой строкой (”).</p>
<p>В определении адаптера <span><em>FrontDeskNG</em></span> задаются и адаптируемый интерфейс и интерфейс, к которому происходит адаптация. То же самое задано и при регистрации адаптера, что бессмысленно дублирует информацию. Особой необходимости в этом нет, поэтому можно зарегистрировать адаптер <span><em>FrontDeskNG</em></span> следующим упрощенным вызовом:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    gsm.registerAdapter(FrontDeskNG, name<span class="op">=</span><span class="st">&#39;ng&#39;</span>)</code></pre></div>
<p>В ZCA остался устаревший API регистрации, который не следует использовать. Функции устаревшего API начинаются с <span><em>provide</em></span>, например: <code>provideAdapter</code>, <code>provideUtility</code> и т. д. При разработке приложений Zope 3 достаточно удобно использовать еще один способ регистрации компонент – Язык разметки для конфигурирования Zope (Zope configuration markup language, ZCML). Локальные компоненты Zope 3, т. е. компоненты, которые сохраняются в долговременной памяти, можно также регистрировать из Интерфейса управления Zope (Zope Management Interface, ZMI), ну и программным способом регистрация тоже может быть выполнена.</p>
<p>Адаптер <span><em>FrontDeskNG</em></span> зарегистрирован под названием <span><em>ng</em></span>. Подобным же образом можно регистрировать другие адаптеры для этой же комбинации интерфейсов под другими именами. Напомним, что если компонента зарегистрирована без названия, то в качестве названия используется пустая строка.</p>
<p>DUadmonitionnoteDUadmonitionnote</p>
</section>
<section id="запрос-адаптера-в-реестре-id36" class="level2">
<h2><span class="header-section-number">4.3</span> Запрос адаптера в реестре [id36]</h2>
<p>Доступ к зарегистрированной компоненте из реестра компонент осуществляется при помощи двух функций из пакета <code>zope.component</code>. Первая функция называется <code>getAdapter</code>, а другая – <code>queryAdapter</code>. Обе функции принимают одни и те же параметры и возвращают требуемую компоненту, если таковая была зарегистрирована. Eсли поиск компоненты в реестре завершился неудачей, то <code>getAdapter</code> создает исключительную ситуацию <code>ComponentLookupError</code>, <code>queryAdapter</code> просто возвратит <span><em>None</em></span>.</p>
<p>Импорт этих функций выполняется следующим образом:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.component <span class="im">import</span> getAdapter
    <span class="im">from</span> zope.component <span class="im">import</span> queryAdapter</code></pre></div>
<p>В следующем примере нам понадобиться поименованная компонента для адаптируемого объекта <span><em>guest</em></span>, который обслуживает интерфейс <span><em>IDesk</em></span>. Компонента реализована и зарегистрирована под именем ’ng’ в предыдущем разделе. Объект <span><em>guest</em></span> с именем <span><em>jack</em></span> создан в первом разделе этой главы.</p>
<p>Пример демонстрирует, как можно получать доступ к поименованной (’ng’) компоненте, адаптирующей интерфейс (<span><em>IGuest</em></span>) объекта <span><em>jack</em></span> и обслуживающей интерфейс <span><em>IDesk</em></span>. Здесь функции <code>getAdapter</code> и <code>queryAdapter</code> исполняются одинаково:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    getAdapter(jack, IDesk, <span class="st">&#39;ng&#39;</span>)
<span class="op">&lt;</span>FrontDeskNG <span class="bu">object</span> at ... <span class="op">&gt;</span>
    queryAdapter(jack, IDesk, <span class="st">&#39;ng&#39;</span>)
<span class="op">&lt;</span>FrontDeskNG <span class="bu">object</span> at ... <span class="op">&gt;</span></code></pre></div>
<p>В вызове функции первый аргумент – адаптируемый объект, второй – интерфейс, к которому необходимо этот объект адаптировать. Последний аргумент функции – идентификатор адаптера. Если попытаться получить доступ с идентификатором, который не использовался ранее при регистрации адаптеров таких же объектов к такому же интерфейсу, то по понятным причинам это завершиться неудачей. Приведем пример использования функций и продемонстрируем различие в их работе:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    getAdapter(jack, IDesk, <span class="st">&#39;not-exists&#39;</span>)
Traceback (most recent call last):

ComponentLookupError:
    reg <span class="op">=</span> queryAdapter(jack,
              IDesk, <span class="st">&#39;not-exists&#39;</span>)
    reg <span class="kw">is</span> <span class="va">None</span>
<span class="va">True</span></code></pre></div>
<p>Видно, что в результате неудачного доступа в <code>getAdapter</code> возникло исключение <code>ComponentLookupError</code>, а <code>queryAdapter</code> мирно вернул <span><em>None</em></span>. Если при получении доступа к компоненте не использовать ее идентификатор, это означает, что он будет равен пустой строке. И если компоненты без идентификатора не было зарегистрировано, то получить такой доступ тоже невозможно. Как и прежде в <code>getAdapter</code> возникнет исключение <code>ComponentLookupError</code>, а <code>queryAdapter</code> вернет <span><em>None</em></span>. Вот пример такого неудачного доступа:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    getAdapter(jack, IDesk)
Traceback (most recent call last):

ComponentLookupError:
    reg <span class="op">=</span> queryAdapter(jack, IDesk)
    reg <span class="kw">is</span> <span class="va">None</span>
<span class="va">True</span></code></pre></div>
<p>В этом разделе продемонстрировано как регистрируются простые адаптеры, и как потом получать к ним доступ при помощи реестра компонент. Простые адаптеры называются единичными адаптерами, так как адаптируют только один объект. Если компонента адаптирует более одного объекта, то она называется мультиадаптером.</p>
</section>
<section id="получение-доступа-к-адаптеру-с-использованием-интерфейса-id37" class="level2">
<h2><span class="header-section-number">4.4</span> Получение доступа к адаптеру с использованием интерфейса [id37]</h2>
<p>Получить доступ к адаптеру можно, используя только интерфейс. Этот метод работает только для непоименованных адаптеров, адаптирующих только один объект. Первый аргумент – адаптируемый объект, второй аргумент, ключевое слово, – объект, который возвращается, если доступ к компоненте оказывается неудачным.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    IDesk(jack, alternate<span class="op">=</span><span class="st">&#39;default-output&#39;</span>)
<span class="co">&#39;default-output&#39;</span></code></pre></div>
<p>Второй аргумент можно задавать и не в формате ключевого слова:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    IDesk(jack, <span class="st">&#39;default-output&#39;</span>)
<span class="co">&#39;default-output&#39;</span></code></pre></div>
<p>Если второй аргумент совсем не задан, то неудачная попытка доступа порождает исключение <span><em>TypeError</em></span>:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    IDesk(jack)
Traceback (most recent call last):

<span class="pp">TypeError</span>: (<span class="st">&#39;Could not adapt&#39;</span>,
  <span class="op">&lt;</span>Guest <span class="bu">object</span> at ... <span class="op">&gt;</span>,
  <span class="op">&lt;</span>InterfaceClass __builtin__.IDesk<span class="op">&gt;</span>)</code></pre></div>
<p>Зарегистрируем <span><em>FrontDeskNG</em></span> как непоименованный адаптер:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    gsm.registerAdapter(FrontDeskNG)</code></pre></div>
<p>Теперь доступ должен быть удачно получен:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    IDesk(jack, <span class="st">&#39;default-output&#39;</span>)
<span class="op">&lt;</span>FrontDeskNG <span class="bu">object</span> at ...<span class="op">&gt;</span></code></pre></div>
<p>В простых ситуациях можно спокойно использовать интерфейсы для получения доступа к компонентам&quot;=адаптерам.</p>
</section>
<section id="шаблон-проектирования-adapter-adapter" class="level2">
<h2><span class="header-section-number">4.5</span> Шаблон проектирования <span><em>Adapter</em></span> [adapter]</h2>
<p>Концепция использования адаптеров в Zope Component Architecture и в применении шаблона <span><em>Adapter</em></span> в классической книге “Шаблоны проектирования” являются схожими. Но приемы использования адаптеров в ZCA обладают большей гибкостью и широтой применения по сравнению с классическим шаблоном. Шаблон <span><em>Adapter</em></span> задает лишь преобразование некоторого класса к какому“=то другому интерфейсу, который требует сервис от экземпляров класса, с которыми он взаимодействует. Шаблон позволяет разным классам взаимодействовать друг с другом, даже если они до этого не могли это делать из”=за несовместимости их интерфейсов. В подразделе <span><em>Мотивация</em></span> книги “Шаблоны проектирования” авторы пишут: “Часто адаптер отвечает за функциональность, которую не может предоставить адаптируемый класс”. Адаптеры ZCA фокусируются больше как раз на реализации новых функций, чем просто создание нового интерфейса для адаптируемого объекта. При этом адаптер в ZCA расширяет функциональность за счет новых методов. Будет, наверное, интересным заметить, что <span><em>Adapter</em></span> в ранних версиях дизайна проекта ZCA назывался <span><em>Feature</em></span>.<span> </span></p>
<p>Упомянутая в предыдущем абзаце цитата из книги Банды четырех заканчивается следующими словами: “ … которую не может предоставить адаптируемый класс”. Но в следующем предложении абзаца использовано словосочетание “адаптируемого объекта” вместо “адаптируемого класса”, так как авторы книги на самом деле пишут про два варианта адаптеров, вариант зависит от реализации. Первый вариант – это “Адаптер класса”, а другой – “Адаптер объекта”. Адаптер классов использует множественное наследование для адаптации одного интерфейса к другому, с другой стороны, адаптер объекта опирается на композицию объектов. Адаптеры ZCA согласно книге Банды четырех следуют принципу адаптеру объекта, который использует делегирование (агрегирование) в качестве механизма композиции. Второй принцип объектно“=ориентированного дизайна согласно Банде четырех выражается следующим образом: ”Предпочитайте объектную композицию наследованию классов“. Если хотите более детально познакомиться с приемами адаптации, прочтите книгу ”Шаблоны проектирования&quot;.</p>
<p>Самой привлекательной стороной адаптеров ZCA – это явное использование интерфейсов, в виде специальных объектов Python, во время исполнения программы, а также реестра компонент. Адаптеры ZCA регистрируются в реестре компонент, через который другие объекты, затем, могут к ним получить доступ при помощи интерфейсов и механизмов поименования.</p>
</section>
</section>
<section id="утилиты-id39" class="level1">
<h1><span class="header-section-number">5</span> Утилиты [id39]</h1>
<p>Вы уже знакомы с концепциями “интерфейс”“, ”адаптер“ и ”реестр компонент&quot;. Иногда удобно регистрировать и отдельные объекты, которые ничего не адаптируют. Примерами таких объектов выступают соединения с базами данных, трансляторы XML, объекты, порождающие уникальные идентификаторы. Глобальные компоненты такого рода называются <code>утилитами</code>.</p>
<p>Утилиты – это объекты, которые обслуживают некоторый интерфейс, и к которым модули программ получают доступ по этим интерфейсам и регистрационным именам. Такой подход, с пользованием глобального реестра, позволяет регистрировать различные объекты и получать к ним доступ из различных частей программы, и при этом нет необходимости передавать эти объекты между модулями программы каким&quot;=либо специальным образом.</p>
<p>В программе нет необходимости регистрировать все глобальные объекты, смысл регистрации состоит в том, чтобы создать механизмы замены одних объектов, реализующих некоторый сервис, на другие, которые делают это как“=то по”=другому.</p>
<section id="простые-утилиты-id41" class="level2">
<h2><span class="header-section-number">5.1</span> Простые утилиты [id41]</h2>
<p>Утилиты могут быть зарегистрированы поименованными или нет. Пример поименованной утилиты рассмотрим в следующем разделе. Перед тем, как реализовать утилиту определим ее интерфейс. Следующий программный код определяет интерфейс <span><em>greeter</em></span> утилиты, которая будет приветствовать постояльцев:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Interface
    <span class="im">from</span> zope.interface <span class="im">import</span> implements

    <span class="kw">class</span> IGreeter(Interface):

        <span class="kw">def</span> greet(name):
            <span class="co">&quot;&quot;&quot;Поприветствовать&quot;&quot;&quot;</span></code></pre></div>
<p>Как и адаптеры, так и утилиты можно реализовать несколькими способами. Вот классическая реализация при помощи класса:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">class</span> Greeter(<span class="bu">object</span>):

        implements(IGreeter)

        <span class="kw">def</span> greet(<span class="va">self</span>, name):
            <span class="cf">return</span> <span class="st">&quot;Здравствуйте, &quot;</span> <span class="op">+</span> name</code></pre></div>
<p>В данном случае утилитой будет экземпляр класса <span><em>Greeter</em></span>. Чтобы утилитой можно было пользоваться, необходимо ее зарегистрировать. Для этого пользуется API ZCA. Утилита регистрируется при помощи метода реестра компонент <code>registerUtility</code>:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.component <span class="im">import</span> getGlobalSiteManager
    gsm <span class="op">=</span> getGlobalSiteManager()

    greet <span class="op">=</span> Greeter()
    gsm.registerUtility(greet, IGreeter)</code></pre></div>
<p>В этом примере утилита зарегистрирована как компонента, обслуживающая интерфейс <span><em>IGreeter</em></span>. Доступ к утилите получается по запросу обслуживаемого ей интерфейса, передав его функций <span><em>queryUtility</em></span> или <span><em>getUtility</em></span> в качестве первого параметра.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.component <span class="im">import</span> queryUtility
    <span class="im">from</span> zope.component <span class="im">import</span> getUtility

    queryUtility(IGreeter).greet(<span class="st">&#39;Jack&#39;</span>)
<span class="co">&#39;Здравствуйте, Jack&#39;</span>

    getUtility(IGreeter).greet(<span class="st">&#39;Jack&#39;</span>)
<span class="co">&#39;Здравствуйте,~Jack&#39;</span></code></pre></div>
<p>По аналогии с адаптерами, которые, как правило, являются классами, утилиты, как правило, являются экземплярами классов. Поэтому экземпляры утилит создаются единожды, а экземпляры адаптеров – всякий раз, как кто&quot;=то желает получить адаптер для объекта или нескольких объектов.</p>
</section>
<section id="поименованные-утилиты-id42" class="level2">
<h2><span class="header-section-number">5.2</span> Поименованные утилиты [id42]</h2>
<p>При регистрации компоненты“=утилиты, как и адаптера, можно давать им имена. Утилита, зарегистрированная под каким”=либо именем, называется поименованной утилитой.</p>
<p>Приведем пример регистрации поименованной утилиты <span><em>greeter</em></span>:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    greet <span class="op">=</span> Greeter()
    gsm.registerUtility(greet, IGreeter, <span class="st">&#39;new&#39;</span>)</code></pre></div>
<p>Экземпляр <span><em>greet</em></span> зарегистрирован как утилита, обслуживающая интерфейс <span><em>IGreeter</em></span>, под именем <span><em>new</em></span>. Теперь можно получить к ней доступ одной из функций <span><em>queryUtility</em></span> или <span><em>getUtility</em></span>:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.component <span class="im">import</span> queryUtility
    <span class="im">from</span> zope.component <span class="im">import</span> getUtility

    queryUtility(IGreeter, <span class="st">&#39;new&#39;</span>).greet(<span class="st">&#39;Jill&#39;</span>)
<span class="co">&#39;Здравствуйте, Jill&#39;</span>

    getUtility(IGreeter, <span class="st">&#39;new&#39;</span>).greet(<span class="st">&#39;Jill&#39;</span>)
<span class="co">&#39;Здравствуйте, Jill&#39;</span></code></pre></div>
<p>Заметим, что для получения доступа необходимо использовать имя <span><em>name</em></span> во втором аргументе функций.</p>
<p>Вызов функции <span><em>getUtility</em></span> без имени (второй аргумент) эквивалентно вызову этой функции с пустой строкой в качестве второго аргумента, так как это – значение по умолчанию. Если в данном примере реестру компонент задать поиск компоненты, чье имя – пустая строка, такая попытка поиска завершится неуспехом. Если компонента не найдена, то функция создают исключение <code>ComponentLookupError</code>. Она не будут вам возвращать какие&quot;=то другие компоненты, зарегистрированные под другими именами. Функции получения доступа к адаптерам <span><em>getAdapter</em></span> и <span><em>queryAdapter</em></span> функционируют аналогично.</p>
</section>
<section id="фабрики-id43" class="level2">
<h2><span class="header-section-number">5.3</span> Фабрики [id43]</h2>
<p>Компоненты, называемые <span><em>фабриками</em></span> (<code>Factory</code>), – это утилиты, обслуживающие интерфейс <code>IFactory</code>.</p>
<p>Чтобы создать фабрику, сначала необходимо определить интерфейс объекта.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Attribute
    <span class="im">from</span> zope.interface <span class="im">import</span> Interface
    <span class="im">from</span> zope.interface <span class="im">import</span> implements

    <span class="kw">class</span> IDatabase(Interface):

        <span class="kw">def</span> getConnection():
            <span class="co">&quot;&quot;&quot;Вернуть объект - соединение с базой данных&quot;&quot;&quot;</span></code></pre></div>
<p>Вот пример заглушки, реализующей интерфейс <span><em>IDatabase</em></span>:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">class</span> FakeDb(<span class="bu">object</span>):

        implements(IDatabase)

        <span class="kw">def</span> getConnection(<span class="va">self</span>):
            <span class="cf">return</span> <span class="st">&quot;connection&quot;</span></code></pre></div>
<p>Теперь можно создать фабрику при помощи <code>zope.component.factory.Factory</code>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.component.factory <span class="im">import</span> Factory

    factory <span class="op">=</span> Factory(FakeDb, <span class="st">&#39;FakeDb&#39;</span>)</code></pre></div>
<p>Зарегистрируем фабрику.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.component <span class="im">import</span> getGlobalSiteManager
    gsm <span class="op">=</span> getGlobalSiteManager()

    <span class="im">from</span> zope.component.interfaces <span class="im">import</span> IFactory
    gsm.registerUtility(factory, IFactory, <span class="st">&#39;fakedb&#39;</span>)</code></pre></div>
<p>Для получения доступа к фабрике, можно использовать следующий код:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.component <span class="im">import</span> queryUtility
    queryUtility(IFactory, <span class="st">&#39;fakedb&#39;</span>)()
<span class="op">&lt;</span>FakeDb <span class="bu">object</span> at ...<span class="op">&gt;</span></code></pre></div>
<p>Кроме того, можно и удобную использовать сокращенную версию запроса на порождение фабрикой конкретных объектов:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.component <span class="im">import</span> createObject
    createObject(<span class="st">&#39;fakedb&#39;</span>)
<span class="op">&lt;</span>FakeDb <span class="bu">object</span> at ...<span class="op">&gt;</span></code></pre></div>
</section>
</section>
<section id="дополнительные-возможности-адаптеров-id44" class="level1">
<h1><span class="header-section-number">6</span> Дополнительные возможности адаптеров [id44]</h1>
<p>В этом разделе рассмотрим дополнительные возможности, предоставляемые специальными видами адаптеров, в частности, <span><em>мультиадаптерами</em></span> (<span><em>multi adapter</em></span>), <span><em>адаптерами&quot;=подписчиками</em></span> (<span><em>subscription adapter</em></span>) и <span><em>обработчиками</em></span> (<span><em>handler</em></span>).</p>
<section id="мультиадаптеры-id45" class="level2">
<h2><span class="header-section-number">6.1</span> Мультиадаптеры [id45]</h2>
<p>Простые адаптеры адаптируют только один объект, но, в принципе, компоненты могут адаптировать и несколько объектов. Если компонента адаптирует больше одного объекта, кто она называется <span><em>мультиадаптер</em></span> (<span><em>multi&quot;=adapter</em></span>).</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Interface
    <span class="im">from</span> zope.interface <span class="im">import</span> implements
    <span class="im">from</span> zope.component <span class="im">import</span> adapts

    <span class="kw">class</span> IAdapteeOne(Interface):
        <span class="cf">pass</span>

    <span class="kw">class</span> IAdapteeTwo(Interface):
        <span class="cf">pass</span>

    <span class="kw">class</span> IFunctionality(Interface):
        <span class="cf">pass</span>

    <span class="kw">class</span> MyFunctionality(<span class="bu">object</span>):
        implements(IFunctionality)
        adapts(IAdapteeOne, IAdapteeTwo)

        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, one, two):
            <span class="va">self</span>.one <span class="op">=</span> one
            <span class="va">self</span>.two <span class="op">=</span> two

    <span class="im">from</span> zope.component <span class="im">import</span> getGlobalSiteManager
    gsm <span class="op">=</span> getGlobalSiteManager()

    gsm.registerAdapter(MyFunctionality)

    <span class="kw">class</span> One(<span class="bu">object</span>):
        implements(IAdapteeOne)

    <span class="kw">class</span> Two(<span class="bu">object</span>):
        implements(IAdapteeTwo)

    one <span class="op">=</span> One()
    two <span class="op">=</span> Two()

    <span class="im">from</span> zope.component <span class="im">import</span> getMultiAdapter

    getMultiAdapter((one,two), IFunctionality)
<span class="op">&lt;</span>MyFunctionality <span class="bu">object</span> at ...<span class="op">&gt;</span>

    myfunctionality <span class="op">=</span> getMultiAdapter((one,two), IFunctionality)
    myfunctionality.one
<span class="op">&lt;</span>One <span class="bu">object</span> at ...<span class="op">&gt;</span>
    myfunctionality.two
<span class="op">&lt;</span>Two <span class="bu">object</span> at ...<span class="op">&gt;</span></code></pre></div>
</section>
<section id="адаптеры-подписчики-id46" class="level2">
<h2><span class="header-section-number">6.2</span> Адаптеры-подписчики [id46]</h2>
<p>В отличие от обычных адаптеров, адаптеры“=подписчики, еще их называют просто <span><em>подписчиками</em></span>, используются, если есть необходимость реализовать возможность набора некоторого списка достаточно однотипных компонент”=адаптеров, адаптирующих объект к одному и тому же интерфейсу. Полученный список адаптеров, затем, можно поэлементно перебрать и выполнить одну и ту же процедуру в каждом адаптере“=подписчике. Результаты волнения процедур каким”=либо образом объединяются и используются.</p>
<p>Рассмотрим задачу верификации объектов. Пусть задан набор объектов, и нам требуется оценить их соответствие некоторым требованиям. Определим интерфейс верификатора.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Interface
    <span class="im">from</span> zope.interface <span class="im">import</span> Attribute
    <span class="im">from</span> zope.interface <span class="im">import</span> implements

    <span class="kw">class</span> IValidate(Interface):

        <span class="kw">def</span> validate(ob):
            <span class="co">&quot;&quot;&quot;Определить соответствие объекта стандарту</span>

<span class="co">            Возвращает строку, характеризующую отклонение от</span>
<span class="co">            стандарта. Пустая строка обозначает, что объект</span>
<span class="co">            успешно прошел верификацию.</span>
<span class="co">            &quot;&quot;&quot;</span></code></pre></div>
<p>Определим объекты-документы.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">class</span> IDocument(Interface):

        summary <span class="op">=</span> Attribute(<span class="st">&quot;Document summary&quot;</span>)
        body <span class="op">=</span> Attribute(<span class="st">&quot;Document text&quot;</span>)

    <span class="kw">class</span> Document(<span class="bu">object</span>):

        implements(IDocument)

        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, summary, body):
            <span class="va">self</span>.summary, <span class="va">self</span>.body <span class="op">=</span> summary, body</code></pre></div>
<p>Теперь можно определить разные правила верификации документов. Например, можно потребовать, чтобы конспект&quot;=резюме документа был текстом из одной строки.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.component <span class="im">import</span> adapts

    <span class="kw">class</span> SingleLineSummary:

        adapts(IDocument)
        implements(IValidate)

        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, doc):
            <span class="va">self</span>.doc <span class="op">=</span> doc

        <span class="kw">def</span> validate(<span class="va">self</span>):
            <span class="cf">if</span> <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span> <span class="kw">in</span> <span class="va">self</span>.doc.summary:
                <span class="cf">return</span> <span class="st">&#39;Резюме должно состоять только из одной` +</span>
<span class="st">                ` строки текста&#39;</span>
            <span class="cf">else</span>:
                <span class="cf">return</span> <span class="st">&#39;&#39;</span></code></pre></div>
<p>Можно потребовать, чтобы основной текст документа состоял как минимум из 1000 символов.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">class</span> AdequateLength(<span class="bu">object</span>):

        adapts(IDocument)
        implements(IValidate)

        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, doc):
            <span class="va">self</span>.doc <span class="op">=</span> doc

        <span class="kw">def</span> validate(<span class="va">self</span>):
            <span class="cf">if</span> <span class="bu">len</span>(<span class="va">self</span>.doc.body) <span class="op">&lt;</span> <span class="dv">1000</span>:
                <span class="cf">return</span> <span class="st">&#39;слишком короткий&#39;</span>
            <span class="cf">else</span>:
                <span class="cf">return</span> <span class="st">&#39;&#39;</span></code></pre></div>
<p>Теперь надо зарегистрировать эти адаптеры-подписчики.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.component <span class="im">import</span> getGlobalSiteManager
    gsm <span class="op">=</span> getGlobalSiteManager()

    gsm.registerSubscriptionAdapter(SingleLineSummary)
    gsm.registerSubscriptionAdapter(AdequateLength)</code></pre></div>
<p>И теперь зарегистрированные подписчики можно использовать для верификации объектов.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.component <span class="im">import</span> subscribers

    doc <span class="op">=</span> Document(<span class="st">&quot;A text</span><span class="ch">\n</span><span class="st">Document&quot;</span>, <span class="st">&quot;lorum&quot;</span>)
    [adapter.validate()
     <span class="cf">for</span> adapter <span class="kw">in</span> subscribers([doc], IValidate)
     <span class="cf">if</span> adapter.validate()]
[<span class="st">&#39;Резюме должно состоять только из одной строки текста&#39;</span>, <span class="st">&#39;слишком короткий&#39;</span>]

    doc <span class="op">=</span> Document(<span class="st">&quot;A text</span><span class="ch">\n</span><span class="st">Document&quot;</span>, <span class="st">&quot;ipsum&quot;</span> <span class="op">*</span> <span class="dv">1000</span>)
    [adapter.validate()
     <span class="cf">for</span> adapter <span class="kw">in</span> subscribers([doc], IValidate)
     <span class="cf">if</span> adapter.validate()]
[<span class="st">&#39;Резюме должно состоять только из одной строки текста&#39;</span>]

    doc <span class="op">=</span> Document(<span class="st">&quot;A Document&quot;</span>, <span class="st">&quot;dolor&quot;</span>)
    [adapter.validate()
     <span class="cf">for</span> adapter <span class="kw">in</span> subscribers([doc], IValidate)
     <span class="cf">if</span> adapter.validate()]
[<span class="st">&#39;слишком короткий&#39;</span>]</code></pre></div>
</section>
<section id="обработчики-id47" class="level2">
<h2><span class="header-section-number">6.3</span> Обработчики [id47]</h2>
<p><span><em>Обработчики</em></span> – это фабрики адаптеров&quot;=подписчиков, которые ничего не возвращают. Они просто выполняют некоторую процедуру, как только им передается управление. Основной вид использования обработчиков – это реализация реакции на возникающие в приложении события. Обработчики по своей сути являются подписчиками на события, и их иногда называют <span><em>адаптеры, подписанные на события</em></span>.</p>
<p>Подписчики на события отличаются от других адаптеров“=подписчиков тем, что объект, вызывающий обработчика, не ожидает от него никакого прямого взаимодействия. Например, объект, инициирующий событие не ожидает от обработчиков этого события каких”=либо значений в ответ. Подписчикам нет необходимости обслуживать какой&quot;=либо API для вызвавших их компонентов, поэтому более естественно реализовывать подписчики при помощи функций, а не классов. В системе управления контентом, например, можно автоматизировать добавление времени создания документа в виде поля этого документа.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">import</span> datetime

    <span class="kw">def</span> documentCreated(event):
        event.doc.created <span class="op">=</span> datetime.datetime.utcnow()</code></pre></div>
<p>В предыдущем примере определена функция, которая получает событие (<span><em>event</em></span>) и выполняет процедуру добавления данных в соответствующий объект. Результат, как видите, не возвращается. Обработчики – это частные случаи подписчиков, которые адаптируют события к “ничто”. Вся работа выполняется, когда этот адаптер-“фабрика” был вызван. Для регистрации обработчиков в ZCA APIs используются специальные функции.</p>
<p>Чтобы продемонстрировать регистрацию и использование вышеупомянутого обработчика, сначала создадим событие <span><em>документ&quot;=создан</em></span> (<span><em>document&quot;=created</em></span>).</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Interface
    <span class="im">from</span> zope.interface <span class="im">import</span> Attribute
    <span class="im">from</span> zope.interface <span class="im">import</span> implements

    <span class="kw">class</span> IDocumentCreated(Interface):

        doc <span class="op">=</span> Attribute(<span class="st">&quot;Документ, который был создан&quot;</span>)

    <span class="kw">class</span> DocumentCreated(<span class="bu">object</span>):

        implements(IDocumentCreated)

        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, doc):
            <span class="va">self</span>.doc <span class="op">=</span> doc</code></pre></div>
<p>Также немного дополним текст нашего обработчика.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.component <span class="im">import</span> adapter

    <span class="at">@adapter</span>(IDocumentCreated)
    <span class="kw">def</span> documentCreated(event):
        event.doc.created <span class="op">=</span> datetime.datetime.utcnow()</code></pre></div>
<p>Добавленная конструкция помечает обработчик интерфейсом <span><em>IDocumentCreated</em></span> компоненты&quot;=события <span><em>DocumentCreated</em></span>.</p>
<p>Теперь необходимо обработчик зарегистрировать.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.component <span class="im">import</span> getGlobalSiteManager
    gsm <span class="op">=</span> getGlobalSiteManager()

    gsm.registerHandler(documentCreated)</code></pre></div>
<p>Теперь можно создать компоненту&quot;=событие и инициировать его обработку функцией <span><em>handle</em></span>, которая вызовет все зарегистрированные обработчики для данного события.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.component <span class="im">import</span> handle

    handle(DocumentCreated(doc))
    doc.created.__class__.<span class="va">__name__</span>
<span class="co">&#39;datetime&#39;</span></code></pre></div>
</section>
</section>
<section id="как-zca-используется-в-zope-zca-zope" class="level1">
<h1><span class="header-section-number">7</span> Как ZCA используется в Zope [zca-zope]</h1>
<p>Компонентная архитектура Zope используется как в Zope 3 и более новых версиях, так и в Zope 2. В этом разделе предложен обзор применения ZCA в Zope.</p>
<section id="zcml-zcml" class="level2">
<h2><span class="header-section-number">7.1</span> ZCML [zcml]</h2>
<p>Язык <strong>Zope Configuration Markup Language (ZCML)</strong> (Язык разметки для конфигурирования Zope) – это язык задания конфигурации программной системе, базирующийся на стандарте XML. Вместо того, чтобы использовать API Python для регистрации компонент, можно использовать язык ZCML. Но для этого сначала надо установить несколько пакетов, от которых зависит функционирование языка.</p>
<p>Необходимые зависимости догружаются во время установки пакета <code>zope.component</code> в варианте с поддержкой ZCML. Загрузка пакетов выполняется утилитой командной строки easy_install следующим образом:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="ex">easy_install</span> <span class="st">&quot;zope.component [zcml]&quot;</span></code></pre></div>
<p>Каждый файл конфигурации и регистрации компонент ZCML должен начиняться с директивы (тега) <code>configure</code> с соответствующей декларацией пространства имен.</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;configure</span><span class="ot"> xmlns=</span><span class="st">&quot;http://namespaces.zope.org/zope&quot;</span><span class="kw">&gt;</span>

<span class="kw">&lt;/configure&gt;</span></code></pre></div>
<p>Директива <span><em>adapter</em></span> предназначена для регистрации адаптеров.</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;adapter</span>
<span class="ot">    factory=</span><span class="st">&quot;.company.EmployeeSalary&quot;</span>
<span class="ot">    provides=</span><span class="st">&quot;.interfaces.ISalary&quot;</span>
<span class="ot">    for=</span><span class="st">&quot;.interfaces.IEmployee&quot;</span>
    <span class="kw">/&gt;</span></code></pre></div>
<p>Атрибуты <span><em>provides</em></span> и <span><em>for</em></span> являются необязательными, если необходимая информация ранее была представлена в реализации.</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;adapter</span>
<span class="ot">    factory=</span><span class="st">&quot;.company.EmployeeSalary&quot;</span>
    <span class="kw">/&gt;</span></code></pre></div>
<p>Для того, чтобы зарегистрировать компоненту как поименованный адаптер надо использовать атрибут <span><em>name</em></span>.</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;adapter</span>
<span class="ot">    factory=</span><span class="st">&quot;.company.EmployeeSalary&quot;</span>
<span class="ot">    name=</span><span class="st">&quot;salary&quot;</span>
    <span class="kw">/&gt;</span></code></pre></div>
<p>Утилиты регистрируются директивой <span><em>utility</em></span>. Для этого используется следующая конструкция:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;utility</span>
<span class="ot">    component=</span><span class="st">&quot;.database.connection&quot;</span>
<span class="ot">    provides=</span><span class="st">&quot;.interfaces.IConnection&quot;</span>
    <span class="kw">/&gt;</span></code></pre></div>
<p>Атрибут <span><em>provides</em></span> не является обязательным, если необходимая информация представлена в реализации.</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;configure</span><span class="ot"> xmlns=</span><span class="st">&quot;http://namespaces.zope.org/zope&quot;</span><span class="kw">&gt;</span>

<span class="kw">&lt;utility</span>
<span class="ot">    component=</span><span class="st">&quot;.database.connection&quot;</span>
    <span class="kw">/&gt;</span></code></pre></div>
<p>Поименованные утилиты регистрируются также, только необходимо использовать атрибут <span><em>name</em></span>.</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;utility</span>
<span class="ot">    component=</span><span class="st">&quot;.database.connection&quot;</span>
<span class="ot">    name=</span><span class="st">&quot;db_connection&quot;</span>
    <span class="kw">/&gt;</span></code></pre></div>
<p>Вместо регистрации утилиты как объекта (экземпляра) можно зарегистрировать его фабрику.</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;utility</span>
<span class="ot">    factory=</span><span class="st">&quot;.database.Connection&quot;</span>
    <span class="kw">/&gt;</span></code></pre></div>
</section>
<section id="замещения-id48" class="level2">
<h2><span class="header-section-number">7.2</span> Замещения [id48]</h2>
<p>При регистрации компонент методами <code>register*</code> API Python реализуется следующее правило: компонента, которая была зарегистрирована последней заменяет (замещает) собой ранее зарегистрированную компоненту, если они обе зарегистрированы с одним и тем же набором аргументов функций&quot;=регистраторов. Рассмотрим следующий пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Attribute
    <span class="im">from</span> zope.interface <span class="im">import</span> Interface

    <span class="kw">class</span> IA(Interface):
        <span class="cf">pass</span>

    <span class="kw">class</span> IP(Interface):
        <span class="cf">pass</span>

    <span class="im">from</span> zope.interface <span class="im">import</span> implements
    <span class="im">from</span> zope.component <span class="im">import</span> adapts

    <span class="im">from</span> zope.component <span class="im">import</span> getGlobalSiteManager
    gsm <span class="op">=</span> getGlobalSiteManager()

    <span class="kw">class</span> AP(<span class="bu">object</span>):

        implements(IP)
        adapts(IA)

        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, context):
            <span class="va">self</span>.context <span class="op">=</span> context

    <span class="kw">class</span> AP2(<span class="bu">object</span>):

        implements(IP)
        adapts(IA)

        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, context):
            <span class="va">self</span>.context <span class="op">=</span> context

    <span class="kw">class</span> A(<span class="bu">object</span>):

        implements(IA)

    a <span class="op">=</span> A()
    ap <span class="op">=</span> AP(a)

    gsm.registerAdapter(AP)

    getAdapter(a, IP)
<span class="op">&lt;</span>AP <span class="bu">object</span> at ...<span class="op">&gt;</span></code></pre></div>
<p>Теперь, если зарегистрировать еще один адаптер, то уже существующий будет замещен.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    gsm.registerAdapter(AP2)

    getAdapter(a, IP)
<span class="op">&lt;</span>AP2 <span class="bu">object</span> at ...<span class="op">&gt;</span></code></pre></div>
<p>Если же регистрировать компоненты при помощи ZCML, то вторая регистрация создаст конфликт, что проявится в виде исключения. Этот принцип позволяет контролировать ситуации, когда нужный зарегистрированный адаптер по ошибке замещается каким&quot;=то другим. В результате удается избегать необходимость отслеживать ошибки в работе проектируемой программной системы. Получается, что использование ZCML способствует даже упрощению разработки.</p>
<p>Иногда, все&quot;=таки, необходимо заменять существующие регистрации. Для этого в ZCML есть директива <code>includeOverrides</code>. Используя эту директиву, можно указывать, что в отдельном файле (атрибут <span><em>file</em></span>) находятся регистрации, замещающие собой имеющиеся:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;includeOverrides</span><span class="ot"> file=</span><span class="st">&quot;overrides.zcml&quot;</span> <span class="kw">/&gt;</span></code></pre></div>
</section>
<section id="адаптер-namechooser-namechooser" class="level2">
<h2><span class="header-section-number">7.3</span> Адаптер NameChooser [namechooser]</h2>
<p>Пакет: <span><em>zope.app.container.contained.NameChooser</em></span></p>
<p>Адаптер NameChooser – это адаптер, который подбирает уникальное имя для некоторого объекта внутри контейнера.</p>
<p>Регистрация такого адаптера выглядит следующим образом:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;adapter</span>
<span class="ot">    provides=</span><span class="st">&quot;.interfaces.INameChooser&quot;</span>
<span class="ot">    for=</span><span class="st">&quot;zope.app.container.interfaces.IWriteContainer&quot;</span>
<span class="ot">    factory=</span><span class="st">&quot;.contained.NameChooser&quot;</span>
    <span class="kw">/&gt;</span></code></pre></div>
<p>Из данной конструкции видно, что адаптируемый объект обеспечивает <code>IWriteContainer</code>, а адаптер – <code>INameChooser</code>.</p>
<p>Адаптер <span><em>NameChooser</em></span> очень удобен программистам Zope. Реализация <code>IWriteContainer</code> в Zope 3 распределена, в основном, между классами пакетов <code>zope.app.container.BTreeContainer</code> и <code>zope.app.folder.Folder</code>. Обычно в своих программах надо наследовать от этих классов их функции для создания собственных классов&quot;=контейнеров. Если бы разработчики ранее не реализовали интерфейс <code>INameChooser</code> и адаптер <code>NameChooser</code>, тогда вам пришлось бы вновь создавать их для каждой реализации отдельно.</p>
</section>
<section id="адаптер-locationphysicallylocatable-locationphysicallylocatable" class="level2">
<h2><span class="header-section-number">7.4</span> Адаптер LocationPhysicallyLocatable [locationphysicallylocatable]</h2>
<p>Пакет: <code>zope.location.traversing.LocationPhysicallyLocatable</code></p>
<p>Этот адаптер часто используется при программировании приложений в среде Zope 3, но вызывается обычно при помощи специального API в пакете <code>zope.traversing.api</code>. (Редкий старый код до сих пор использует функции <code>zope.app.zapi</code>, которые добавляют еще один слой косвенных вызовов для этого адаптера)</p>
<p>Регистрация данного адаптера выполняется следующим образом:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;adapter</span>
<span class="ot">    factory=</span><span class="st">&quot;zope.location.traversing.LocationPhysicallyLocatable&quot;</span>
    <span class="kw">/&gt;</span></code></pre></div>
<p>Интерфейс, который обеспечивает компонента и адаптируемый интерфейс задаются в реализации, начало которой выглядит вот так:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> LocationPhysicallyLocatable(<span class="bu">object</span>):
    <span class="co">&quot;&quot;&quot;Обеспечить информацию о местоположении объектов</span>
<span class="co">    &quot;&quot;&quot;</span>
    zope.component.adapts(ILocation)
    zope.interface.implements(IPhysicallyLocatable)
    ...</code></pre></div>
<p>Как правило, все объекты, хранимые в базах данных, в приложении Zope 3 обеспечивают интерфейс <code>ILocation</code>. У этого интерфейса есть только два атрибута, <code>__parent__</code> и <code>__name__</code>. Атрибут <code>__parent__</code> соответствует родительскому узлу в иерархии адресов, а <code>__name__</code> – это название объекта, которое уникально среди множества объектов с одним родительским узлом.</p>
<p>Интерфейс <code>IPhysicallyLocatable</code> содержит четыре метода: <code>getRoot</code>, <code>getPath</code>, <code>getName</code>, и <code>getNearestSite</code>.</p>
<ul>
<li><p><code>getRoot</code> – функция, которая возвращает объект, соответствующий корневому узлу.</p></li>
<li><p><code>getPath</code> возвращает физический путь к объекту в виде строки.</p></li>
<li><p><code>getName</code> возвращает последний сегмент физического пути.</p></li>
<li><p><code>getNearestSite</code> возвращает объект“=сайт, в котором содержится адаптируемый объект, как правило это регистр компонент, привязанный к конкретному сайту (интернет”=приложению, реализованному на одном сервере Zope 3); если он сам является сайтом, то он сам и возвращается.</p></li>
</ul>
<p>Если вы решите заняться изучением среды Zope 3, вы увидите, что компоненты, о которых идет сейчас речь, являются важными сущностями, и они используются очень и очень часто. Для полного осознания всей красоты такого подхода необходимо также разобраться, как в системе Zope 2 осуществляется поиск корневого объекта и как это реализовано: почти в каждом объекте&quot;=контейнере есть метод <code>getPhysicalRoot</code>.</p>
</section>
<section id="адаптер-defaultsized-defaultsized" class="level2">
<h2><span class="header-section-number">7.5</span> Адаптер DefaultSized [defaultsized]</h2>
<p>Пакет: <code>zope.size.DefaultSized</code></p>
<p>Этот адаптер – просто реализация интерфейса <code>ISized</code> по умолчанию. Адаптер “знает” как адаптировать все виды объектов, т. е. зарегистрирован как адаптер всех объектов. Если вам потребуется зарегистрировать этот адаптер для какого&quot;=либо интерфейса, то придется уже существующую регистрацию замещать новой.</p>
<p>Регистрация этого адаптера в Zope сделана следующим образом:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;adapter</span>
<span class="ot">    for=</span><span class="st">&quot;*&quot;</span>
<span class="ot">    factory=</span><span class="st">&quot;zope.size.DefaultSized&quot;</span>
<span class="ot">    provides=</span><span class="st">&quot;zope.size.interfaces.ISized&quot;</span>
<span class="ot">    permission=</span><span class="st">&quot;zope.View&quot;</span>
    <span class="kw">/&gt;</span></code></pre></div>
<p>Здесь видно, что адаптируемый интерфейс задан как <span><em>*</em></span>, т. е. <span><em>DefaultSized</em></span> адаптирует любые разновидности объектов.</p>
<p>Интерфейс <code>ISized</code> очень прост и включает спецификации всего двух методов.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> ISized(Interface):

    <span class="kw">def</span> sizeForSorting():
        <span class="co">&quot;&quot;&quot;Возвращает двойку (basic_unit, amount).</span>

<span class="co">        Используется для сортировки разнородных объектов,</span>
<span class="co">        характеризующихся некоторым размером. Значение &#39;amount&#39;</span>
<span class="co">        требуется только для сортировки объектов с одной и той же</span>
<span class="co">        единицей измерения &#39;basic_unit&#39;.&quot;&quot;&quot;</span>

    <span class="kw">def</span> sizeForDisplay():
        <span class="co">&quot;&quot;&quot;Возвращает строку, представляющую размер объекта.</span>
<span class="co">        &quot;&quot;&quot;</span></code></pre></div>
<p>Пример специально зарегистрированного адаптера <code>ISized</code> для интерфейса <code>IZPTPage</code> можно посмотреть в пакете <code>zope.app.zptpage</code>.</p>
</section>
<section id="утилита-zopeversionutility-zopeversionutility" class="level2">
<h2><span class="header-section-number">7.6</span> Утилита ZopeVersionUtility [zopeversionutility]</h2>
<p>Пакет: <code>zope.app.applicationcontrol.ZopeVersionUtility</code></p>
<p>Утилита сообщает версию выполняющегося процесса Zope.</p>
<p>Регистрация выполняется следующим образом:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;utility</span>
<span class="ot">    component=</span><span class="st">&quot;.zopeversion.ZopeVersionUtility&quot;</span>
<span class="ot">    provides=</span><span class="st">&quot;.interfaces.IZopeVersion&quot;</span> <span class="kw">/&gt;</span></code></pre></div>
<p>Интерфейс, который обслуживает эта утилита, называется <code>IZopeVersion</code>, он специфицирует только один метод, называемый <code>getZopeVersion</code>. Этот метод возвращает строку, характеризующую версию программного обеспечения среды Zope, включая всевозможную информацию, например, версию исходного кода в репозитарии Subversion.</p>
<p>Реализация утилиты по умолчанию, <code>ZopeVersionUtility</code>, получает информацию о версии Zope из файла <code>version.txt</code> в директории <span><em>zope/app</em></span>. Если система Zope была запущена в слепке (checkout) сервера Subversion, то утилита покажет последний номер ревизии. Если ни того ни другого источника информации не удалось найти, утилита вернет строку <span><em>Development/Unknown</em></span>.</p>
</section>
<section id="sec:proxyadapters" class="level2">
<h2><span class="header-section-number">7.7</span> Адаптеры–&lt;&lt;заместители&gt;&gt;</h2>
<p>FIXME: Вероятно не в этом разделе это должно быть.</p>
<p>Практически в любом приложении предполагается наличие системы пользователей и ролей, где каждой роли назначается набор функций, допустимых к исполнению. Например, руководитель предприятия получает доступ к результатам анализа финансового состояния предприятия. Специалист&quot;=аналитик проводит этот анализ на основе данных базы данных предприятия, а работники имеют право вводить данные в базу данных согласно структуру предприятия. При этом множества функций, выполняемых пользователями (ролями), как правило, не пересекаются. Такое разделение позволяет уменьшить количество ошибок в базе данных и структуре документооборота на предприятии.</p>
<p>В рамках компонентной модели система ролей реализуется при помощи адаптеров…</p>
<section id="sec:distributedapps" class="level3">
<h3><span class="header-section-number">7.7.1</span> Распределенные приложения</h3>
<p>Иногда бывает так, что ресурсов одной рабочей станции достаточно для реализации всех необходимых функций программной системы…. Для этого необходимо выделять отдельные процессы и переносить их на другие рабочие станции. Типичным примером являются сервера баз данных. Серьезный сервер баз данных требует определенных характеристик аппаратного обеспечения сервера, структуры файловой системы, свойств операционной системы и т. п.</p>
<p>Другим примером, когда необходимо выделять функции в отдельные процессы, выступает процесс интеграции разрабатываемой программной системы со сторонними приложениями. …</p>
<p>Здесь мы рассмотрим пример выделения компоненты в отдельный процесс…</p>
</section>
<section id="sec:xmlrpc" class="level3">
<h3><span class="header-section-number">7.7.2</span> Протокол и библиотеки XML-RPC</h3>
<p>RPC stands for Remote Procedure Call. As its name indicates, it is a mechanism to call a procedure or a function available on a remote computer. RPC is a much older technology than the Web. Effectively, RPC gives developers a mechanism for defining interfaces that can be called over a network. These interfaces can be as simple as a single function call or as complex as a large API. What is XML&quot;=RPC ?</p>
<p>XML-RPC is among the simplest and most foolproof web service approaches that makes it easy for computers to call procedures on other computers.</p>
<p>XML-RPC permits programs to make function or procedure calls across a network.</p>
<p>XML-RPC uses the HTTP protocol to pass information from a client computer to a server computer.</p>
<p>XML-RPC uses a small XML vocabulary to describe the nature of requests and responses.</p>
<p>XML-RPC client specifies a procedure name and parameters in the XML request, and the server returns either a fault or a response in the XML response.</p>
<p>XML-RPC parameters are a simple list of types and content - structs and arrays are the most complex types available.</p>
<p>XML-RPC has no notion of objects and no mechanism for including information that uses other XML vocabulary.</p>
<p>With XML-RPC and web services, however, the Web becomes a collection of procedural connections where computers exchange information along tightly bound paths.</p>
<p>XML-RPC emerged in early 1998; it was published by UserLand Software and initially implemented in their Frontier product.</p>
<p>Why XML-RPC ?</p>
<p>If you need to integrate multiple computing environments, but don’t need to share complex data structures directly, you will find that XML-RPC lets you establish communications quickly and easily.</p>
<p>Even if you work within a single environment, you may find that the RPC approach makes it easy to connect programs that have different data models or processing expectations and that it can provide easy access to reusable logic.</p>
<p>XML-RPC is an excellent tool for establishing a wide variety of connections between computers.</p>
<p>XML-RPC offers integrators an opportunity to use a standard vocabulary and approach for exchanging information.</p>
<p>XML-RPC’s most obvious field of application is connecting different kinds of environments, allowing Java to talk with Perl, Python, ASP, and so on.</p>
<p>XML-RPC Technical Overview</p>
<p>XML-RPC consists of three relatively small parts:</p>
<p>XML-RPC data model : A set of types for use in passing parameters, return values, and faults (error messages).</p>
<p>XML-RPC request structures : An HTTP POST request containing method and parameter information.</p>
<p>XML-RPC response structures : An HTTP response that contains return values or fault information.</p>
<p>We will study all these three components in the next three chapters.</p>
</section>
<section id="sec:distrimpl" class="level3">
<h3><span class="header-section-number">7.7.3</span> Реализация распределенного приложения</h3>
</section>
</section>
</section>
<section id="интерфейсы-пользователя" class="level1">
<h1><span class="header-section-number">8</span> Интерфейсы пользователя</h1>
<p>Как и любую другую программная компонента интерфейс пользователя тоже имеет смысл разрабатывать как компоненту приложения. Естественно здесь есть свои особенности.</p>
<section id="sec:MVC" class="level2">
<h2><span class="header-section-number">8.1</span> Шаблон проектирования Model-View-Controller</h2>
<p>The Model-View-Control (MVC) pattern, originally formulated in the late 1970s, is a software architecture pattern built on the basis of keeping the presentation of data separate from the methods that interact with the data. In theory, a well-developed MVC system should allow a front-end developer and a back-end developer to work on the same system without interfering, sharing, or editing files either party is working on.</p>
<p>Even though MVC was originally designed for personal computing, it has been adapted and is widely used by web developers due to its emphasis on separation of concerns, and thus indirectly, reusable code. The pattern encourages the development of modular systems, allowing developers to quickly update, add, or even remove functionality.</p>
<p>In this article, I will go the basic principles of MVC, a run through the definition of the pattern and a quick example of MVC in PHP. This is definitely a read for anyone who has never coding with MVC before or those wanting to brush up on previous MVC development skills. Understanding MVC</p>
<p>The pattern’s title is a collation of its three core parts: Model, View, and Controller. A visual representation of a complete and correct MVC pattern looks like the following diagram:</p>
<p>MVC Process</p>
<p>The image shows the single flow layout of data, how it’s passed between each component, and finally how the relationship between each component works. Model</p>
<p>The Model is the name given to the permanent storage of the data used in the overall design. It must allow access for the data to be viewed, or collected and written to, and is the bridge between the View component and the Controller component in the overall pattern.</p>
<p>One important aspect of the Model is that it’s technically “blind” – by this I mean the model has no connection or knowledge of what happens to the data when it is passed to the View or Controller components. It neither calls nor seeks a response from the other parts; its sole purpose is to process data into its permanent storage or seek and prepare data to be passed along to the other parts.</p>
<p>The Model, however, cannot simply be summed up as a database, or a gateway to another system which handles the data process. The Model must act as a gatekeeper to the data itself, asking no questions but accepting all requests which comes its way. Often the most complex part of the MVC system, the Model component is also the pinnacle of the whole system since without it there isn’t a connection between the Controller and the View. View</p>
<p>The View is where data, requested from the Model, is viewed and its final output is determined. Traditionally in web apps built using MVC, the View is the part of the system where the HTML is generated and displayed. The View also ignites reactions from the user, who then goes on to interact with the Controller. The basic example of this is a button generated by a View, which a user clicks and triggers an action in the Controller.</p>
<p>There are some misconceptions held about View components, particularly by web developers using the MVC pattern to build their application. For example, many mistake the View as having no connection whatsoever to the Model and that all of the data displayed by the View is passed from the Controller. In reality, this flow disregards the theory behind the MVC pattern completely. Fabio Cevasco’s article The CakePHP Framework: Your First Bite demonstrates this confused approach to MVC in the CakePHP framework, an example of the many non-traditional MVC PHP frameworks available:</p>
<p>“It is important to note that in order to correctly apply the MVC architecture, there must be no interaction between models and views: all the logic is handled by controllers“</p>
<p>Furthermore, the description of Views as a template file is inaccurate. However, as Tom Butler points out, this is not one person’s fault but a multitude of errors by a multitude of developers which result in developers learning MVC incorrectly. They then go on to educate others incorrectly. The View is really much more than just a template, however modern MVC inspired frameworks have bastardised the view almost to the point that no one really cares whether or not a framework actually adheres to the correct MVC pattern or not.</p>
<p>It’s also important to remember that the View part is never given data by the Controller. As I mentioned when discussing the Model, there is no direct relationship between the View and the Controller without the Model in between them. Controller</p>
<p>The final component of the triad is the Controller. Its job is to handle data that the user inputs or submits, and update the Model accordingly. The Controller’s life blood is the user; without user interactions, the Controller has no purpose. It is the only part of the pattern the user should be interacting with.</p>
<p>The Controller can be summed up simply as a collector of information, which then passes it on to the Model to be organized for storage, and does not contain any logic other than that needed to collect the input. The Controller is also only connected to a single View and to a single Model, making it a one way data flow system, with handshakes and signoffs at each point of data exchange.</p>
<p>It’s important to remember the Controller is only given tasks to perform when the user interacts with the View first, and that each Controller function is a trigger, set off by the user’s interaction with the View. The most common mistake made by developers is confusing the Controller for a gateway, and ultimately assigning it functions and responsibilities that the View should have (this is normally a result of the same developer confusing the View component simply as a template). Additionally, it’s a common mistake to give the Controller functions that give it the sole responsibility of crunching, passing, and processing data from the Model to the View, whereas in the MVC pattern this relationship should be kept between the Model and the View. MVC in PHP</p>
<p>It is possible to write a web application in PHP whose architecture is based on the MVC pattern. Let’s start with a bare bones example:</p>
<p>We have our project started with some very basic classes for each part of the pattern. Now we need to set up the relationships between them:</p>
<p>As you can see in the example above, we don’t have any Controller-specific functionality because we don’t have any user interactions defined with our application. The View holds all of the functionality as the example is purely for display purposes.</p>
<p>Let’s now expand the example to show how we would add functionality to the controller, thereby adding interactivity to the application:</p>
<p>We’ve enhanced the application with some basic functionality. Setting up the relationship between our components now looks like this:</p>
<p>Run the code and when you click on the link you’ll be able to see the string change its data. Conclusion</p>
<p>We’ve covered the basic theory behind the MVC pattern and have produced a very basic MVC application, but we still have a long way to go before we get into any nitty-gritty functionality.</p>
<p>Next up in the series we’ll cover some of the choices you face when trying to create a true MVC application on the web in PHP. Stay tuned!</p>
</section>
<section id="sec:gtk" class="level2">
<h2><span class="header-section-number">8.2</span> Библиотека GTK+</h2>
<p>GTK+ is a widget toolkit. Each user interface created by GTK+ consists of widgets. This is implemented in C using GObject, an object-oriented framework for C. Widgets are organized in a hierachy. The window widget is the main container. The user interface is then built by adding buttons, drop-down menus, input fields, and other widgets to the window. If you are creating complex user interfaces it is recommended to use GtkBuilder and its GTK-specific markup description language, instead of assembling the interface manually. You can also use a visual user interface editor, like Glade.</p>
<p>GTK+ is event-driven. The toolkit listens for events such as a click on a button, and passes the event to your application.</p>
<p>This chapter contains some tutorial information to get you started with GTK+ programming. It assumes that you have GTK+, its dependencies and a C compiler installed and ready to use. If you need to build GTK+ itself first, refer to the Compiling the GTK+ libraries section in this reference.</p>
<p>In a GTK+ application, the purpose of the main() function is to create a GtkApplication object and run it. In this example a GtkApplication pointer named app is called and then initialized using gtk_application_new().</p>
<p>When creating a GtkApplication you need to pick an application identifier (a name) and input to gtk_application_new() as parameter. For this example org.gtk.example is used but for choosing an identifier for your application see this guide. Lastly gtk_application_new() takes a GApplicationFlags as input for your application, if your application would have special needs.</p>
<p>Next the activate signal is connected to the activate() function above the main() functions. The activate signal will be sent when your application is launched with g_application_run() on the line below. The gtk_application_run() also takes as arguments the pointers to the command line arguments counter and string array; this allows GTK+ to parse specific command line arguments that control the behavior of GTK+ itself. The parsed arguments will be removed from the array, leaving the unrecognized ones for your application to parse.</p>
<p>Within g_application_run the activate() signal is sent and we then proceed into the activate() function of the application. Inside the activate() function we want to construct our GTK window, so that a window is shown when the application is launched. The call to gtk_application_window_new() will create a new GtkWindow and store it inside the window pointer. The window will have a frame, a title bar, and window controls depending on the platform.</p>
<p>A window title is set using gtk_window_set_title(). This function takes a GtkWindow* pointer and a string as input. As our window pointer is a GtkWidget pointer, we need to cast it to GtkWindow*. But instead of casting window via (GtkWindow*), window can be cast using the macro GTK_WINDOW(). GTK_WINDOW() will check if the pointer is an instance of the GtkWindow class, before casting, and emit a warning if the check fails. More information about this convention can be found here.</p>
<p>Finally the window size is set using gtk_window_set_default_size and the window is then shown by GTK via gtk_widget_show_all().</p>
<p>When you exit the window, by for example pressing the X, the g_application_run() in the main loop returns with a number which is saved inside an integer named “status”. Afterwards, the GtkApplication object is freed from memory with g_object_unref(). Finally the status integer is returned and the GTK application exits.</p>
<p>While the program is running, GTK+ is receiving events. These are typically input events caused by the user interacting with your program, but also things like messages from the window manager or other applications. GTK+ processes these and as a result, signals may be emitted on your widgets. Connecting handlers for these signals is how you normally make your program do something in response to user input.</p>
<p>The following example is slightly more complex, and tries to showcase some of the capabilities of GTK+.</p>
<p>In the long tradition of programming languages and libraries, it is called Hello, World.</p>
<p>As seen above, example-1.c builds further upon example-0.c by adding a button to our window, with the label “Hello World”. Two new GtkWidget pointers are declared to accomplish this, button and button_box. The button_box variable is created to store a GtkButtonBox which is GTK+’s way of controlling the size and layout of buttons. The GtkButtonBox is created and assigned to gtk_button_box_new() which takes a GtkOrientation enum as parameter. The buttons which this box will contain can either be stored horizontally or vertically but this does not matter in this particular case as we are dealing with only one button. After initializing button_box with horizontal orientation, the code adds the button_box widget to the window widget using gtk_container_add().</p>
<p>Next the button variable is initialized in similar manner. gtk_button_new_with_label() is called which returns a GtkButton to be stored inside button. Afterwards button is added to our button_box. Using g_signal_connect the button is connected to a function in our app called print_hello(), so that when the button is clicked, GTK will call this function. As the print_hello() function does not use any data as input, NULL is passed to it. print_hello() calls g_print() with the string “Hello World” which will print Hello World in a terminal if the GTK application was started from one.</p>
<p>After connecting print_hello(), another signal is connected to the “clicked” state of the button using g_signal_connect_swapped(). This functions is similar to a g_signal_connect() with the difference lying in how the callback function is treated. g_signal_connect_swapped() allow you to specify what the callback function should take as parameter by letting you pass it as data. In this case the function being called back is gtk_widget_destroy() and the window pointer is passed to it. This has the effect that when the button is clicked, the whole GTK window is destroyed. In contrast if a normal g_signal_connect() were used to connect the “clicked” signal with gtk_widget_destroy(), then the button itself would have been destroyed, not the window. More information about creating buttons can be found here.</p>
<p>The rest of the code in example-1.c is identical to example-0.c. Next section will elaborate further on how to add several GtkWidgets to your GTK application.</p>
<section id="sec:glade" class="level3">
<h3><span class="header-section-number">8.2.1</span> Дизайнер интерфесов Glade</h3>
<p>Мы не будем далее вдаваться в подробности функционирования элементов управления библиотеки, а воспользуемся дизайнером интерфейсов Glade (лезвие).</p>
<p>Glade is a RAD tool to enable quick and easy development of user interfaces for the GTK+ toolkit and the GNOME desktop environment.</p>
<p>The user interfaces designed in Glade are saved as XML, and by using the GtkBuilder GTK+ object these can be loaded by applications dynamically as needed.</p>
<p>By using GtkBuilder, Glade XML files can be used in numerous programming languages including C, C++, C#, Vala, Java, Perl, Python,and others.</p>
<p>OK, since it looks like you gave me a chance to show how I usually work, let’s start.</p>
<p>Today’s work will be separated into two sections:</p>
<p>Creating “blueprint” of our application’s GUI based on requirements. Writing down widget tree, based on blueprint from previous section.</p>
<p>Now, what are requirements for our application. Obviously, it needs to be able to display data in numeric and graphic form. We also want to be able to add new, delete, rearrange and modify points. We also want to be able to display point markers, connecting lines or both on the chart. And this is about it for initial requirements. We’ll leave some space for future expansion in our plans, just in case if we decide to add anything to it later.</p>
<p>Now comes the fun part - drawing interface. I prefer to do this on paper using pencil, but feel free to experiment. For sample project, I came up with this design:</p>
<p>Mock-up of interface</p>
<p>Dark gray rectangles represent scroll bars. What do you think? Do I suck as interface designer or do I really suck as interface designer?;)</p>
<p>Now for the last thing we need to do today: writing down widget tree. In GTK+, everything starts with top-level GtkWindow, which will serve as a root of our widget tree.</p>
<p>Our main window will be split into four vertical sections: one for menu bar, one for tool bar, one for central part where all the action will happen and last one for status bar. Since our main window (GtkWindow) can hold only one child widget, we need GtkVBox in which we will pack, from bottom to top: GtkStatusbar, widget for central part, GtkToolbar and GtkMenuBar. Why did I say that we’ll be packing from bottom? I’ll explain this in next post, when we’ll be playing with Glade3.</p>
<p>Central part will need to be further divided into horizontal sections: one for data table, one for point controls and one for display area. So this will require GtkHBox. What widgets will we need inside it? For data table we’ll use GtkTreeView, which is packed inside GtkScrolledWindow to enable scrolling. For point controls we’ll need GtkVButtonBox that will house our buttons.</p>
<p>Now for the display area. We again have two parts: upper part that will actually display chart; and bottom part that will hold check buttons. So we’ll need another GtkVBox to hold the whole section. Bottom part will be represented by GtkHButtonBox with GtkToggleButtons, while upper part deserves another paragraph;).</p>
<p>Why another paragraph? Because we’ll need to add quite a few widgets in order to get desired layout. As you can see on my drawing, I want to have graph area centered in display part. In order to be able to add zoom to chart area, we also need some kind of scrolling widget. And how to assemble all this together? First we’ll add GtkScrolledWindow to GtkVBox from previous paragraph. To make contents scrollable, we need to pack GtkViewport inside GtkScrolledWindow. Inside GtkViewport we’ll add GtkAlignment, which will take care of centering the chart area. Inside GtkAlignment we’ll add GtkFrame, which will add a shadow to chart area. Finally, we add GtkDrawing area inside GtkFrame. And we’re done.</p>
<p>There is just one thing I would like to explain today. When adding GtkTreeView to GtkScrolledWindow I haven’t used GtkViewport as an adapter widget, while adding GtkAlignment did require one. Why? When it comes to GtkScrolledWindow, there are two kinds of widgets: the ones that support scrolling natively and the ones that don’t. GtkTreeView, GtkTextView, GtkIconView and GtkViewport do support scrolling and can be added into GtkScrolledWindow directly. All other widgets need GtkViewport as an adapter.</p>
<p>I hope this starting lesson wasn’t too tough and you’ll join me next time when we’ll fire up Glade3 and do some property mangling.</p>
</section>
<section id="sec:gladeint" class="level3">
<h3><span class="header-section-number">8.2.2</span> Конструирование интерфейса</h3>
<p>In this part of tutorial, we’ll create application’s GUI using Glade3 according to our blueprint and widget tree. To check how our GUI looks like, we’ll also write a minimalistic application.</p>
<p>I’ll be using Glade3-3.6.7 in this tutorial, but any version from 3.6 series will do. Our project will be saved as a GtkBuilder project and we’ll use GtkBuilder to create our interface at runtime. Glade3-3.4.5 cannot be used when following this tutorial, since we’ll use some new features of Glade3 that were introduced in 3.6 series.</p>
<p>Contents</p>
<p>Glade3 tutorial (1) - Introduction Glade3 tutorial (2) - Constructing interface Glade3 tutorial (3) - Size negotiation Glade3 tutorial (4) - GtkTreeView data backend Glade3 tutorial (5) - Modifying widget tree Glade3 tutorial (6) - Signals</p>
<p>Constructing interface</p>
<p>I tried to document each step in GUI creation with screenshot and instructions. Video of the actual process can be found on ScreenToaster site.</p>
<p>When you start Glade3 without opening project, you’re greeted by two windows: main application window that we’ll be using to create interface and preferences dialog that lets you set some project settings.</p>
<p>You can see from this screen that we’ll be using GtkBuilder project format with object names being unique across the whole project. We won’t be using any images in this project, so resource location is not important to us. Lastly, this project will be compatible with GTK+ &gt;= 2.14, which should make it usable on most distributions out there. You can check your project for any incompatibilities from this dialog too, but since we’re starting new poject, this is not needed. Last thing is to click Close and we’re done with initial setup.</p>
<p>Now it’s time to place initial toplevel window into project. Just click “Window” icon in “Toplevels” category and you should see something like this:</p>
<p>Now we’ll set window title to “Charter” and default size to 600 x 400 px.</p>
<p>Now we need to switch to “Common” tab in properties section and set “Border width” to 6 px.</p>
<p>Last thing we need to do with main window is to connect gtk_main_quit function to “destroy” signal. This will close our application when we’ll click on close button. I’ll talk more about signals in one of the following posts, so no more details will be given here.</p>
<p>With our main window finished, we need to add GtkVBox to it. In previous post, we planed to add four widgets inside this box, but since menu bar and tool bar will be created using GtkUIManager and manually inserted from code, we only need two. So when we’re asked about number of elements, we enter 2.</p>
<p>Now we’ll add status bar to application. Click status bar icon and insert it into bottom of the box. Your GUI should look something like this:</p>
<p>Now we need to make sure that status bar is packed from bottom to top. Why is this important? If we would to pack status bar from top to bottom, it would be impossible to add menu and tool bar at the top of the application. How to ensure that status bar is packed from bottom to top? Select “Packing tab” and select “End” as pack type and set “Position” to 0. What does this do? It instructs Glade to pack status bar as first element from bottom to top.</p>
<p>Now run this code and be amazed;). Not too bad, but nothing special either. Try resizing window to see how compartments behave when resized. Do you like it? I don’t either, so join me next time when we’ll be dealing with space alocation/requisition in detail.</p>
<p>And we’re done. If you need more detailed process of clicking/changing properties, head to ScreenToaster site, where you can watch video of the whole thing. Hope you’ll find it useful.</p>
<p>Finished glade file can be obtained from here: tut.glade.</p>
</section>
</section>
<section id="sec:gtkcontroller" class="level2">
<h2><span class="header-section-number">8.3</span> Разработка контроллера</h2>
<p>Контроллер по своей сути является мультиадаптером компонент модели (Model) и интерфейса (View), причем адаптером, который ничего не делает, кроме обеспечения взаимодействия модели и интерфейса. То есть контроллер – это обработчик (handler) и не более того. Запрограммируем его в соответствии с этим.</p>
</section>
</section>
<section id="пример-приложения-id49" class="level1">
<h1><span class="header-section-number">9</span> Пример приложения [id49]</h1>
<p>DUadmonitionnoteDUadmonitionnote</p>
<p>В этом разделе демонстрируется проектирование оконного приложения, используя библиотеку PyGTK для реализации интерфейса пользователя совместно с ZCA. Приложение использует два различных механизма постоянного хранения объектов. Первый – это объектно&quot;=ориентированная база данных ZODB, а вторая – реляционная база данных SQLite. Однако, при установке конкретного приложения только одна база данных будет использоваться. Использование двух механизмов постоянного хранения объектов позволяет продемонстрировать как ZCA собирает компоненты и связывает их в единое приложение. В сходном коде приложения преобладает реализация интерфейса пользователя, основывающаяся не библиотеке PyGTK.</p>
<p>При разработке больших приложений удобно использовать ZCA, так как он обеспечивает и управляемость процессом разработки комплексных приложений, и возможность расширения набора функций программной системы, встраивания и замену (pluggablity) компонент. Непосредственное использование объектов Python, как правило, не создает подобных условий.</p>
<p>Вообще ZCA может с одинаковым успехом использоваться как для разработки ВЕБ-, так и для оконных и других приложений. В каждом конкретно случае необходимо определиться с принципом организации регистрации компонент: в каком модуле какие компоненты будут регистрироваться. В рассматриваемом примере функции регистрации компонент задаются в отдельных модулях, и, затем, через импорт этих модулей производится их регистрация. Главный регистрирующий модуль компоненты – <span><em>register.py</em></span>.</p>
<p>Исходный код готового приложения находится по следующему адресу: <a href="http://www.muthukadan.net/downloads/zcalib.tar.bz2" class="uri">http://www.muthukadan.net/downloads/zcalib.tar.bz2</a></p>
<section id="функции-приложения-id51" class="level2">
<h2><span class="header-section-number">9.1</span> Функции приложения [id51]</h2>
<p>Приложение, о котором идет речь – это система управления библиотекой с некоторым минимальным набором функций. Основные требования к приложению следующие:</p>
<ul>
<li><p>Добавление читателей, идентифицируя их уникальным номером и именем.</p></li>
<li><p>Добавление книг, помечая их баркодом, и указывая автора и название.</p></li>
<li><p>Выдача книг на руки читателям.</p></li>
<li><p>Учет книг, возвращенных читателями.</p></li>
</ul>
<p>Дизайн интерфейса пользователя сделаны таким, чтобы основные функции были доступны из одного окна. Основное окно имеет следующий вид:</p>
<p>В приложении создано специальное окно для управления читателями. При помощи этого окна реализуются функции <em>добавление</em>, <em>обновление</em> данных читателя и <em>удаление</em> читателя:</p>
<p>Аналогично предыдущему окну, интерфейс управления базой данных книг позволяет <em>добавлять</em>, <em>редактировать</em> данные и <em>удалять</em> книги:</p>
<p>Окно управления книжным фондом реализует функции <em>выдачи</em> и <em>возврата</em> книг читателями:</p>
</section>
<section id="обзор-кода-pygtk-pygtk" class="level2">
<h2><span class="header-section-number">9.2</span> Обзор кода PyGTK [pygtk]</h2>
<p>Почти все приложение – это программный код, использующий PyGTK. Структура программ реализации всех окон схожа, общий вид окон и приложения разработан при помощи дизайнера оконных интерфейсов Glade GUI builder. Чтобы использовать разработанный интерфейс в программном коде необходимо основным элементам управления поименовать. В главном меню все пункты поименованы следующим образом: “circulation”, “catalog”, “member”, “quit” и “about”.</p>
<p>Класс <code>gtk.glade.XML</code> используется для трансляции и интерпретации файлов glade, в результате его деятельности создаются элементы управления интерфейса пользователя. Вот пример трансляции и получения доступа к элементу управления:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> gtk.glade
xmlobj <span class="op">=</span> gtk.glade.XML(<span class="st">&#39;/path/to/file.glade&#39;</span>)
widget <span class="op">=</span> xmlobj.get_widget(<span class="st">&#39;widget_name&#39;</span>)</code></pre></div>
<p>В модуле mainwindow.py находится код, аналогичный следующему:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">curdir <span class="op">=</span> os.path.abspath(os.path.dirname(<span class="va">__file__</span>))
xml <span class="op">=</span> os.path.join(curdir, <span class="st">&#39;glade&#39;</span>, <span class="st">&#39;mainwindow.glade&#39;</span>)
xmlobj <span class="op">=</span> gtk.glade.XML(xml)

<span class="va">self</span>.mainwindow <span class="op">=</span> xmlobj.get_widget(<span class="st">&#39;mainwindow&#39;</span>)</code></pre></div>
<p>Название элемента управления, соответствующего главному окну, – <span><em>mainwindow</em></span>. Аналогичным образом можно получать доступ и к другим элементам управления.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">circulation <span class="op">=</span> xmlobj.get_widget(<span class="st">&#39;circulation&#39;</span>)
member <span class="op">=</span> xmlobj.get_widget(<span class="st">&#39;member&#39;</span>)
quit <span class="op">=</span> xmlobj.get_widget(<span class="st">&#39;quit&#39;</span>)
catalog <span class="op">=</span> xmlobj.get_widget(<span class="st">&#39;catalog&#39;</span>)
about <span class="op">=</span> xmlobj.get_widget(<span class="st">&#39;about&#39;</span>)</code></pre></div>
<p>Затем с элементами управления связываются обработчики возникающих событий.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="va">self</span>.mainwindow.<span class="ex">connect</span>(<span class="st">&#39;delete_event&#39;</span>, <span class="va">self</span>.delete_event)
quit.<span class="ex">connect</span>(<span class="st">&#39;activate&#39;</span>, <span class="va">self</span>.delete_event)
circulation.<span class="ex">connect</span>(<span class="st">&#39;activate&#39;</span>, <span class="va">self</span>.on_circulation_activate)
member.<span class="ex">connect</span>(<span class="st">&#39;activate&#39;</span>, <span class="va">self</span>.on_member_activate)
catalog.<span class="ex">connect</span>(<span class="st">&#39;activate&#39;</span>, <span class="va">self</span>.on_catalog_activate)
about.<span class="ex">connect</span>(<span class="st">&#39;activate&#39;</span>, <span class="va">self</span>.on_about_activate)</code></pre></div>
<p>Событие <span><em>delete_event</em></span> возникает, когда пользователь пытается закрыть окно при помощи соответствующей кнопки. Событие <span><em>activate</em></span> инициируется, когда пользователь выбрал какой&quot;=либо пункт меню. В качестве обработчиков событий выступают функции, вызываемые в момент возникновения события.</p>
<p>В приведенном фрагменте кода видно, что событие <span><em>delete_event</em></span> главного окна соединено с методом <span><em>on_delete_event</em></span>. Событие <span><em>activate</em></span> элемента <span><em>quit</em></span> также соединено с этим же методом.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> on_delete_event(<span class="va">self</span>, <span class="op">*</span>args):
    gtk.main_quit()</code></pre></div>
<p>Функция <span><em>on_delete_event</em></span> просто вызывает функцию <span><em>main_quit</em></span>.</p>
</section>
<section id="исходный-код-приложения-id52" class="level2">
<h2><span class="header-section-number">9.3</span> Исходный код приложения [id52]</h2>
<p>Модуль <span><em>zcalib.py</em></span>:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> registry
<span class="im">import</span> mainwindow

<span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&#39;__main__&#39;</span>:
    registry.initialize()
    <span class="cf">try</span>:
        mainwindow.main()
    <span class="cf">except</span> <span class="pp">KeyboardInterrupt</span>:
        <span class="im">import</span> sys
        sys.exit(<span class="dv">1</span>)</code></pre></div>
<p>В тексте импортируются модули <span><em>registry</em></span> и <span><em>mainwindow</em></span>. Затем модуль <span><em>registry</em></span> инициализируется и вызывается функция <span><em>main</em></span> модуля <span><em>mainwindow</em></span>. Если пользователь попытается завершить программу при помощи комбинации клавиш <span><em>Ctrl+C</em></span>, программа закончит свое исполнение. Чтобы заблокировать такое поведение программы, перехватим исключение <span><em>KeyboardInterrupt</em></span>.</p>
<p>Модуль <span><em>registry.py</em></span>:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> sys
<span class="im">from</span> zope.component <span class="im">import</span> getGlobalSiteManager

<span class="im">from</span> interfaces <span class="im">import</span> IMember
<span class="im">from</span> interfaces <span class="im">import</span> IBook
<span class="im">from</span> interfaces <span class="im">import</span> ICirculation
<span class="im">from</span> interfaces <span class="im">import</span> IDbOperation


<span class="kw">def</span> initialize_rdb():
    <span class="im">from</span> interfaces <span class="im">import</span> IRelationalDatabase
    <span class="im">from</span> relationaldatabase <span class="im">import</span> RelationalDatabase
    <span class="im">from</span> member <span class="im">import</span> MemberRDbOperation
    <span class="im">from</span> catalog <span class="im">import</span> BookRDbOperation
    <span class="im">from</span> circulation <span class="im">import</span> CirculationRDbOperation

    gsm <span class="op">=</span> getGlobalSiteManager()
    db <span class="op">=</span> RelationalDatabase()
    gsm.registerUtility(db, IRelationalDatabase)

    gsm.registerAdapter(MemberRDbOperation,
                        (IMember,),
                        IDbOperation)

    gsm.registerAdapter(BookRDbOperation,
                        (IBook,),
                        IDbOperation)

    gsm.registerAdapter(CirculationRDbOperation,
                        (ICirculation,),
                        IDbOperation)

<span class="kw">def</span> initialize_odb():
    <span class="im">from</span> interfaces <span class="im">import</span> IObjectDatabase
    <span class="im">from</span> objectdatabase <span class="im">import</span> ObjectDatabase
    <span class="im">from</span> member <span class="im">import</span> MemberODbOperation
    <span class="im">from</span> catalog <span class="im">import</span> BookODbOperation
    <span class="im">from</span> circulation <span class="im">import</span> CirculationODbOperation

    gsm <span class="op">=</span> getGlobalSiteManager()
    db <span class="op">=</span> ObjectDatabase()
    gsm.registerUtility(db, IObjectDatabase)

    gsm.registerAdapter(MemberODbOperation,
                        (IMember,),
                        IDbOperation)

    gsm.registerAdapter(BookODbOperation,
                        (IBook,),
                        IDbOperation)

    gsm.registerAdapter(CirculationODbOperation,
                        (ICirculation,),
                        IDbOperation)

<span class="kw">def</span> check_use_relational_db():
    use_rdb <span class="op">=</span> <span class="va">False</span>
    <span class="cf">try</span>:
        arg <span class="op">=</span> sys.argv[<span class="dv">1</span>]
        <span class="cf">if</span> arg <span class="op">==</span> <span class="st">&#39;-r&#39;</span>:
            <span class="cf">return</span> <span class="va">True</span>
    <span class="cf">except</span> <span class="pp">IndexError</span>:
        <span class="cf">pass</span>
    <span class="cf">return</span> use_rdb

<span class="kw">def</span> initialize():
    use_rdb <span class="op">=</span> check_use_relational_db()
    <span class="cf">if</span> use_rdb:
        initialize_rdb()
    <span class="cf">else</span>:
        initialize_odb()</code></pre></div>
<p>Обратите внимание на функцию <span><em>initialize</em></span>, которая вызывается в главном модуле <span><em>zcalib.py</em></span>. Функция сначала узнает, какую базу данных надо использовать: реляционную (RDB) или объектную (ODB). Указание варианта базы данных осуществляется при помощи функции <span><em>check_use_relational_db</em></span>. Если в командной строке задать опцию <span><em>-r</em></span>, будет запущена <span><em>initialize_rdb</em></span>, иначе – <span><em>initialize_odb</em></span>. Если выбрана RDB, то будут установлены компоненты, реализующие механизм RDB. В обратном случае – компоненты для ODB.</p>
<p>Модуль <span><em>mainwindow.py</em></span>:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> os
<span class="im">import</span> gtk
<span class="im">import</span> gtk.glade

<span class="im">from</span> circulationwindow <span class="im">import</span> circulationwindow
<span class="im">from</span> catalogwindow <span class="im">import</span> catalogwindow
<span class="im">from</span> memberwindow <span class="im">import</span> memberwindow

<span class="kw">class</span> MainWindow(<span class="bu">object</span>):

    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):
        curdir <span class="op">=</span> os.path.abspath(os.path.dirname(<span class="va">__file__</span>))
        xml <span class="op">=</span> os.path.join(curdir, <span class="st">&#39;glade&#39;</span>, <span class="st">&#39;mainwindow.glade&#39;</span>)
        xmlobj <span class="op">=</span> gtk.glade.XML(xml)

        <span class="va">self</span>.mainwindow <span class="op">=</span> xmlobj.get_widget(<span class="st">&#39;mainwindow&#39;</span>)
        circulation <span class="op">=</span> xmlobj.get_widget(<span class="st">&#39;circulation&#39;</span>)
        member <span class="op">=</span> xmlobj.get_widget(<span class="st">&#39;member&#39;</span>)
        quit <span class="op">=</span> xmlobj.get_widget(<span class="st">&#39;quit&#39;</span>)
        catalog <span class="op">=</span> xmlobj.get_widget(<span class="st">&#39;catalog&#39;</span>)
        about <span class="op">=</span> xmlobj.get_widget(<span class="st">&#39;about&#39;</span>)

        <span class="va">self</span>.mainwindow.<span class="ex">connect</span>(<span class="st">&#39;delete_event&#39;</span>, <span class="va">self</span>.delete_event)
        quit.<span class="ex">connect</span>(<span class="st">&#39;activate&#39;</span>, <span class="va">self</span>.delete_event)

        circulation.<span class="ex">connect</span>(<span class="st">&#39;activate&#39;</span>, <span class="va">self</span>.on_circulation_activate)
        member.<span class="ex">connect</span>(<span class="st">&#39;activate&#39;</span>, <span class="va">self</span>.on_member_activate)
        catalog.<span class="ex">connect</span>(<span class="st">&#39;activate&#39;</span>, <span class="va">self</span>.on_catalog_activate)
        about.<span class="ex">connect</span>(<span class="st">&#39;activate&#39;</span>, <span class="va">self</span>.on_about_activate)

    <span class="kw">def</span> delete_event(<span class="va">self</span>, <span class="op">*</span>args):
        gtk.main_quit()

    <span class="kw">def</span> on_circulation_activate(<span class="va">self</span>, <span class="op">*</span>args):
        circulationwindow.show_all()

    <span class="kw">def</span> on_member_activate(<span class="va">self</span>, <span class="op">*</span>args):
        memberwindow.show_all()

    <span class="kw">def</span> on_catalog_activate(<span class="va">self</span>, <span class="op">*</span>args):
        catalogwindow.show_all()

    <span class="kw">def</span> on_about_activate(<span class="va">self</span>, <span class="op">*</span>args):
        <span class="cf">pass</span>

    <span class="kw">def</span> run(<span class="va">self</span>):
        <span class="va">self</span>.mainwindow.show_all()

<span class="kw">def</span> main():
    mainwindow <span class="op">=</span> MainWindow()
    mainwindow.run()
    gtk.main()</code></pre></div>
<p>Функция <span><em>main</em></span> создает экземпляр класса <span><em>MainWindow</em></span>, который инициализирует все элементы управления.</p>
<p>Модуль <span><em>memberwindow.py</em></span>:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> os
<span class="im">import</span> gtk
<span class="im">import</span> gtk.glade

<span class="im">from</span> zope.component <span class="im">import</span> getAdapter

<span class="im">from</span> components <span class="im">import</span> Member
<span class="im">from</span> interfaces <span class="im">import</span> IDbOperation


<span class="kw">class</span> MemberWindow(<span class="bu">object</span>):

    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):
        curdir <span class="op">=</span> os.path.abspath(os.path.dirname(<span class="va">__file__</span>))
        xml <span class="op">=</span> os.path.join(curdir, <span class="st">&#39;glade&#39;</span>, <span class="st">&#39;memberwindow.glade&#39;</span>)
        xmlobj <span class="op">=</span> gtk.glade.XML(xml)

        <span class="va">self</span>.memberwindow <span class="op">=</span> xmlobj.get_widget(<span class="st">&#39;memberwindow&#39;</span>)
        <span class="va">self</span>.number <span class="op">=</span> xmlobj.get_widget(<span class="st">&#39;number&#39;</span>)
        <span class="va">self</span>.name <span class="op">=</span> xmlobj.get_widget(<span class="st">&#39;name&#39;</span>)
        add <span class="op">=</span> xmlobj.get_widget(<span class="st">&#39;add&#39;</span>)
        update <span class="op">=</span> xmlobj.get_widget(<span class="st">&#39;update&#39;</span>)
        delete <span class="op">=</span> xmlobj.get_widget(<span class="st">&#39;delete&#39;</span>)
        close <span class="op">=</span> xmlobj.get_widget(<span class="st">&#39;close&#39;</span>)
        <span class="va">self</span>.treeview <span class="op">=</span> xmlobj.get_widget(<span class="st">&#39;treeview&#39;</span>)

        <span class="va">self</span>.memberwindow.<span class="ex">connect</span>(<span class="st">&#39;delete_event&#39;</span>, <span class="va">self</span>.on_delete_event)
        add.<span class="ex">connect</span>(<span class="st">&#39;clicked&#39;</span>, <span class="va">self</span>.on_add_clicked)
        update.<span class="ex">connect</span>(<span class="st">&#39;clicked&#39;</span>, <span class="va">self</span>.on_update_clicked)
        delete.<span class="ex">connect</span>(<span class="st">&#39;clicked&#39;</span>, <span class="va">self</span>.on_delete_clicked)
        close.<span class="ex">connect</span>(<span class="st">&#39;clicked&#39;</span>, <span class="va">self</span>.on_delete_event)

        <span class="va">self</span>.initialize_list()

    <span class="kw">def</span> show_all(<span class="va">self</span>):
        <span class="va">self</span>.populate_list_store()
        <span class="va">self</span>.memberwindow.show_all()

    <span class="kw">def</span> populate_list_store(<span class="va">self</span>):
        <span class="va">self</span>.list_store.clear()
        member <span class="op">=</span> Member()
        memberdboperation <span class="op">=</span> getAdapter(member, IDbOperation)
        members <span class="op">=</span> memberdboperation.get()
        <span class="cf">for</span> member <span class="kw">in</span> members:
            number <span class="op">=</span> member.number
            name <span class="op">=</span> member.name
            <span class="va">self</span>.list_store.append((member, number, name,))

    <span class="kw">def</span> on_delete_event(<span class="va">self</span>, <span class="op">*</span>args):
        <span class="va">self</span>.memberwindow.hide()
        <span class="cf">return</span> <span class="va">True</span>

    <span class="kw">def</span> initialize_list(<span class="va">self</span>):
        <span class="va">self</span>.list_store <span class="op">=</span> gtk.ListStore(<span class="bu">object</span>, <span class="bu">str</span>, <span class="bu">str</span>)
        <span class="va">self</span>.treeview.set_model(<span class="va">self</span>.list_store)
        tvcolumn <span class="op">=</span> gtk.TreeViewColumn(<span class="st">&#39;Member Number&#39;</span>)
        <span class="va">self</span>.treeview.append_column(tvcolumn)

        cell <span class="op">=</span> gtk.CellRendererText()
        tvcolumn.pack_start(cell, <span class="va">True</span>)
        tvcolumn.add_attribute(cell, <span class="st">&#39;text&#39;</span>, <span class="dv">1</span>)

        tvcolumn <span class="op">=</span> gtk.TreeViewColumn(<span class="st">&#39;Member Name&#39;</span>)
        <span class="va">self</span>.treeview.append_column(tvcolumn)

        cell <span class="op">=</span> gtk.CellRendererText()
        tvcolumn.pack_start(cell, <span class="va">True</span>)
        tvcolumn.add_attribute(cell, <span class="st">&#39;text&#39;</span>, <span class="dv">2</span>)

    <span class="kw">def</span> on_add_clicked(<span class="va">self</span>, <span class="op">*</span>args):
        number <span class="op">=</span> <span class="va">self</span>.number.get_text()
        name <span class="op">=</span> <span class="va">self</span>.name.get_text()
        member <span class="op">=</span> Member()
        member.number <span class="op">=</span> number
        member.name <span class="op">=</span> name
        <span class="va">self</span>.add(member)
        <span class="va">self</span>.list_store.append((member, number, name,))

    <span class="kw">def</span> add(<span class="va">self</span>, member):
        memberdboperation <span class="op">=</span> getAdapter(member, IDbOperation)
        memberdboperation.add()

    <span class="kw">def</span> on_update_clicked(<span class="va">self</span>, <span class="op">*</span>args):
        number <span class="op">=</span> <span class="va">self</span>.number.get_text()
        name <span class="op">=</span> <span class="va">self</span>.name.get_text()
        treeselection <span class="op">=</span> <span class="va">self</span>.treeview.get_selection()
        model, <span class="bu">iter</span> <span class="op">=</span> treeselection.get_selected()
        <span class="cf">if</span> <span class="kw">not</span> <span class="bu">iter</span>:
            <span class="cf">return</span>
        member <span class="op">=</span> <span class="va">self</span>.list_store.get_value(<span class="bu">iter</span>, <span class="dv">0</span>)
        member.number <span class="op">=</span> number
        member.name <span class="op">=</span> name
        <span class="va">self</span>.update(member)
        <span class="va">self</span>.list_store.<span class="bu">set</span>(<span class="bu">iter</span>, <span class="dv">1</span>, number, <span class="dv">2</span>, name)

    <span class="kw">def</span> update(<span class="va">self</span>, member):
        memberdboperation <span class="op">=</span> getAdapter(member, IDbOperation)
        memberdboperation.update()

    <span class="kw">def</span> on_delete_clicked(<span class="va">self</span>, <span class="op">*</span>args):
        treeselection <span class="op">=</span> <span class="va">self</span>.treeview.get_selection()
        model, <span class="bu">iter</span> <span class="op">=</span> treeselection.get_selected()
        <span class="cf">if</span> <span class="kw">not</span> <span class="bu">iter</span>:
            <span class="cf">return</span>
        member <span class="op">=</span> <span class="va">self</span>.list_store.get_value(<span class="bu">iter</span>, <span class="dv">0</span>)
        <span class="va">self</span>.delete(member)
        <span class="va">self</span>.list_store.remove(<span class="bu">iter</span>)

    <span class="kw">def</span> delete(<span class="va">self</span>, member):
        memberdboperation <span class="op">=</span> getAdapter(member, IDbOperation)
        memberdboperation.delete()

memberwindow <span class="op">=</span> MemberWindow()</code></pre></div>
<p>Модуль <span><em>components.py</em></span>:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> zope.interface <span class="im">import</span> implements

<span class="im">from</span> interfaces <span class="im">import</span> IBook
<span class="im">from</span> interfaces <span class="im">import</span> IMember
<span class="im">from</span> interfaces <span class="im">import</span> ICirculation

<span class="kw">class</span> Book(<span class="bu">object</span>):

    implements(IBook)

    barcode <span class="op">=</span> <span class="st">&quot;&quot;</span>
    title <span class="op">=</span> <span class="st">&quot;&quot;</span>
    author <span class="op">=</span> <span class="st">&quot;&quot;</span>

<span class="kw">class</span> Member(<span class="bu">object</span>):

    implements(IMember)

    number <span class="op">=</span> <span class="st">&quot;&quot;</span>
    name <span class="op">=</span> <span class="st">&quot;&quot;</span>

<span class="kw">class</span> Circulation(<span class="bu">object</span>):

    implements(ICirculation)

    book <span class="op">=</span> Book()
    member <span class="op">=</span> Member()</code></pre></div>
<p>Модуль <span><em>interfaces.py</em></span>:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> zope.interface <span class="im">import</span> Interface
<span class="im">from</span> zope.interface <span class="im">import</span> Attribute


<span class="kw">class</span> IBook(Interface):

    barcode <span class="op">=</span> Attribute(<span class="st">&quot;Barcode&quot;</span>)
    author <span class="op">=</span> Attribute(<span class="st">&quot;Author of book&quot;</span>)
    title <span class="op">=</span> Attribute(<span class="st">&quot;Title of book&quot;</span>)


<span class="kw">class</span> IMember(Interface):

    number <span class="op">=</span> Attribute(<span class="st">&quot;ID number&quot;</span>)
    name <span class="op">=</span> Attribute(<span class="st">&quot;Name of member&quot;</span>)


<span class="kw">class</span> ICirculation(Interface):

    book <span class="op">=</span> Attribute(<span class="st">&quot;A book&quot;</span>)
    member <span class="op">=</span> Attribute(<span class="st">&quot;A member&quot;</span>)


<span class="kw">class</span> IRelationalDatabase(Interface):

    <span class="kw">def</span> commit():
        <span class="cf">pass</span>

    <span class="kw">def</span> rollback():
        <span class="cf">pass</span>

    <span class="kw">def</span> cursor():
        <span class="cf">pass</span>

    <span class="kw">def</span> get_next_id():
        <span class="cf">pass</span>


<span class="kw">class</span> IObjectDatabase(Interface):

    <span class="kw">def</span> commit():
        <span class="cf">pass</span>

    <span class="kw">def</span> rollback():
        <span class="cf">pass</span>

    <span class="kw">def</span> container():
        <span class="cf">pass</span>

    <span class="kw">def</span> get_next_id():
        <span class="cf">pass</span>


<span class="kw">class</span> IDbOperation(Interface):

    <span class="kw">def</span> get():
        <span class="cf">pass</span>

    <span class="kw">def</span> add():
        <span class="cf">pass</span>

    <span class="kw">def</span> update():
        <span class="cf">pass</span>

    <span class="kw">def</span> delete():
        <span class="cf">pass</span></code></pre></div>
<p>Модуль <span><em>member.py</em></span>:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> zope.interface <span class="im">import</span> implements
<span class="im">from</span> zope.component <span class="im">import</span> getUtility
<span class="im">from</span> zope.component <span class="im">import</span> adapts

<span class="im">from</span> components <span class="im">import</span> Member

<span class="im">from</span> interfaces <span class="im">import</span> IRelationalDatabase
<span class="im">from</span> interfaces <span class="im">import</span> IObjectDatabase
<span class="im">from</span> interfaces <span class="im">import</span> IMember
<span class="im">from</span> interfaces <span class="im">import</span> IDbOperation


<span class="kw">class</span> MemberRDbOperation(<span class="bu">object</span>):

    implements(IDbOperation)
    adapts(IMember)

    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, member):
        <span class="va">self</span>.member <span class="op">=</span> member

    <span class="kw">def</span> get(<span class="va">self</span>):
        db <span class="op">=</span> getUtility(IRelationalDatabase)
        cr <span class="op">=</span> db.cursor()
        number <span class="op">=</span> <span class="va">self</span>.member.number
        <span class="cf">if</span> number:
            cr.execute(<span class="st">&quot;&quot;&quot;SELECT</span>
<span class="st">                            id,</span>
<span class="st">                            number,</span>
<span class="st">                            name</span>
<span class="st">                          FROM members</span>
<span class="st">                          WHERE number = ?&quot;&quot;&quot;</span>,
                       (number,))
        <span class="cf">else</span>:
            cr.execute(<span class="st">&quot;&quot;&quot;SELECT</span>
<span class="st">                            id,</span>
<span class="st">                            number,</span>
<span class="st">                            name</span>
<span class="st">                          FROM members&quot;&quot;&quot;</span>)
        rst <span class="op">=</span> cr.fetchall()
        cr.close()
        members <span class="op">=</span> []
        <span class="cf">for</span> record <span class="kw">in</span> rst:
            <span class="bu">id</span> <span class="op">=</span> record[<span class="st">&#39;id&#39;</span>]
            number <span class="op">=</span> record[<span class="st">&#39;number&#39;</span>]
            name <span class="op">=</span> record[<span class="st">&#39;name&#39;</span>]
            member <span class="op">=</span> Member()
            member.<span class="bu">id</span> <span class="op">=</span> <span class="bu">id</span>
            member.number <span class="op">=</span> number
            member.name <span class="op">=</span> name
            members.append(member)
        <span class="cf">return</span> members

    <span class="kw">def</span> add(<span class="va">self</span>):
        db <span class="op">=</span> getUtility(IRelationalDatabase)
        cr <span class="op">=</span> db.cursor()
        next_id <span class="op">=</span> db.get_next_id(<span class="st">&quot;members&quot;</span>)
        number <span class="op">=</span> <span class="va">self</span>.member.number
        name <span class="op">=</span> <span class="va">self</span>.member.name
        cr.execute(<span class="st">&quot;&quot;&quot;INSERT INTO members</span>
<span class="st">                        (id, number, name)</span>
<span class="st">                      VALUES (?, ?, ?)&quot;&quot;&quot;</span>,
                   (next_id, number, name))
        cr.close()
        db.commit()
        <span class="va">self</span>.member.<span class="bu">id</span> <span class="op">=</span> next_id

    <span class="kw">def</span> update(<span class="va">self</span>):
        db <span class="op">=</span> getUtility(IRelationalDatabase)
        cr <span class="op">=</span> db.cursor()
        number <span class="op">=</span> <span class="va">self</span>.member.number
        name <span class="op">=</span> <span class="va">self</span>.member.name
        <span class="bu">id</span> <span class="op">=</span> <span class="va">self</span>.member.<span class="bu">id</span>
        cr.execute(<span class="st">&quot;&quot;&quot;UPDATE members</span>
<span class="st">                        SET</span>
<span class="st">                           number = ?,</span>
<span class="st">                           name = ?</span>
<span class="st">                      WHERE id = ?&quot;&quot;&quot;</span>,
                   (number, name, <span class="bu">id</span>))
        cr.close()
        db.commit()

    <span class="kw">def</span> delete(<span class="va">self</span>):
        db <span class="op">=</span> getUtility(IRelationalDatabase)
        cr <span class="op">=</span> db.cursor()
        <span class="bu">id</span> <span class="op">=</span> <span class="va">self</span>.member.<span class="bu">id</span>
        cr.execute(<span class="st">&quot;&quot;&quot;DELETE FROM members</span>
<span class="st">                      WHERE id = ?&quot;&quot;&quot;</span>,
                   (<span class="bu">id</span>,))
        cr.close()
        db.commit()


<span class="kw">class</span> MemberODbOperation(<span class="bu">object</span>):

    implements(IDbOperation)
    adapts(IMember)

    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, member):
        <span class="va">self</span>.member <span class="op">=</span> member

    <span class="kw">def</span> get(<span class="va">self</span>):
        db <span class="op">=</span> getUtility(IObjectDatabase)
        zcalibdb <span class="op">=</span> db.container()
        members <span class="op">=</span> zcalibdb[<span class="st">&#39;members&#39;</span>]
        <span class="cf">return</span> members.values()

    <span class="kw">def</span> add(<span class="va">self</span>):
        db <span class="op">=</span> getUtility(IObjectDatabase)
        zcalibdb <span class="op">=</span> db.container()
        members <span class="op">=</span> zcalibdb[<span class="st">&#39;members&#39;</span>]
        number <span class="op">=</span> <span class="va">self</span>.member.number
        <span class="cf">if</span> number <span class="kw">in</span> [x.number <span class="cf">for</span> x <span class="kw">in</span> members.values()]:
            db.rollback()
            <span class="cf">raise</span> <span class="pp">Exception</span>(<span class="st">&quot;Duplicate key&quot;</span>)
        next_id <span class="op">=</span> db.get_next_id(<span class="st">&#39;members&#39;</span>)
        <span class="va">self</span>.member.<span class="bu">id</span> <span class="op">=</span> next_id
        members[next_id] <span class="op">=</span> <span class="va">self</span>.member
        db.commit()

    <span class="kw">def</span> update(<span class="va">self</span>):
        db <span class="op">=</span> getUtility(IObjectDatabase)
        zcalibdb <span class="op">=</span> db.container()
        members <span class="op">=</span> zcalibdb[<span class="st">&#39;members&#39;</span>]
        <span class="bu">id</span> <span class="op">=</span> <span class="va">self</span>.member.<span class="bu">id</span>
        members[<span class="bu">id</span>] <span class="op">=</span> <span class="va">self</span>.member
        db.commit()

    <span class="kw">def</span> delete(<span class="va">self</span>):
        db <span class="op">=</span> getUtility(IObjectDatabase)
        zcalibdb <span class="op">=</span> db.container()
        members <span class="op">=</span> zcalibdb[<span class="st">&#39;members&#39;</span>]
        <span class="bu">id</span> <span class="op">=</span> <span class="va">self</span>.member.<span class="bu">id</span>
        <span class="kw">del</span> members[<span class="bu">id</span>]
        db.commit()</code></pre></div>
</section>
<section id="pysqlite-pysqlite" class="level2">
<h2><span class="header-section-number">9.4</span> PySQLite [pysqlite]</h2>
</section>
<section id="zodb-zodb" class="level2">
<h2><span class="header-section-number">9.5</span> ZODB [zodb]</h2>
</section>
</section>
<section id="сервер-интернетприложений-pyramid" class="level1">
<h1><span class="header-section-number">10</span> Сервер Интернет&quot;=приложений Pyramid</h1>
<p>Среда разработки Интернет-приложений Pyramid использует регистратор компонент, встроенный в ZCA, в качестве регистра компонент разрабатываемого приложения. The Zope Component Architecture is referred to colloquially as the “ZCA.”</p>
<p>The zope.component API used to access data in a traditional Zope application can be opaque. For example, here is a typical “unnamed utility” lookup using the zope.component.getUtility() global API as it might appear in a traditional Zope application:</p>
<p>1 2 3</p>
<p>from pyramid.interfaces import ISettings from zope.component import getUtility settings = getUtility(ISettings)</p>
<p>After this code runs, settings will be a Python dictionary. But it’s unlikely that any “civilian” will be able to figure this out just by reading the code casually. When the zope.component.getUtility API is used by a developer, the conceptual load on a casual reader of code is high.</p>
<p>While the ZCA is an excellent tool with which to build a framework such as Pyramid, it is not always the best tool with which to build an application due to the opacity of the zope.component APIs. Accordingly, Pyramid tends to hide the presence of the ZCA from application developers. You needn’t understand the ZCA to create a Pyramid application; its use is effectively only a framework implementation detail.</p>
<p>However, developers who are already used to writing Zope applications often still wish to use the ZCA while building a Pyramid application. Pyramid makes this possible. Using the ZCA global API in a Pyramid application</p>
<p>Zope uses a single ZCA registry—the “global” ZCA registry—for all Zope applications that run in the same Python process, effectively making it impossible to run more than one Zope application in a single process.</p>
<p>However, for ease of deployment, it’s often useful to be able to run more than a single application per process. For example, use of a PasteDeploy “composite” allows you to run separate individual WSGI applications in the same process, each answering requests for some URL prefix. This makes it possible to run, for example, a TurboGears application at /turbogears and a Pyramid application at /pyramid, both served up using the same WSGI server within a single Python process.</p>
<p>Most production Zope applications are relatively large, making it impractical due to memory constraints to run more than one Zope application per Python process. However, a Pyramid application may be very small and consume very little memory, so it’s a reasonable goal to be able to run more than one Pyramid application per process.</p>
<p>In order to make it possible to run more than one Pyramid application in a single process, Pyramid defaults to using a separate ZCA registry per application.</p>
<p>While this services a reasonable goal, it causes some issues when trying to use patterns which you might use to build a typical Zope application to build a Pyramid application. Without special help, ZCA “global” APIs such as zope.component.getUtility() and zope.component.getSiteManager() will use the ZCA “global” registry. Therefore, these APIs will appear to fail when used in a Pyramid application, because they’ll be consulting the ZCA global registry rather than the component registry associated with your Pyramid application.</p>
<p>There are three ways to fix this: by disusing the ZCA global API entirely, by using pyramid.config.Configurator.hook_zca() or by passing the ZCA global registry to the Configurator constructor at startup time. We’ll describe all three methods in this section. Disusing the global ZCA API</p>
<p>ZCA “global” API functions such as zope.component.getSiteManager, zope.component.getUtility, zope.component.getAdapter(), and zope.component.getMultiAdapter() aren’t strictly necessary. Every component registry has a method API that offers the same functionality; it can be used instead. For example, presuming the registry value below is a Zope Component Architecture component registry, the following bit of code is equivalent to zope.component.getUtility(IFoo):</p>
<p>registry.getUtility(IFoo)</p>
<p>The full method API is documented in the zope.component package, but it largely mirrors the “global” API almost exactly.</p>
<p>If you are willing to disuse the “global” ZCA APIs and use the method interface of a registry instead, you need only know how to obtain the Pyramid component registry.</p>
<p>There are two ways of doing so:</p>
<p>use the pyramid.threadlocal.get_current_registry() function within Pyramid view or resource code. This will always return the “current” Pyramid application registry. use the attribute of the request object named registry in your Pyramid view code, e.g., request.registry. This is the ZCA component registry related to the running Pyramid application.</p>
<p>See Thread Locals for more information about pyramid.threadlocal.get_current_registry(). Enabling the ZCA global API by using hook_zca</p>
<p>Consider the following bit of idiomatic Pyramid startup code:</p>
<p>1 2 3 4 5 6</p>
<p>from pyramid.config import Configurator</p>
<p>def app(global_settings, **settings): config = Configurator(settings=settings) config.include(’some.other.package’) return config.make_wsgi_app()</p>
<p>When the app function above is run, a Configurator is constructed. When the configurator is created, it creates a new application registry (a ZCA component registry). A new registry is constructed whenever the registry argument is omitted, when a Configurator constructor is called, or when a registry argument with a value of None is passed to a Configurator constructor.</p>
<p>During a request, the application registry created by the Configurator is “made current”. This means calls to get_current_registry() in the thread handling the request will return the component registry associated with the application.</p>
<p>As a result, application developers can use get_current_registry to get the registry and thus get access to utilities and such, as per Disusing the global ZCA API. But they still cannot use the global ZCA API. Without special treatment, the ZCA global APIs will always return the global ZCA registry (the one in zope.component.globalregistry.base).</p>
<p>To “fix” this and make the ZCA global APIs use the “current” Pyramid registry, you need to call hook_zca() within your setup code. For example:</p>
<p>1 2 3 4 5 6 7</p>
<p>from pyramid.config import Configurator</p>
<p>def app(global_settings, **settings): config = Configurator(settings=settings) config.hook_zca() config.include(’some.other.application’) return config.make_wsgi_app()</p>
<p>We’ve added a line to our original startup code, line number 5, which calls config.hook_zca(). The effect of this line under the hood is that an analogue of the following code is executed:</p>
<p>1 2 3</p>
<p>from zope.component import getSiteManager from pyramid.threadlocal import get_current_registry getSiteManager.sethook(get_current_registry)</p>
<p>This causes the ZCA global API to start using the Pyramid application registry in threads which are running a Pyramid request.</p>
<p>Calling hook_zca is usually sufficient to “fix” the problem of being able to use the global ZCA API within a Pyramid application. However, it also means that a Zope application that is running in the same process may start using the Pyramid global registry instead of the Zope global registry, effectively inverting the original problem. In such a case, follow the steps in the next section, Enabling the ZCA global API by using the ZCA global registry. Enabling the ZCA global API by using the ZCA global registry</p>
<p>You can tell your Pyramid application to use the ZCA global registry at startup time instead of constructing a new one:</p>
<p>1 2 3 4 5 6 7 8 9</p>
<p>from zope.component import getGlobalSiteManager from pyramid.config import Configurator</p>
<p>def app(global_settings, **settings): globalreg = getGlobalSiteManager() config = Configurator(registry=globalreg) config.setup_registry(settings=settings) config.include(’some.other.application’) return config.make_wsgi_app()</p>
<p>Lines 5, 6, and 7 above are the interesting ones. Line 5 retrieves the global ZCA component registry. Line 6 creates a Configurator, passing the global ZCA registry into its constructor as the registry argument. Line 7 “sets up” the global registry with Pyramid-specific registrations; this is code that is normally executed when a registry is constructed rather than created, but we must call it “by hand” when we pass an explicit registry.</p>
<p>At this point, Pyramid will use the ZCA global registry rather than creating a new application-specific registry. Since by default the ZCA global API will use this registry, things will work as you might expect in a Zope app when you use the global ZCA API.</p>
<section id="заключение-id53" class="level2">
<h2><span class="header-section-number">10.1</span> Заключение [id53]</h2>
</section>
</section>
<section id="cha:labs" class="level1">
<h1><span class="header-section-number">11</span> Методические указания к выполнению лабораторных работ</h1>
<p>Чтобы знания, полученные в предыдущих частях учебного пособия, создали почву для формирования навыков использования компонентной архитектуры необходимо выполнить ряд лабораторных работ, которые представлены в разделах данной главы. Задания на лабораторные работы сформированы таким образом, чтобы следующая лабораторная работа дополняла материал предыдущей. Это позволяет смотреть на процесс обучения как на маленький проект, состоящий из четырех этапов: разработки компоненты, моделирующей предметную некоторую область или известную структуру данных; создание адаптера интерфейса компоненты из первой лабораторной работы к одной из компонент, представленных в другом варианте задания; разработка оконно интерфейса пользователя, позволяющая вносить изменения в данные компоненты через ее интерфейс; реализация распределенной версии приложения при помощи прокси&quot;=адаптера.</p>
<section id="sec:labcomp" class="level2">
<h2><span class="header-section-number">11.1</span> Разработка и тестирование компоненты</h2>
<section id="варианты-задания" class="level5">
<h5><span class="header-section-number">11.1.0.0.1</span> Варианты задания</h5>
</section>
</section>
<section id="sec:labadapter" class="level2">
<h2><span class="header-section-number">11.2</span> Реализация адаптера интерфейса</h2>
<section id="варианты-задания-1" class="level5">
<h5><span class="header-section-number">11.2.0.0.1</span> Варианты задания</h5>
</section>
</section>
<section id="sec:labinterface" class="level2">
<h2><span class="header-section-number">11.3</span> Создание интерфейса пользователя</h2>
<section id="варианты-задания-2" class="level5">
<h5><span class="header-section-number">11.3.0.0.1</span> Варианты задания</h5>
</section>
</section>
<section id="sec:labmodel" class="level2">
<h2><span class="header-section-number">11.4</span> Моделирование распределенного приложения</h2>
<section id="варианты-задания-3" class="level5">
<h5><span class="header-section-number">11.4.0.0.1</span> Варианты задания</h5>
</section>
</section>
</section>
<section id="справочник-id54" class="level1">
<h1><span class="header-section-number">12</span> Справочник [id54]</h1>
<section id="adaptedby-adaptedby" class="level2 unnumbered">
<h2>adaptedBy [adaptedby]</h2>
<p>Функция возвращает перечень интерфейсов, адаптируемых объектом&quot;=адаптером.</p>
<ul>
<li><p>Модуль: <code>zope.component</code></p></li>
<li><p>Сигнатура: <span><em>adaptedBy(object)</em></span></p></li>
</ul>
<p>Пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> implements
    <span class="im">from</span> zope.component <span class="im">import</span> adapts
    <span class="im">from</span> zope.component <span class="im">import</span> adaptedBy

    <span class="kw">class</span> FrontDeskNG(<span class="bu">object</span>):

        implements(IDesk)
        adapts(IGuest)

        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, guest):
            <span class="va">self</span>.guest <span class="op">=</span> guest

    adaptedBy(FrontDeskNG)
(<span class="op">&lt;</span>InterfaceClass __builtin__.IGuest<span class="op">&gt;</span>,)</code></pre></div>
</section>
<section id="adapter-id55" class="level2 unnumbered">
<h2>adapter [id55]</h2>
<p>Адаптерами выступают любые вызываемые (callable) объекты. Также существует специальный декоратор <span><em>adapter</em></span>, который позволяет декларировать вызываемые объекты как адаптеры для указанных интерфейсов (или классов).</p>
<ul>
<li><p>Модуль: <code>zope.component</code></p></li>
<li><p>Спецификация: <span><em>adapter(*interfaces)</em></span></p></li>
</ul>
<p>Пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Attribute
    <span class="im">from</span> zope.interface <span class="im">import</span> Interface
    <span class="im">from</span> zope.interface <span class="im">import</span> implementer
    <span class="im">from</span> zope.component <span class="im">import</span> adapter
    <span class="im">from</span> zope.interface <span class="im">import</span> implements

    <span class="kw">class</span> IJob(Interface):
        <span class="co">&quot;&quot;&quot;A job&quot;&quot;&quot;</span>

    <span class="kw">class</span> Job(<span class="bu">object</span>):
        implements(IJob)

    <span class="kw">class</span> IPerson(Interface):

        name <span class="op">=</span> Attribute(<span class="st">&quot;Name&quot;</span>)
        job <span class="op">=</span> Attribute(<span class="st">&quot;Job&quot;</span>)

    <span class="kw">class</span> Person(<span class="bu">object</span>):
        implements(IPerson)

        name <span class="op">=</span> <span class="va">None</span>
        job <span class="op">=</span> <span class="va">None</span>

    <span class="at">@implementer</span>(IJob)
    <span class="at">@adapter</span>(IPerson)
    <span class="kw">def</span> personJob(person):
        <span class="cf">return</span> person.job

    jack <span class="op">=</span> Person()
    jack.name <span class="op">=</span> <span class="st">&quot;Jack&quot;</span>
    jack.job <span class="op">=</span> Job()
    personJob(jack)
<span class="op">&lt;</span>Job <span class="bu">object</span> at ...<span class="op">&gt;</span></code></pre></div>
</section>
<section id="adapts-adapts" class="level2 unnumbered">
<h2>adapts [adapts]</h2>
<p>Функция определяющая, что некоторый класс является адаптером.</p>
<ul>
<li><p>Модуль: <code>zope.component</code></p></li>
<li><p>Спецификация: <span><em>adapts(*interfaces)</em></span></p></li>
</ul>
<p>Пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> implements
    <span class="im">from</span> zope.component <span class="im">import</span> adapts

    <span class="kw">class</span> FrontDeskNG(<span class="bu">object</span>):

        implements(IDesk)
        adapts(IGuest)

        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, guest):
            <span class="va">self</span>.guest <span class="op">=</span> guest

        <span class="kw">def</span> register(<span class="va">self</span>):
            next_id <span class="op">=</span> get_next_id()
            bookings_db[next_id] <span class="op">=</span> {
            <span class="st">&#39;name&#39;</span>: guest.name,
            <span class="st">&#39;place&#39;</span>: guest.place,
            <span class="st">&#39;phone&#39;</span>: guest.phone
            }</code></pre></div>
</section>
<section id="alsoprovides-alsoprovides" class="level2 unnumbered">
<h2>alsoProvides [alsoprovides]</h2>
<p>Задает объекту перечень интерфейсов, которые он обслуживать, в дополнение к ранее декларированным. Параметры функции, следующие за объектом, – перечень обслуживаемых интерфейсов (один или несколько).</p>
<ul>
<li><p>Модуль: <code>zope.interface</code></p></li>
<li><p>Спецификация: <span><em>alsoProvides(object, *interfaces)</em></span></p></li>
</ul>
<p>Пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Attribute
    <span class="im">from</span> zope.interface <span class="im">import</span> Interface
    <span class="im">from</span> zope.interface <span class="im">import</span> implements
    <span class="im">from</span> zope.interface <span class="im">import</span> alsoProvides

    <span class="kw">class</span> IPerson(Interface):

        name <span class="op">=</span> Attribute(<span class="st">&quot;Name of person&quot;</span>)

    <span class="kw">class</span> IStudent(Interface):

        college <span class="op">=</span> Attribute(<span class="st">&quot;Name of college&quot;</span>)

    <span class="kw">class</span> Person(<span class="bu">object</span>):

        implements(IDesk)
        name <span class="op">=</span> <span class="st">u&quot;&quot;</span>

    jack <span class="op">=</span> Person()
    jack.name <span class="op">=</span> <span class="st">&quot;Jack&quot;</span>
    jack.college <span class="op">=</span> <span class="st">&quot;New College&quot;</span>
    alsoProvides(jack, IStudent)

You can test it like this:

    <span class="im">from</span> zope.interface <span class="im">import</span> providedBy
    IStudent <span class="kw">in</span> providedBy(jack)
<span class="va">True</span></code></pre></div>
</section>
<section id="attribute-attribute" class="level2 unnumbered">
<h2>Attribute [attribute]</h2>
<p>Класс, предназначенный для определения атрибутов в интерфейсе.</p>
<ul>
<li><p>Модуль: <code>zope.interface</code></p></li>
<li><p>Спецификация: <span><em>Attribute(name, doc=”)</em></span></p></li>
<li><p>Смотри также:</p></li>
</ul>
<p>Пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Attribute
    <span class="im">from</span> zope.interface <span class="im">import</span> Interface

    <span class="kw">class</span> IPerson(Interface):

        name <span class="op">=</span> Attribute(<span class="st">&quot;Name of person&quot;</span>)
        email <span class="op">=</span> Attribute(<span class="st">&quot;Email Address&quot;</span>)</code></pre></div>
</section>
<section id="classimplements-classimplements" class="level2 unnumbered">
<h2>classImplements [classimplements]</h2>
<p>Задает дополнительные интерфейсы классу, которые он в системе будет реализовывать. Перечень аргументов, следующих за классом – задаваемые интерфейсы, которые добавляются к списку ранее заданных интерфейсов.</p>
<ul>
<li><p>Модуль: <code>zope.interface</code></p></li>
<li><p>Спецификация: <span><em>classImplements(cls, *interfaces)</em></span></p></li>
</ul>
<p>Пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Attribute
    <span class="im">from</span> zope.interface <span class="im">import</span> Interface
    <span class="im">from</span> zope.interface <span class="im">import</span> implements
    <span class="im">from</span> zope.interface <span class="im">import</span> classImplements

    <span class="kw">class</span> IPerson(Interface):

        name <span class="op">=</span> Attribute(<span class="st">&quot;Имя человека&quot;</span>)

    <span class="kw">class</span> IStudent(IPerson):

        college <span class="op">=</span> Attribute(<span class="st">&quot;Название колледжа&quot;</span>)

    <span class="kw">class</span> Person(<span class="bu">object</span>):

        implements(IDesk)
        name <span class="op">=</span> <span class="st">u&quot;&quot;</span>
        college <span class="op">=</span> <span class="st">u&quot;&quot;</span>

    classImplements(Person, IStudent)
    ganes <span class="op">=</span> Person()
    ganes.name <span class="op">=</span> <span class="st">&quot;Баролби Гейнс&quot;</span>
    ganes.college <span class="op">=</span> <span class="st">&quot;Саус-хермондский институт технологий&quot;</span>

Результат тестируется следующим образом:

    <span class="im">from</span> zope.interface <span class="im">import</span> providedBy
    IStudent <span class="kw">in</span> providedBy(ganes)
<span class="va">True</span></code></pre></div>
</section>
<section id="classimplementsonly-classimplementsonly" class="level2 unnumbered">
<h2>classImplementsOnly [classimplementsonly]</h2>
<p>Задает классу набор реализуемых им интерфейсов. Перечень аргументов после класса – задаваемые интерфейсы. Ранее декларированные интерфейсы заменяются данным перечнем.</p>
<blockquote>
<ul>
<li><p>Модуль: <code>zope.interface</code></p></li>
<li><p>Спецификация: <span><em>classImplementsOnly(cls, *interfaces)</em></span></p></li>
</ul>
</blockquote>
<p>Пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Attribute
    <span class="im">from</span> zope.interface <span class="im">import</span> Interface
    <span class="im">from</span> zope.interface <span class="im">import</span> implements
    <span class="im">from</span> zope.interface <span class="im">import</span> classImplementsOnly

    <span class="kw">class</span> IPerson(Interface):

        name <span class="op">=</span> Attribute(<span class="st">&quot;Name of person&quot;</span>)

    <span class="kw">class</span> IStudent(Interface):

        college <span class="op">=</span> Attribute(<span class="st">&quot;Name of college&quot;</span>)

    <span class="kw">class</span> Person(<span class="bu">object</span>):

        implements(IPerson)
        college <span class="op">=</span> <span class="st">u&quot;&quot;</span>

    classImplementsOnly(Person, IStudent)
    jack <span class="op">=</span> Person()
    jack.college <span class="op">=</span> <span class="st">&quot;New College&quot;</span>

Результат тестируется следующим образом:

    <span class="im">from</span> zope.interface <span class="im">import</span> providedBy
    IPerson <span class="kw">in</span> providedBy(jack)
<span class="va">False</span>
    IStudent <span class="kw">in</span> providedBy(jack)
<span class="va">True</span></code></pre></div>
</section>
<section id="classprovides-classprovides" class="level2 unnumbered">
<h2>classProvides [classprovides]</h2>
<p>Обычно если класс реализует определенный интерфейс, то его экземпляры обслуживают этот интерфейс. Но когда надо, чтобы именно класс обслуживал некоторый интерфейс, то это реализуется функцией <code>classProvides</code>.</p>
<ul>
<li><p>Модуль: <code>zope.interface</code></p></li>
<li><p>Спецификация: <span><em>classProvides(*interfaces)</em></span></p></li>
</ul>
<p>Пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Attribute
    <span class="im">from</span> zope.interface <span class="im">import</span> Interface
    <span class="im">from</span> zope.interface <span class="im">import</span> classProvides

    <span class="kw">class</span> IPerson(Interface):

        name <span class="op">=</span> Attribute(<span class="st">&quot;Name of person&quot;</span>)

    <span class="kw">class</span> Person(<span class="bu">object</span>):

        classProvides(IPerson)
        name <span class="op">=</span> <span class="st">u&quot;Jack&quot;</span>

Результат тестируется следующим образом:

    <span class="im">from</span> zope.interface <span class="im">import</span> providedBy
    IPerson <span class="kw">in</span> providedBy(Person)
<span class="va">True</span></code></pre></div>
</section>
<section id="componentlookuperror-componentlookuperror" class="level2 unnumbered">
<h2>ComponentLookupError [componentlookuperror]</h2>
<p>Исключение, которое инициируется, если поиск компоненты не удался.</p>
<p>Пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">class</span> IPerson(Interface):

        name <span class="op">=</span> Attribute(<span class="st">&quot;Name of person&quot;</span>)

    person <span class="op">=</span> <span class="bu">object</span>()
    getAdapter(person, IPerson, <span class="st">&#39;not-exists&#39;</span>)
Traceback (most recent call last):

ComponentLookupError: ...</code></pre></div>
</section>
<section id="createobject-createobject" class="level2 unnumbered">
<h2>createObject [createobject]</h2>
<p>Создает объект, используя фабрику.</p>
<p>Производит поиск поименованной фабрики в текущем регистре компонент (менеджере сайта) и запускает ее с заданными аргументами. Если такой фабрики не удается найти, инициируется исключение <code>ComponentLookupError</code>. Возвращает созданный объект.</p>
<p>При помощи ключевого слова <span><em>context</em></span> в аргументе функции задается контекст, где следует искать фабрику, в отличие от основного регистра. Ограничения технологии не позволяют передавать аргумент по ключу “context” в фабрику.</p>
<ul>
<li><p>Модуль: <code>zope.component</code></p></li>
<li><p>Спецификация: <span><em>createObject(factory_name, *args, **kwargs)</em></span></p></li>
</ul>
<p>Пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Attribute
    <span class="im">from</span> zope.interface <span class="im">import</span> Interface
    <span class="im">from</span> zope.interface <span class="im">import</span> implements

    <span class="kw">class</span> IDatabase(Interface):

        <span class="kw">def</span> getConnection():
            <span class="co">&quot;&quot;&quot;Return connection object&quot;&quot;&quot;</span>

    <span class="kw">class</span> FakeDb(<span class="bu">object</span>):

        implements(IDatabase)

        <span class="kw">def</span> getConnection(<span class="va">self</span>):
            <span class="cf">return</span> <span class="st">&quot;connection&quot;</span>

    <span class="im">from</span> zope.component.factory <span class="im">import</span> Factory

    factory <span class="op">=</span> Factory(FakeDb, <span class="st">&#39;FakeDb&#39;</span>)

    <span class="im">from</span> zope.component <span class="im">import</span> getGlobalSiteManager
    gsm <span class="op">=</span> getGlobalSiteManager()

    <span class="im">from</span> zope.component.interfaces <span class="im">import</span> IFactory
    gsm.registerUtility(factory, IFactory, <span class="st">&#39;fakedb&#39;</span>)

    <span class="im">from</span> zope.component <span class="im">import</span> createObject
    createObject(<span class="st">&#39;fakedb&#39;</span>)
<span class="op">&lt;</span>FakeDb <span class="bu">object</span> at ...<span class="op">&gt;</span></code></pre></div>
</section>
<section id="declaration-declaration" class="level2 unnumbered">
<h2>Declaration [declaration]</h2>
<p>Непосредственно не запускается.</p>
</section>
<section id="directlyprovidedby-directlyprovidedby" class="level2 unnumbered">
<h2>directlyProvidedBy [directlyprovidedby]</h2>
<p>Возвращает список интерфейсов, которые непосредственно обслуживаются объектом, переданным в параметре.</p>
<ul>
<li><p>Модуль: <code>zope.interface</code></p></li>
<li><p>Спецификация: <span><em>directlyProvidedBy(object)</em></span></p></li>
</ul>
<p>Пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Attribute
    <span class="im">from</span> zope.interface <span class="im">import</span> Interface

    <span class="kw">class</span> IPerson(Interface):

        name <span class="op">=</span> Attribute(<span class="st">&quot;Name of person&quot;</span>)

    <span class="kw">class</span> IStudent(Interface):

        college <span class="op">=</span> Attribute(<span class="st">&quot;Name of college&quot;</span>)

    <span class="kw">class</span> ISmartPerson(Interface):
        <span class="cf">pass</span>

    <span class="kw">class</span> Person(<span class="bu">object</span>):

        implements(IPerson)
        name <span class="op">=</span> <span class="st">u&quot;&quot;</span>

    jack <span class="op">=</span> Person()
    jack.name <span class="op">=</span> <span class="st">u&quot;Jack&quot;</span>
    jack.college <span class="op">=</span> <span class="st">&quot;New College&quot;</span>
    alsoProvides(jack, ISmartPerson, IStudent)

    <span class="im">from</span> zope.interface <span class="im">import</span> directlyProvidedBy

    jack_dp <span class="op">=</span> directlyProvidedBy(jack)
    IPerson <span class="kw">in</span> jack_dp.interfaces()
<span class="va">False</span>
    IStudent <span class="kw">in</span> jack_dp.interfaces()
<span class="va">True</span>
    ISmartPerson <span class="kw">in</span> jack_dp.interfaces()
<span class="va">True</span></code></pre></div>
</section>
<section id="directlyprovides-directlyprovides" class="level2 unnumbered">
<h2>directlyProvides [directlyprovides]</h2>
<p>Задает перечень интерфейсов, обслуживаемых объектом. Аргументы, непосредственно следующие за объектом – перечень декларируемых интерфейсов. Заданные интерфейсы заменяют декларированные ранее.</p>
<blockquote>
<ul>
<li><p>Модуль: <code>zope.interface</code></p></li>
<li><p>Спецификация: <span><em>directlyProvides(object, *interfaces)</em></span></p></li>
</ul>
</blockquote>
<p>Пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Attribute
    <span class="im">from</span> zope.interface <span class="im">import</span> Interface

    <span class="kw">class</span> IPerson(Interface):

        name <span class="op">=</span> Attribute(<span class="st">&quot;Name of person&quot;</span>)

    <span class="kw">class</span> IStudent(Interface):

        college <span class="op">=</span> Attribute(<span class="st">&quot;Name of college&quot;</span>)

    <span class="kw">class</span> ISmartPerson(Interface):
        <span class="cf">pass</span>

    <span class="kw">class</span> Person(<span class="bu">object</span>):

        implements(IPerson)
        name <span class="op">=</span> <span class="st">u&quot;&quot;</span>

    jack <span class="op">=</span> Person()
    jack.name <span class="op">=</span> <span class="st">u&quot;Jack&quot;</span>
    jack.college <span class="op">=</span> <span class="st">&quot;New College&quot;</span>
    alsoProvides(jack, ISmartPerson, IStudent)

    <span class="im">from</span> zope.interface <span class="im">import</span> directlyProvidedBy

    jack_dp <span class="op">=</span> directlyProvidedBy(jack)
    ISmartPerson <span class="kw">in</span> jack_dp.interfaces()
<span class="va">True</span>
    IPerson <span class="kw">in</span> jack_dp.interfaces()
<span class="va">False</span>
    IStudent <span class="kw">in</span> jack_dp.interfaces()
<span class="va">True</span>
    <span class="im">from</span> zope.interface <span class="im">import</span> providedBy

    ISmartPerson <span class="kw">in</span> providedBy(jack)
<span class="va">True</span>

    <span class="im">from</span> zope.interface <span class="im">import</span> directlyProvides
    directlyProvides(jack, IStudent)

    jack_dp <span class="op">=</span> directlyProvidedBy(jack)
    ISmartPerson <span class="kw">in</span> jack_dp.interfaces()
<span class="va">False</span>
    IPerson <span class="kw">in</span> jack_dp.interfaces()
<span class="va">False</span>
    IStudent <span class="kw">in</span> jack_dp.interfaces()
<span class="va">True</span>

    ISmartPerson <span class="kw">in</span> providedBy(jack)
<span class="va">False</span></code></pre></div>
</section>
<section id="getadapter-getadapter" class="level2 unnumbered">
<h2>getAdapter [getadapter]</h2>
<p>Возвращает поименованный адаптер к заданному интерфейсу для заданного объекта. Если подходящего адаптера не получается найти, создается исключительная ситуация <code>ComponentLookupError</code>.</p>
<ul>
<li><p>Модуль: <code>zope.interface</code></p></li>
<li><p>Спецификация: <span><em>getAdapter(object, interface=Interface, name=u”, context=None)</em></span></p></li>
</ul>
<p>Пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Attribute
    <span class="im">from</span> zope.interface <span class="im">import</span> Interface

    <span class="kw">class</span> IDesk(Interface):
        <span class="co">&quot;&quot;&quot;A frontdesk will register object&#39;s details&quot;&quot;&quot;</span>

        <span class="kw">def</span> register():
            <span class="co">&quot;&quot;&quot;Register object&#39;s details&quot;&quot;&quot;</span>


    <span class="im">from</span> zope.interface <span class="im">import</span> implements
    <span class="im">from</span> zope.component <span class="im">import</span> adapts

    <span class="kw">class</span> FrontDeskNG(<span class="bu">object</span>):

        implements(IDesk)
        adapts(IGuest)

        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, guest):
            <span class="va">self</span>.guest <span class="op">=</span> guest

        <span class="kw">def</span> register(<span class="va">self</span>):
            next_id <span class="op">=</span> get_next_id()
            bookings_db[next_id] <span class="op">=</span> {
            <span class="st">&#39;name&#39;</span>: guest.name,
            <span class="st">&#39;place&#39;</span>: guest.place,
            <span class="st">&#39;phone&#39;</span>: guest.phone
            }

    <span class="kw">class</span> Guest(<span class="bu">object</span>):

        implements(IGuest)

        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, name, place):
            <span class="va">self</span>.name <span class="op">=</span> name
            <span class="va">self</span>.place <span class="op">=</span> place

    jack <span class="op">=</span> Guest(<span class="st">&quot;Jack&quot;</span>, <span class="st">&quot;Bangalore&quot;</span>)
    jack_frontdesk <span class="op">=</span> FrontDeskNG(jack)

    IDesk.providedBy(jack_frontdesk)
<span class="va">True</span>

    <span class="im">from</span> zope.component <span class="im">import</span> getGlobalSiteManager
    gsm <span class="op">=</span> getGlobalSiteManager()
    gsm.registerAdapter(FrontDeskNG,
                        (IGuest,), IDesk, <span class="st">&#39;ng&#39;</span>)

    getAdapter(jack, IDesk, <span class="st">&#39;ng&#39;</span>)
<span class="op">&lt;</span>FrontDeskNG <span class="bu">object</span> at ...<span class="op">&gt;</span></code></pre></div>
</section>
<section id="getadapterincontext-getadapterincontext" class="level2 unnumbered">
<h2>getAdapterInContext [getadapterincontext]</h2>
<p>Вместо этой функции следует использовать аргумент <span><em>context</em></span> функции .</p>
<ul>
<li><p>Модуль: <code>zope.component</code></p></li>
<li><p>Спецификация: <span><em>getAdapterInContext(object, interface, context)</em></span></p></li>
<li><p>Смотри также:</p></li>
</ul>
<p>Пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.component.globalregistry <span class="im">import</span> BaseGlobalComponents
    <span class="im">from</span> zope.component <span class="im">import</span> IComponentLookup
    sm <span class="op">=</span> BaseGlobalComponents()

    <span class="kw">class</span> Context(<span class="bu">object</span>):
        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, sm):
            <span class="va">self</span>.sm <span class="op">=</span> sm
        <span class="kw">def</span> __conform__(<span class="va">self</span>, interface):
            <span class="cf">if</span> interface.isOrExtends(IComponentLookup):
                <span class="cf">return</span> <span class="va">self</span>.sm

    context <span class="op">=</span> Context(sm)

    <span class="im">from</span> zope.interface <span class="im">import</span> Attribute
    <span class="im">from</span> zope.interface <span class="im">import</span> Interface

    <span class="kw">class</span> IDesk(Interface):
        <span class="co">&quot;&quot;&quot;A frontdesk will register object&#39;s details&quot;&quot;&quot;</span>

        <span class="kw">def</span> register():
            <span class="co">&quot;&quot;&quot;Register object&#39;s details&quot;&quot;&quot;</span>


    <span class="im">from</span> zope.interface <span class="im">import</span> implements
    <span class="im">from</span> zope.component <span class="im">import</span> adapts

    <span class="kw">class</span> FrontDeskNG(<span class="bu">object</span>):

        implements(IDesk)
        adapts(IGuest)

        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, guest):
            <span class="va">self</span>.guest <span class="op">=</span> guest

        <span class="kw">def</span> register(<span class="va">self</span>):
            next_id <span class="op">=</span> get_next_id()
            bookings_db[next_id] <span class="op">=</span> {
            <span class="st">&#39;name&#39;</span>: guest.name,
            <span class="st">&#39;place&#39;</span>: guest.place,
            <span class="st">&#39;phone&#39;</span>: guest.phone
            }

    <span class="kw">class</span> Guest(<span class="bu">object</span>):

        implements(IGuest)

        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, name, place):
            <span class="va">self</span>.name <span class="op">=</span> name
            <span class="va">self</span>.place <span class="op">=</span> place

    jack <span class="op">=</span> Guest(<span class="st">&quot;Jack&quot;</span>, <span class="st">&quot;Bangalore&quot;</span>)
    jack_frontdesk <span class="op">=</span> FrontDeskNG(jack)

    IDesk.providedBy(jack_frontdesk)
<span class="va">True</span>

    <span class="im">from</span> zope.component <span class="im">import</span> getGlobalSiteManager
    gsm <span class="op">=</span> getGlobalSiteManager()
    sm.registerAdapter(FrontDeskNG,
                        (IGuest,), IDesk)

    <span class="im">from</span> zope.component <span class="im">import</span> getAdapterInContext

    getAdapterInContext(jack, IDesk, sm)
<span class="op">&lt;</span>FrontDeskNG <span class="bu">object</span> at ...<span class="op">&gt;</span></code></pre></div>
</section>
<section id="getadapters-getadapters" class="level2 unnumbered">
<h2>getAdapters [getadapters]</h2>
<p>Осуществляет поиск всех подходящих адаптеров к заданному интерфейсу и заданным объектам. Возвращает список адаптеров. Если в списке есть поименованный адаптер, то выдается наиболее специфический адаптер с заданным именем.</p>
<ul>
<li><p>Модуль: <code>zope.component</code></p></li>
<li><p>Спецификация: <span><em>getAdapters(objects, provided, context=None)</em></span></p></li>
</ul>
<p>Пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> implements
    <span class="im">from</span> zope.component <span class="im">import</span> adapts

    <span class="kw">class</span> FrontDeskNG(<span class="bu">object</span>):

        implements(IDesk)
        adapts(IGuest)

        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, guest):
            <span class="va">self</span>.guest <span class="op">=</span> guest

        <span class="kw">def</span> register(<span class="va">self</span>):
            next_id <span class="op">=</span> get_next_id()
            bookings_db[next_id] <span class="op">=</span> {
            <span class="st">&#39;name&#39;</span>: guest.name,
            <span class="st">&#39;place&#39;</span>: guest.place,
            <span class="st">&#39;phone&#39;</span>: guest.phone
            }

    jack <span class="op">=</span> Guest(<span class="st">&quot;Jack&quot;</span>, <span class="st">&quot;Bangalore&quot;</span>)
    jack_frontdesk <span class="op">=</span> FrontDeskNG(jack)

    <span class="im">from</span> zope.component <span class="im">import</span> getGlobalSiteManager
    gsm <span class="op">=</span> getGlobalSiteManager()

    gsm.registerAdapter(FrontDeskNG, name<span class="op">=</span><span class="st">&#39;ng&#39;</span>)

    <span class="im">from</span> zope.component <span class="im">import</span> getAdapters
    <span class="bu">list</span>(getAdapters((jack,), IDesk))
[(<span class="st">u&#39;ng&#39;</span>, <span class="op">&lt;</span>FrontDeskNG <span class="bu">object</span> at ...<span class="op">&gt;</span>)]</code></pre></div>
</section>
<section id="getallutilitiesregisteredfor-getallutilitiesregisteredfor" class="level2 unnumbered">
<h2>getAllUtilitiesRegisteredFor [getallutilitiesregisteredfor]</h2>
<p>Возвращает все зарегистрированные утилиты для заданного интерфейса, в том числе и те, которые были заменены (overridden). По возвращаемому значению можно осуществлять итерацию, где каждый элемент – это утилита.</p>
<ul>
<li><p>Модуль: <code>zope.component</code></p></li>
<li><p>Спецификация: <span><em>getAllUtilitiesRegisteredFor(interface)</em></span></p></li>
</ul>
<p>Пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Interface
    <span class="im">from</span> zope.interface <span class="im">import</span> implements

    <span class="kw">class</span> IGreeter(Interface):
        <span class="kw">def</span> greet(name):
            <span class="co">&quot;say hello&quot;</span>

    <span class="kw">class</span> Greeter(<span class="bu">object</span>):

        implements(IGreeter)

        <span class="kw">def</span> greet(<span class="va">self</span>, name):
            <span class="bu">print</span> <span class="st">&quot;Hello&quot;</span>, name

    <span class="im">from</span> zope.component <span class="im">import</span> getGlobalSiteManager
    gsm <span class="op">=</span> getGlobalSiteManager()

    greet <span class="op">=</span> Greeter()
    gsm.registerUtility(greet, IGreeter)

    <span class="im">from</span> zope.component <span class="im">import</span> getAllUtilitiesRegisteredFor

    getAllUtilitiesRegisteredFor(IGreeter)
[<span class="op">&lt;</span>Greeter <span class="bu">object</span> at ...<span class="op">&gt;</span>]</code></pre></div>
</section>
<section id="getfactoriesfor-getfactoriesfor" class="level2 unnumbered">
<h2>getFactoriesFor [getfactoriesfor]</h2>
<p>Возвращает список двоек (name, factory) зарегистрированных фабрик классов, реализующих заданный интерфейс.</p>
<blockquote>
<ul>
<li><p>Модуль: <code>zope.component</code></p></li>
<li><p>Спецификация: <span><em>getFactoriesFor(interface, context=None)</em></span></p></li>
</ul>
</blockquote>
<p>Пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Attribute
    <span class="im">from</span> zope.interface <span class="im">import</span> Interface
    <span class="im">from</span> zope.interface <span class="im">import</span> implements

    <span class="kw">class</span> IDatabase(Interface):

        <span class="kw">def</span> getConnection():
            <span class="co">&quot;&quot;&quot;Return connection object&quot;&quot;&quot;</span>

    <span class="kw">class</span> FakeDb(<span class="bu">object</span>):

        implements(IDatabase)

        <span class="kw">def</span> getConnection(<span class="va">self</span>):
            <span class="cf">return</span> <span class="st">&quot;connection&quot;</span>

    <span class="im">from</span> zope.component.factory <span class="im">import</span> Factory

    factory <span class="op">=</span> Factory(FakeDb, <span class="st">&#39;FakeDb&#39;</span>)

    <span class="im">from</span> zope.component <span class="im">import</span> getGlobalSiteManager
    gsm <span class="op">=</span> getGlobalSiteManager()

    <span class="im">from</span> zope.component.interfaces <span class="im">import</span> IFactory
    gsm.registerUtility(factory, IFactory, <span class="st">&#39;fakedb&#39;</span>)

    <span class="im">from</span> zope.component <span class="im">import</span> getFactoriesFor

    <span class="bu">list</span>(getFactoriesFor(IDatabase))
[(<span class="st">u&#39;fakedb&#39;</span>, <span class="op">&lt;</span>Factory <span class="cf">for</span> <span class="op">&lt;</span><span class="kw">class</span> <span class="st">&#39;FakeDb&#39;</span><span class="op">&gt;</span> ... <span class="op">&gt;</span>)]</code></pre></div>
</section>
<section id="getfactoryinterfaces-getfactoryinterfaces" class="level2 unnumbered">
<h2>getFactoryInterfaces [getfactoryinterfaces]</h2>
<p>Возвращает перечень интерфейсов, реализуемых фабрикой. Производит поиск по заданному имени фабрики, которая находится в ближайшем контексте, затем возвращает либо ее интерфейс, либо n&quot;=ку (tuple) интерфейсов, которые будут обслуживать объекты, создаваемые данной фабрикой.</p>
<ul>
<li><p>Модуль: <code>zope.component</code></p></li>
<li><p>Спецификация: <span><em>getFactoryInterfaces(name, context=None)</em></span></p></li>
</ul>
<p>Пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Attribute
    <span class="im">from</span> zope.interface <span class="im">import</span> Interface
    <span class="im">from</span> zope.interface <span class="im">import</span> implements

    <span class="kw">class</span> IDatabase(Interface):

        <span class="kw">def</span> getConnection():
            <span class="co">&quot;&quot;&quot;Return connection object&quot;&quot;&quot;</span>

    <span class="kw">class</span> FakeDb(<span class="bu">object</span>):

        implements(IDatabase)

        <span class="kw">def</span> getConnection(<span class="va">self</span>):
            <span class="cf">return</span> <span class="st">&quot;connection&quot;</span>

    <span class="im">from</span> zope.component.factory <span class="im">import</span> Factory

    factory <span class="op">=</span> Factory(FakeDb, <span class="st">&#39;FakeDb&#39;</span>)

    <span class="im">from</span> zope.component <span class="im">import</span> getGlobalSiteManager
    gsm <span class="op">=</span> getGlobalSiteManager()

    <span class="im">from</span> zope.component.interfaces <span class="im">import</span> IFactory
    gsm.registerUtility(factory, IFactory, <span class="st">&#39;fakedb&#39;</span>)

    <span class="im">from</span> zope.component <span class="im">import</span> getFactoryInterfaces

    getFactoryInterfaces(<span class="st">&#39;fakedb&#39;</span>)
<span class="op">&lt;</span>implementedBy __builtin__.FakeDb<span class="op">&gt;</span></code></pre></div>
</section>
<section id="getglobalsitemanager-getglobalsitemanager" class="level2 unnumbered">
<h2>getGlobalSiteManager [getglobalsitemanager]</h2>
<p>Функция возвращает глобальный регистр компонент (глобальный менеджер сайта). Эта функция всегда должна успешно выполнится. Возвращаемый регистр обслуживает интерфейс <span><em>IGlobalSiteManager</em></span>.</p>
<ul>
<li><p>Модуль: <code>zope.component</code></p></li>
<li><p>Спецификация: <span><em>getGlobalSiteManager()</em></span></p></li>
</ul>
<p>Пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.component <span class="im">import</span> getGlobalSiteManager
    <span class="im">from</span> zope.component <span class="im">import</span> globalSiteManager
    gsm <span class="op">=</span> getGlobalSiteManager()
    gsm <span class="kw">is</span> globalSiteManager
<span class="va">True</span></code></pre></div>
</section>
<section id="getmultiadapter-getmultiadapter" class="level2 unnumbered">
<h2>getMultiAdapter [getmultiadapter]</h2>
<p>Осуществляет поиск мультиадаптера (multi&quot;=adapter) к заданному интерфейсу и набору адаптируемых объектов. Возвращает мультиадаптер, который способен адаптировать эти объекты к указанному интерфейсу. Если такого адаптера найти не удается, то создается исключение <span><em>ComponentLookupError</em></span>. Пустое имя адаптера зарезервировано для непоименнованных адаптеров. Функции, реализующие поиск непоименнованных адаптеров, – это функции поиска адаптеров, где в качестве имени адаптера задается пустая строка.</p>
<ul>
<li><p>Модуль: <code>zope.component</code></p></li>
<li><p>Спецификация: <span><em>getMultiAdapter(objects, interface=Interface, name=”, context=None)</em></span></p></li>
<li><p>Смотри также:</p></li>
</ul>
<p>Пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Interface
    <span class="im">from</span> zope.interface <span class="im">import</span> implements
    <span class="im">from</span> zope.component <span class="im">import</span> adapts

    <span class="kw">class</span> IAdapteeOne(Interface):
        <span class="cf">pass</span>

    <span class="kw">class</span> IAdapteeTwo(Interface):
        <span class="cf">pass</span>

    <span class="kw">class</span> IFunctionality(Interface):
        <span class="cf">pass</span>

    <span class="kw">class</span> MyFunctionality(<span class="bu">object</span>):
        implements(IFunctionality)
        adapts(IAdapteeOne, IAdapteeTwo)

        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, one, two):
            <span class="va">self</span>.one <span class="op">=</span> one
            <span class="va">self</span>.two <span class="op">=</span> two

    <span class="im">from</span> zope.component <span class="im">import</span> getGlobalSiteManager
    gsm <span class="op">=</span> getGlobalSiteManager()

    gsm.registerAdapter(MyFunctionality)

    <span class="kw">class</span> One(<span class="bu">object</span>):
        implements(IAdapteeOne)

    <span class="kw">class</span> Two(<span class="bu">object</span>):
        implements(IAdapteeTwo)

    one <span class="op">=</span> One()
    two <span class="op">=</span> Two()

    <span class="im">from</span> zope.component <span class="im">import</span> getMultiAdapter

    getMultiAdapter((one,two), IFunctionality)
<span class="op">&lt;</span>MyFunctionality <span class="bu">object</span> at ...<span class="op">&gt;</span>

    myfunctionality <span class="op">=</span> getMultiAdapter((one,two), IFunctionality)
    myfunctionality.one
<span class="op">&lt;</span>One <span class="bu">object</span> at ...<span class="op">&gt;</span>
    myfunctionality.two
<span class="op">&lt;</span>Two <span class="bu">object</span> at ...<span class="op">&gt;</span></code></pre></div>
</section>
<section id="getsitemanager-getsitemanager" class="level2 unnumbered">
<h2>getSiteManager [getsitemanager]</h2>
<p>Возвращает регистр компонент (менеджер сайта), который является наиближайщем в заданном контексте. Если параметр <span><em>context</em></span> равен <span><em>None</em></span>, то возвращается глобальный регистр. Если параметр <span><em>context</em></span> не равен <span><em>None</em></span>, то предполагается, что найдется какой&quot;=либо адаптер из <span><em>context</em></span>-а <span><em>IComponentLookup</em></span>. Если же найти такой адаптер на самом деле не удалось, создается исключение <span><em>ComponentLookupError</em></span>.</p>
<ul>
<li><p>Модуль: <code>zope.component</code></p></li>
<li><p>Спецификация: <span><em>getSiteManager(context=None)</em></span></p></li>
</ul>
<p>Пример 1:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.component.globalregistry <span class="im">import</span> BaseGlobalComponents
    <span class="im">from</span> zope.component <span class="im">import</span> IComponentLookup
    sm <span class="op">=</span> BaseGlobalComponents()

    <span class="kw">class</span> Context(<span class="bu">object</span>):
        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, sm):
            <span class="va">self</span>.sm <span class="op">=</span> sm
        <span class="kw">def</span> __conform__(<span class="va">self</span>, interface):
            <span class="cf">if</span> interface.isOrExtends(IComponentLookup):
                <span class="cf">return</span> <span class="va">self</span>.sm

    context <span class="op">=</span> Context(sm)

    <span class="im">from</span> zope.component <span class="im">import</span> getSiteManager

    lsm <span class="op">=</span> getSiteManager(context)
    lsm <span class="kw">is</span> sm
<span class="va">True</span></code></pre></div>
<p>Пример 2:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.component <span class="im">import</span> getGlobalSiteManager
    gsm <span class="op">=</span> getGlobalSiteManager()

    sm <span class="op">=</span> getSiteManager()
    gsm <span class="kw">is</span> sm
<span class="va">True</span></code></pre></div>
</section>
<section id="getutilitiesfor-getutilitiesfor" class="level2 unnumbered">
<h2>getUtilitiesFor [getutilitiesfor]</h2>
<p>Осуществляет поиск зарегистрированных утилит, которые обслуживают заданный интерфейс. Возвращает объект, генерирующий двойки (name, utility).</p>
<ul>
<li><p>Модуль: <code>zope.component</code></p></li>
<li><p>Спецификация: <span><em>getUtilitiesFor(interface)</em></span></p></li>
</ul>
<p>Пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Interface
    <span class="im">from</span> zope.interface <span class="im">import</span> implements

    <span class="kw">class</span> IGreeter(Interface):
        <span class="kw">def</span> greet(name):
            <span class="co">&quot;say hello&quot;</span>

    <span class="kw">class</span> Greeter(<span class="bu">object</span>):

        implements(IGreeter)

        <span class="kw">def</span> greet(<span class="va">self</span>, name):
            <span class="bu">print</span> <span class="st">&quot;Hello&quot;</span>, name

    <span class="im">from</span> zope.component <span class="im">import</span> getGlobalSiteManager
    gsm <span class="op">=</span> getGlobalSiteManager()

    greet <span class="op">=</span> Greeter()
    gsm.registerUtility(greet, IGreeter)

    <span class="im">from</span> zope.component <span class="im">import</span> getUtilitiesFor

    <span class="bu">list</span>(getUtilitiesFor(IGreeter))
[(<span class="st">u&#39;&#39;</span>, <span class="op">&lt;</span>Greeter <span class="bu">object</span> at ...<span class="op">&gt;</span>)]</code></pre></div>
</section>
<section id="getutility-getutility" class="level2 unnumbered">
<h2>getUtility [getutility]</h2>
<p>Возвращает утилиту, которая обслуживает заданный интерфейс. Возвращает утилиту, которая находится в ближайшем из контекстов. Если такой утилиты не удается найти, то создается исключение <code>ComponentLookupError</code>.</p>
<ul>
<li><p>Модуль: <code>zope.component</code></p></li>
<li><p>Спецификация: <span><em>getUtility(interface, name=”, context=None)</em></span></p></li>
</ul>
<p>Пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Interface
    <span class="im">from</span> zope.interface <span class="im">import</span> implements

    <span class="kw">class</span> IGreeter(Interface):
        <span class="kw">def</span> greet(name):
            <span class="co">&quot;say hello&quot;</span>

    <span class="kw">class</span> Greeter(<span class="bu">object</span>):

        implements(IGreeter)

        <span class="kw">def</span> greet(<span class="va">self</span>, name):
            <span class="cf">return</span> <span class="st">&quot;Hello &quot;</span> <span class="op">+</span> name

    <span class="im">from</span> zope.component <span class="im">import</span> getGlobalSiteManager
    gsm <span class="op">=</span> getGlobalSiteManager()

    greet <span class="op">=</span> Greeter()
    gsm.registerUtility(greet, IGreeter)

    <span class="im">from</span> zope.component <span class="im">import</span> getUtility

    getUtility(IGreeter).greet(<span class="st">&#39;Jack&#39;</span>)
<span class="co">&#39;Hello~Jack&#39;</span></code></pre></div>
</section>
<section id="handle-handle" class="level2 unnumbered">
<h2>handle [handle]</h2>
<p>Запускает все обработчики (handlers) для заданных объектов. Обработчики – это фабрики адаптеров&quot;=подписчиков (subscription adapter), которые ничего не возвращают. Они просто выполняют некоторую процедуру. Обработчики обычно используются для реализации реакции на событие.</p>
<ul>
<li><p>Модуль: <code>zope.component</code></p></li>
<li><p>Спецификация: <span><em>handle(*objects)</em></span></p></li>
</ul>
<p>Пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">import</span> datetime

    <span class="kw">def</span> documentCreated(event):
        event.doc.created <span class="op">=</span> datetime.datetime.utcnow()

    <span class="im">from</span> zope.interface <span class="im">import</span> Interface
    <span class="im">from</span> zope.interface <span class="im">import</span> Attribute
    <span class="im">from</span> zope.interface <span class="im">import</span> implements

    <span class="kw">class</span> IDocumentCreated(Interface):
        doc <span class="op">=</span> Attribute(<span class="st">&quot;The document that was created&quot;</span>)

    <span class="kw">class</span> DocumentCreated(<span class="bu">object</span>):
        implements(IDocumentCreated)

        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, doc):
            <span class="va">self</span>.doc <span class="op">=</span> doc


    <span class="kw">def</span> documentCreated(event):
        event.doc.created <span class="op">=</span> datetime.datetime.utcnow()

    <span class="im">from</span> zope.component <span class="im">import</span> adapter

    <span class="at">@adapter</span>(IDocumentCreated)
    <span class="kw">def</span> documentCreated(event):
        event.doc.created <span class="op">=</span> datetime.datetime.utcnow()


    <span class="im">from</span> zope.component <span class="im">import</span> getGlobalSiteManager
    gsm <span class="op">=</span> getGlobalSiteManager()

    gsm.registerHandler(documentCreated)

    <span class="im">from</span> zope.component <span class="im">import</span> handle

    handle(DocumentCreated(doc))
    doc.created.__class__.<span class="va">__name__</span>
<span class="co">&#39;datetime&#39;</span></code></pre></div>
</section>
<section id="implementedby-implementedby" class="level2 unnumbered">
<h2>implementedBy [implementedby]</h2>
<p>Возвращает перечень интерфейсов, реализуемых заданным классом.</p>
<ul>
<li><p>Модуль: <code>zope.interface</code></p></li>
<li><p>Спецификация: <span><em>implementedBy(class_)</em></span></p></li>
</ul>
<p>Пример 1:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Interface
    <span class="im">from</span> zope.interface <span class="im">import</span> implements

    <span class="kw">class</span> IGreeter(Interface):
        <span class="kw">def</span> greet(name):
            <span class="co">&quot;say hello&quot;</span>

    <span class="kw">class</span> Greeter(<span class="bu">object</span>):

        implements(IGreeter)

        <span class="kw">def</span> greet(<span class="va">self</span>, name):
            <span class="bu">print</span> <span class="st">&quot;Hello&quot;</span>, name

    <span class="im">from</span> zope.interface <span class="im">import</span> implementedBy
    implementedBy(Greeter)
<span class="op">&lt;</span>implementedBy __builtin__.Greeter<span class="op">&gt;</span></code></pre></div>
<p>Пример 2:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Attribute
    <span class="im">from</span> zope.interface <span class="im">import</span> Interface
    <span class="im">from</span> zope.interface <span class="im">import</span> implements

    <span class="kw">class</span> IPerson(Interface):
        name <span class="op">=</span> Attribute(<span class="st">&quot;Name of person&quot;</span>)

    <span class="kw">class</span> ISpecial(Interface):
        <span class="cf">pass</span>

    <span class="kw">class</span> Person(<span class="bu">object</span>):
        implements(IPerson)
        name <span class="op">=</span> <span class="st">u&quot;&quot;</span>

    <span class="im">from</span> zope.interface <span class="im">import</span> classImplements
    classImplements(Person, ISpecial)

    <span class="im">from</span> zope.interface <span class="im">import</span> implementedBy

To get a <span class="bu">list</span> of <span class="bu">all</span> interfaces implemented by that <span class="kw">class</span>::

    [x.<span class="va">__name__</span> <span class="cf">for</span> x <span class="kw">in</span> implementedBy(Person)]
[<span class="st">&#39;IPerson&#39;</span>, <span class="st">&#39;ISpecial&#39;</span>]</code></pre></div>
</section>
<section id="implementer-implementer" class="level2 unnumbered">
<h2>implementer [implementer]</h2>
<p>Создает декоратор (decorator) для задания интерфейса, реализуемого фабрикой. Возвращает исполняемый объект (callable), которые представляет собой фабрику, обрамляющую объект, переданный декоратору в качестве параметра.</p>
<ul>
<li><p>Модуль: <code>zope.interface</code></p></li>
<li><p>Спецификация: <span><em>implementer(*interfaces)</em></span></p></li>
</ul>
<p>Пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> implementer
    <span class="kw">class</span> IFoo(Interface):
        <span class="cf">pass</span>
    <span class="kw">class</span> Foo(<span class="bu">object</span>):
        implements(IFoo)

    <span class="at">@implementer</span>(IFoo)
    <span class="kw">def</span> foocreator():
        foo <span class="op">=</span> Foo()
        <span class="cf">return</span> foo
    <span class="bu">list</span>(implementedBy(foocreator))
[<span class="op">&lt;</span>InterfaceClass __builtin__.IFoo<span class="op">&gt;</span>]</code></pre></div>
</section>
<section id="implements-implements" class="level2 unnumbered">
<h2>implements [implements]</h2>
<p>Функция вызывается внутри определения класса. Функция задает перечень интерфейсов, которые класс намеревается реализовать. Реализуемые интерфейсы задаются в качестве параметров функции. Заданные интерфейсы добавляются ранее декларированным, включая интерфейсы, получаемые при наследовании. Функция <span><em>implementsOnly</em></span> используется для задания перечня интерфейсов, при этом унаследованные и ранее декларированные интерфейсы заменяются.</p>
<ul>
<li><p>Модуль: <code>zope.interface</code></p></li>
<li><p>Спецификация: <span><em>implements(*interfaces)</em></span></p></li>
</ul>
<p>Пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Attribute
    <span class="im">from</span> zope.interface <span class="im">import</span> Interface
    <span class="im">from</span> zope.interface <span class="im">import</span> implements

    <span class="kw">class</span> IPerson(Interface):

        name <span class="op">=</span> Attribute(<span class="st">&quot;Name of person&quot;</span>)

    <span class="kw">class</span> Person(<span class="bu">object</span>):

        implements(IPerson)
        name <span class="op">=</span> <span class="st">u&quot;&quot;</span>

    jack <span class="op">=</span> Person()
    jack.name <span class="op">=</span> <span class="st">&quot;Jack&quot;</span>

You can test it like this:

    <span class="im">from</span> zope.interface <span class="im">import</span> providedBy
    IPerson <span class="kw">in</span> providedBy(jack)
<span class="va">True</span></code></pre></div>
</section>
<section id="implementsonly-implementsonly" class="level2 unnumbered">
<h2>implementsOnly [implementsonly]</h2>
<p>Задает перечень интерфейсов, реализуемых классом, при этом ранее сделанные и унаследованные декларации интерфейсов отменяются (overridden). Эта функция выполняется в процессе определения класса. Аргументы функции – декларируемые интерфейсы.</p>
<ul>
<li><p>Модуль: <code>zope.interface</code></p></li>
<li><p>Спецификация: <span><em>implementsOnly(*interfaces)</em></span></p></li>
</ul>
<p>Пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Attribute
    <span class="im">from</span> zope.interface <span class="im">import</span> Interface
    <span class="im">from</span> zope.interface <span class="im">import</span> implements
    <span class="im">from</span> zope.interface <span class="im">import</span> implementsOnly

    <span class="kw">class</span> IPerson(Interface):

        name <span class="op">=</span> Attribute(<span class="st">&quot;Name of person&quot;</span>)

    <span class="kw">class</span> IStudent(Interface):

        college <span class="op">=</span> Attribute(<span class="st">&quot;Name of college&quot;</span>)

    <span class="kw">class</span> Person(<span class="bu">object</span>):

        implements(IPerson)
        name <span class="op">=</span> <span class="st">u&quot;&quot;</span>

    <span class="kw">class</span> NewPerson(Person):
        implementsOnly(IStudent)
        college <span class="op">=</span> <span class="st">u&quot;&quot;</span>

    jack <span class="op">=</span> NewPerson()
    jack.college <span class="op">=</span> <span class="st">&quot;New College&quot;</span>

You can test it like this:

    <span class="im">from</span> zope.interface <span class="im">import</span> providedBy
    IPerson <span class="kw">in</span> providedBy(jack)
<span class="va">False</span>
    IStudent <span class="kw">in</span> providedBy(jack)
<span class="va">True</span></code></pre></div>
</section>
<section id="interface-interface" class="level2 unnumbered">
<h2>Interface [interface]</h2>
<p>При помощи данного класса задаются интерфейсы. Интерфейсы – это особые классы Python. Чтобы определить класс&quot;=интерфейс надо просто унаследовать <code>Interface</code>.</p>
<ul>
<li><p>Модуль: <code>zope.interface</code></p></li>
<li><p>Спецификация: <span><em>Interface(name, doc=”)</em></span></p></li>
</ul>
<p>Пример 1:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Attribute
    <span class="im">from</span> zope.interface <span class="im">import</span> Interface

    <span class="kw">class</span> IPerson(Interface):

        name <span class="op">=</span> Attribute(<span class="st">&quot;Name of person&quot;</span>)
        email <span class="op">=</span> Attribute(<span class="st">&quot;Email Address&quot;</span>)</code></pre></div>
<p>Пример 2:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Interface

    <span class="kw">class</span> IHost(Interface):

        <span class="kw">def</span> goodmorning(guest):
            <span class="co">&quot;&quot;&quot;Say good morning to guest&quot;&quot;&quot;</span></code></pre></div>
</section>
<section id="moduleprovides-moduleprovides" class="level2 unnumbered">
<h2>moduleProvides [moduleprovides]</h2>
<p>Определить модуль Python как объект, обслуживающий заданный интерфейс. Функция используется в тексте определения модуля. Аргументы – один или несколько интерфейсов. Исключительная ситуация создается в случае, если в модуле уже ранее встречалась такая декларация. Другими словами, в модуле декларация интерфейсов должна быть только одна.</p>
<p>Функция <span><em>moduleProvides</em></span> – это удобный вариант функции <code>directlyProvides</code>, применяемой к объекту&quot;=модулю.</p>
<ul>
<li><p>Модуль: <code>zope.interface</code></p></li>
<li><p>Спецификация: <span><em>moduleProvides(*interfaces)</em></span></p></li>
<li><p>Смотри также:</p></li>
</ul>
<p>В исходном коде модуля <span><em>zope.component</em></span> эта функция применяется, а именно, в файле <span><em>__init__.py</em></span> есть следующие операторы:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">moduleProvides(IComponentArchitecture,
               IComponentRegistrationConvenience)</code></pre></div>
<p>Таким образом, <span><em>zope.component</em></span> обслуживает два интерфейса: <span><em>IComponentArchitecture</em></span> и <span><em>IComponentRegistrationConvenience</em></span>.</p>
</section>
<section id="nolongerprovides-nolongerprovides" class="level2 unnumbered">
<h2>noLongerProvides [nolongerprovides]</h2>
<p>Исключить заданный интерфейс из списка интерфейсов, обслуживаемых объектом.</p>
<ul>
<li><p>Модуль: <code>zope.interface</code></p></li>
<li><p>Спецификация: <span><em>noLongerProvides(object, interface)</em></span></p></li>
</ul>
<p>Пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Attribute
    <span class="im">from</span> zope.interface <span class="im">import</span> Interface
    <span class="im">from</span> zope.interface <span class="im">import</span> implements
    <span class="im">from</span> zope.interface <span class="im">import</span> classImplements

    <span class="kw">class</span> IPerson(Interface):

        name <span class="op">=</span> Attribute(<span class="st">&quot;Name of person&quot;</span>)

    <span class="kw">class</span> IStudent(Interface):

        college <span class="op">=</span> Attribute(<span class="st">&quot;Name of college&quot;</span>)

    <span class="kw">class</span> Person(<span class="bu">object</span>):

        implements(IPerson)
        name <span class="op">=</span> <span class="st">u&quot;&quot;</span>

    jack <span class="op">=</span> Person()
    jack.name <span class="op">=</span> <span class="st">&quot;Jack&quot;</span>
    jack.college <span class="op">=</span> <span class="st">&quot;New College&quot;</span>
    directlyProvides(jack, IStudent)

You can test it like this:

    <span class="im">from</span> zope.interface <span class="im">import</span> providedBy
    IPerson <span class="kw">in</span> providedBy(jack)
<span class="va">True</span>
    IStudent <span class="kw">in</span> providedBy(jack)
<span class="va">True</span>
    <span class="im">from</span> zope.interface <span class="im">import</span> noLongerProvides
    noLongerProvides(jack, IStudent)
    IPerson <span class="kw">in</span> providedBy(jack)
<span class="va">True</span>
    IStudent <span class="kw">in</span> providedBy(jack)
<span class="va">False</span></code></pre></div>
</section>
<section id="provideadapter-provideadapter" class="level2 unnumbered">
<h2>provideAdapter [provideadapter]</h2>
<p>Вместо этой функции рекомендовано использовать функцию .</p>
</section>
<section id="providehandler-providehandler" class="level2 unnumbered">
<h2>provideHandler [providehandler]</h2>
<p>Вместо этой функции рекомендовано использовать функцию .</p>
</section>
<section id="providesubscriptionadapter-providesubscriptionadapter" class="level2 unnumbered">
<h2>provideSubscriptionAdapter [providesubscriptionadapter]</h2>
<p>Вместо этой функции рекомендовано использовать функцию .</p>
</section>
<section id="provideutility-provideutility" class="level2 unnumbered">
<h2>provideUtility [provideutility]</h2>
<p>Вместо этой функции рекомендовано использовать функцию .</p>
</section>
<section id="providedby-providedby" class="level2 unnumbered">
<h2>providedBy [providedby]</h2>
<p>Функция проверят, обслуживает ли объект указанный интерфейс. Возвращается <span><em>истина</em></span>, если это так, в том числе, если объект обслуживает этот интерфейс через наследование интерфейсов.</p>
<ul>
<li><p>Модуль: <code>zope.interface</code></p></li>
<li><p>Спецификация: <span><em>providedBy(object)</em></span></p></li>
</ul>
<p>Пример 1:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Attribute
    <span class="im">from</span> zope.interface <span class="im">import</span> Interface
    <span class="im">from</span> zope.interface <span class="im">import</span> implements

    <span class="kw">class</span> IPerson(Interface):

        name <span class="op">=</span> Attribute(<span class="st">&quot;Name of person&quot;</span>)

    <span class="kw">class</span> Person(<span class="bu">object</span>):

        implements(IPerson)
        name <span class="op">=</span> <span class="st">u&quot;&quot;</span>

    jack <span class="op">=</span> Person()
    jack.name <span class="op">=</span> <span class="st">&quot;Jack&quot;</span>

Результат проверяется следующим образом:

    <span class="im">from</span> zope.interface <span class="im">import</span> providedBy
    IPerson <span class="kw">in</span> providedBy(jack)
<span class="va">True</span></code></pre></div>
<p>Пример 2:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Attribute
    <span class="im">from</span> zope.interface <span class="im">import</span> Interface
    <span class="im">from</span> zope.interface <span class="im">import</span> implements

    <span class="kw">class</span> IPerson(Interface):
        name <span class="op">=</span> Attribute(<span class="st">&quot;Name of person&quot;</span>)

    <span class="kw">class</span> ISpecial(Interface):
        <span class="cf">pass</span>

    <span class="kw">class</span> Person(<span class="bu">object</span>):
        implements(IPerson)
        name <span class="op">=</span> <span class="st">u&quot;&quot;</span>

    <span class="im">from</span> zope.interface <span class="im">import</span> classImplements
    classImplements(Person, ISpecial)
    <span class="im">from</span> zope.interface <span class="im">import</span> providedBy
    jack <span class="op">=</span> Person()
    jack.name <span class="op">=</span> <span class="st">&quot;Jack&quot;</span>

Следующий код позволяет получить полный перечень интерфейсов,
обслуживаемых объектом::

    [x.<span class="va">__name__</span> <span class="cf">for</span> x <span class="kw">in</span> providedBy(jack)]
[<span class="st">&#39;IPerson&#39;</span>, <span class="st">&#39;ISpecial&#39;</span>]</code></pre></div>
</section>
<section id="queryadapter-queryadapter" class="level2 unnumbered">
<h2>queryAdapter [queryadapter]</h2>
<p>Производит поиск адаптера к заданному интерфейсу для заданного объекта. Возвращает подходящий адаптер, если такого адаптера нет, то возвратить значение, заданное параметром <span><em>default</em></span>.</p>
<ul>
<li><p>Модуль: <code>zope.component</code></p></li>
<li><p>Спецификация: <span><em>queryAdapter(object, interface=Interface, name=u”, default=None, context=None)</em></span></p></li>
</ul>
<p>Пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Attribute
    <span class="im">from</span> zope.interface <span class="im">import</span> Interface

    <span class="kw">class</span> IDesk(Interface):
        <span class="co">&quot;&quot;&quot;A frontdesk will register object&#39;s details&quot;&quot;&quot;</span>

        <span class="kw">def</span> register():
            <span class="co">&quot;&quot;&quot;Register object&#39;s details&quot;&quot;&quot;</span>


    <span class="im">from</span> zope.interface <span class="im">import</span> implements
    <span class="im">from</span> zope.component <span class="im">import</span> adapts

    <span class="kw">class</span> FrontDeskNG(<span class="bu">object</span>):

        implements(IDesk)
        adapts(IGuest)

        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, guest):
            <span class="va">self</span>.guest <span class="op">=</span> guest

        <span class="kw">def</span> register(<span class="va">self</span>):
            next_id <span class="op">=</span> get_next_id()
            bookings_db[next_id] <span class="op">=</span> {
            <span class="st">&#39;name&#39;</span>: guest.name,
            <span class="st">&#39;place&#39;</span>: guest.place,
            <span class="st">&#39;phone&#39;</span>: guest.phone
            }

    <span class="kw">class</span> Guest(<span class="bu">object</span>):

        implements(IGuest)

        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, name, place):
            <span class="va">self</span>.name <span class="op">=</span> name
            <span class="va">self</span>.place <span class="op">=</span> place

    jack <span class="op">=</span> Guest(<span class="st">&quot;Jack&quot;</span>, <span class="st">&quot;Bangalore&quot;</span>)
    jack_frontdesk <span class="op">=</span> FrontDeskNG(jack)

    IDesk.providedBy(jack_frontdesk)
<span class="va">True</span>

    <span class="im">from</span> zope.component <span class="im">import</span> getGlobalSiteManager
    gsm <span class="op">=</span> getGlobalSiteManager()
    gsm.registerAdapter(FrontDeskNG,
                        (IGuest,), IDesk, <span class="st">&#39;ng&#39;</span>)

    queryAdapter(jack, IDesk, <span class="st">&#39;ng&#39;</span>)
<span class="op">&lt;</span>FrontDeskNG <span class="bu">object</span> at ...<span class="op">&gt;</span></code></pre></div>
</section>
<section id="queryadapterincontext-queryadapterincontext" class="level2 unnumbered">
<h2>queryAdapterInContext [queryadapterincontext]</h2>
<p>Осуществляет поиск адаптера специального вида к заданному интерфейсу для заданного объекта.</p>
<p>NOTE: Этот метод должен вызываться только в специальных случаях, когда по каким&quot;=либо причинам следует изменить обычный механизм получения доступа к компонентам. Иначе следует применять функцию <span><em>interface</em></span>, как в этом примере:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">interface(<span class="bu">object</span>,<span class="op">~</span>default)</code></pre></div>
<p>Функция возвращает адаптер, который способен адаптировать заданный объект к заданному интерфейсу. Если такого адаптера не удается найти, то возвращается значение, указанное в параметре <span><em>default</em></span>.</p>
<p>Контекст адаптируется к интерфейсу <span><em>IServiceService</em></span>, полученный адаптер используется как сервис.</p>
<p>Если объект, переданный в параметр, включает метод <span><em>__conform__</em></span>, этот метод вызывается с запрашиваемым интерфейсом в качестве параметра. Если метод возвращает значение, отличное от <span><em>None</em></span>, это значение и возвращается. Иначе, если объект и так реализует заданный интерфейс, то он сам и будет возвращен.</p>
<ul>
<li><p>Модуль: <code>zope.component</code></p></li>
<li><p>Спецификация: <span><em>queryAdapterInContext(object, interface, context, default=None)</em></span></p></li>
<li><p>Смотри также:</p></li>
</ul>
<p>Пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.component.globalregistry <span class="im">import</span> BaseGlobalComponents
    <span class="im">from</span> zope.component <span class="im">import</span> IComponentLookup
    sm <span class="op">=</span> BaseGlobalComponents()

    <span class="kw">class</span> Context(<span class="bu">object</span>):
        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, sm):
            <span class="va">self</span>.sm <span class="op">=</span> sm
        <span class="kw">def</span> __conform__(<span class="va">self</span>, interface):
            <span class="cf">if</span> interface.isOrExtends(IComponentLookup):
                <span class="cf">return</span> <span class="va">self</span>.sm

    context <span class="op">=</span> Context(sm)

    <span class="im">from</span> zope.interface <span class="im">import</span> Attribute
    <span class="im">from</span> zope.interface <span class="im">import</span> Interface

    <span class="kw">class</span> IDesk(Interface):
        <span class="co">&quot;&quot;&quot;A frontdesk will register object&#39;s details&quot;&quot;&quot;</span>

        <span class="kw">def</span> register():
            <span class="co">&quot;&quot;&quot;Register object&#39;s details&quot;&quot;&quot;</span>


    <span class="im">from</span> zope.interface <span class="im">import</span> implements
    <span class="im">from</span> zope.component <span class="im">import</span> adapts

    <span class="kw">class</span> FrontDeskNG(<span class="bu">object</span>):

        implements(IDesk)
        adapts(IGuest)

        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, guest):
            <span class="va">self</span>.guest <span class="op">=</span> guest

        <span class="kw">def</span> register(<span class="va">self</span>):
            next_id <span class="op">=</span> get_next_id()
            bookings_db[next_id] <span class="op">=</span> {
            <span class="st">&#39;name&#39;</span>: guest.name,
            <span class="st">&#39;place&#39;</span>: guest.place,
            <span class="st">&#39;phone&#39;</span>: guest.phone
            }

    <span class="kw">class</span> Guest(<span class="bu">object</span>):

        implements(IGuest)

        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, name, place):
            <span class="va">self</span>.name <span class="op">=</span> name
            <span class="va">self</span>.place <span class="op">=</span> place

    jack <span class="op">=</span> Guest(<span class="st">&quot;Jack&quot;</span>, <span class="st">&quot;Bangalore&quot;</span>)
    jack_frontdesk <span class="op">=</span> FrontDeskNG(jack)

    IDesk.providedBy(jack_frontdesk)
<span class="va">True</span>

    <span class="im">from</span> zope.component <span class="im">import</span> getGlobalSiteManager
    gsm <span class="op">=</span> getGlobalSiteManager()
    sm.registerAdapter(FrontDeskNG,
                        (IGuest,), IDesk)

    <span class="im">from</span> zope.component <span class="im">import</span> queryAdapterInContext

    queryAdapterInContext(jack, IDesk, sm)
<span class="op">&lt;</span>FrontDeskNG <span class="bu">object</span> at ...<span class="op">&gt;</span></code></pre></div>
</section>
<section id="querymultiadapter-querymultiadapter" class="level2 unnumbered">
<h2>queryMultiAdapter [querymultiadapter]</h2>
<p>Осуществляет поиск мультиадаптера (multi&quot;=adapter) к заданному интерфейсу и набору адаптируемых объектов. Возвращает мультиадаптер, который способен адаптировать эти объекты к указанному интерфейсу. Если такого адаптера найти не удается, возвращается значение, переданное в параметре <span><em>default</em></span>. Пустое имя адаптера зарезервировано для непоименнованных адаптеров. Функции, реализующие поиск непоименнованных адаптеров, – это функции поиска адаптеров, где в качестве имени адаптера задается пустая строка.</p>
<ul>
<li><p>Модуль: <code>zope.component</code></p></li>
<li><p>Спецификация: <span><em>queryMultiAdapter(objects, interface=Interface, name=u”, default=None, context=None)</em></span></p></li>
<li><p>Смотри также:</p></li>
</ul>
<p>Пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Interface
    <span class="im">from</span> zope.interface <span class="im">import</span> implements
    <span class="im">from</span> zope.component <span class="im">import</span> adapts

    <span class="kw">class</span> IAdapteeOne(Interface):
        <span class="cf">pass</span>

    <span class="kw">class</span> IAdapteeTwo(Interface):
        <span class="cf">pass</span>

    <span class="kw">class</span> IFunctionality(Interface):
        <span class="cf">pass</span>

    <span class="kw">class</span> MyFunctionality(<span class="bu">object</span>):
        implements(IFunctionality)
        adapts(IAdapteeOne, IAdapteeTwo)

        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, one, two):
            <span class="va">self</span>.one <span class="op">=</span> one
            <span class="va">self</span>.two <span class="op">=</span> two

    <span class="im">from</span> zope.component <span class="im">import</span> getGlobalSiteManager
    gsm <span class="op">=</span> getGlobalSiteManager()

    gsm.registerAdapter(MyFunctionality)

    <span class="kw">class</span> One(<span class="bu">object</span>):
        implements(IAdapteeOne)

    <span class="kw">class</span> Two(<span class="bu">object</span>):
        implements(IAdapteeTwo)

    one <span class="op">=</span> One()
    two <span class="op">=</span> Two()

    <span class="im">from</span> zope.component <span class="im">import</span> queryMultiAdapter

    getMultiAdapter((one,two), IFunctionality)
<span class="op">&lt;</span>MyFunctionality <span class="bu">object</span> at ...<span class="op">&gt;</span>

    myfunctionality <span class="op">=</span> queryMultiAdapter((one,two), IFunctionality)
    myfunctionality.one
<span class="op">&lt;</span>One <span class="bu">object</span> at ...<span class="op">&gt;</span>
    myfunctionality.two
<span class="op">&lt;</span>Two <span class="bu">object</span> at ...<span class="op">&gt;</span></code></pre></div>
</section>
<section id="queryutility-queryutility" class="level2 unnumbered">
<h2>queryUtility [queryutility]</h2>
<p>Функция используется для поиска утилиты, которая обслуживает заданный интерфейс. Если такой утилиты не удается найти, то возвращается значение, переданное в параметре <span><em>default</em></span>.</p>
<ul>
<li><p>Модуль: <code>zope.component</code></p></li>
<li><p>Спецификация: <span><em>queryUtility(interface, name=”, default=None)</em></span></p></li>
</ul>
<p>Пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Interface
    <span class="im">from</span> zope.interface <span class="im">import</span> implements

    <span class="kw">class</span> IGreeter(Interface):
        <span class="kw">def</span> greet(name):
            <span class="co">&quot;say hello&quot;</span>

    <span class="kw">class</span> Greeter(<span class="bu">object</span>):

        implements(IGreeter)

        <span class="kw">def</span> greet(<span class="va">self</span>, name):
            <span class="cf">return</span> <span class="st">&quot;Hello &quot;</span> <span class="op">+</span> name

    <span class="im">from</span> zope.component <span class="im">import</span> getGlobalSiteManager
    gsm <span class="op">=</span> getGlobalSiteManager()

    greet <span class="op">=</span> Greeter()
    gsm.registerUtility(greet, IGreeter)

    <span class="im">from</span> zope.component <span class="im">import</span> queryUtility

    queryUtility(IGreeter).greet(<span class="st">&#39;Jack&#39;</span>)
<span class="co">&#39;Hello Jack&#39;</span></code></pre></div>
</section>
<section id="registeradapter-registeradapter" class="level2 unnumbered">
<h2>registerAdapter [registeradapter]</h2>
<p>Эта функция используется для регистрации фабрики адаптеров.</p>
<ul>
<li><p>Модуль: <code>zope.component - IComponentRegistry</code></p></li>
<li><p>Спецификация: <span><em>registerAdapter(factory, required=None, provided=None, name=u”, info=u”)</em></span></p></li>
<li><p>Смотри также:</p></li>
</ul>
<p>Пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Attribute
    <span class="im">from</span> zope.interface <span class="im">import</span> Interface

    <span class="kw">class</span> IDesk(Interface):
        <span class="co">&quot;&quot;&quot;A frontdesk will register object&#39;s details&quot;&quot;&quot;</span>

        <span class="kw">def</span> register():
            <span class="co">&quot;&quot;&quot;Register object&#39;s details&quot;&quot;&quot;</span>


    <span class="im">from</span> zope.interface <span class="im">import</span> implements
    <span class="im">from</span> zope.component <span class="im">import</span> adapts

    <span class="kw">class</span> FrontDeskNG(<span class="bu">object</span>):

        implements(IDesk)
        adapts(IGuest)

        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, guest):
            <span class="va">self</span>.guest <span class="op">=</span> guest

        <span class="kw">def</span> register(<span class="va">self</span>):
            next_id <span class="op">=</span> get_next_id()
            bookings_db[next_id] <span class="op">=</span> {
            <span class="st">&#39;name&#39;</span>: guest.name,
            <span class="st">&#39;place&#39;</span>: guest.place,
            <span class="st">&#39;phone&#39;</span>: guest.phone
            }

    <span class="kw">class</span> Guest(<span class="bu">object</span>):

        implements(IGuest)

        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, name, place):
            <span class="va">self</span>.name <span class="op">=</span> name
            <span class="va">self</span>.place <span class="op">=</span> place

    jack <span class="op">=</span> Guest(<span class="st">&quot;Jack&quot;</span>, <span class="st">&quot;Bangalore&quot;</span>)
    jack_frontdesk <span class="op">=</span> FrontDeskNG(jack)

    IDesk.providedBy(jack_frontdesk)
<span class="va">True</span>

    <span class="im">from</span> zope.component <span class="im">import</span> getGlobalSiteManager
    gsm <span class="op">=</span> getGlobalSiteManager()
    gsm.registerAdapter(FrontDeskNG,
                        (IGuest,), IDesk, <span class="st">&#39;ng&#39;</span>)

Результат тестируется следующим образом:

    queryAdapter(jack, IDesk, <span class="st">&#39;ng&#39;</span>)
<span class="op">&lt;</span>FrontDeskNG <span class="bu">object</span> at ...<span class="op">&gt;</span></code></pre></div>
</section>
<section id="registeredadapters-registeredadapters" class="level2 unnumbered">
<h2>registeredAdapters [registeredadapters]</h2>
<p>Возвращает генератор <span><em>IAdapterRegistrations</em></span>, элементы которого описывают существующие зарегистрированные фабрики адаптеров.</p>
<ul>
<li><p>Модуль: <code>zope.component - IComponentRegistry</code></p></li>
<li><p>Спецификация: <span><em>registeredAdapters()</em></span></p></li>
</ul>
<p>Пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Attribute
    <span class="im">from</span> zope.interface <span class="im">import</span> Interface

    <span class="kw">class</span> IDesk(Interface):
        <span class="co">&quot;&quot;&quot;A frontdesk will register object&#39;s details&quot;&quot;&quot;</span>

        <span class="kw">def</span> register():
            <span class="co">&quot;&quot;&quot;Register object&#39;s details&quot;&quot;&quot;</span>


    <span class="im">from</span> zope.interface <span class="im">import</span> implements
    <span class="im">from</span> zope.component <span class="im">import</span> adapts

    <span class="kw">class</span> FrontDeskNG(<span class="bu">object</span>):

        implements(IDesk)
        adapts(IGuest)

        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, guest):
            <span class="va">self</span>.guest <span class="op">=</span> guest

        <span class="kw">def</span> register(<span class="va">self</span>):
            next_id <span class="op">=</span> get_next_id()
            bookings_db[next_id] <span class="op">=</span> {
            <span class="st">&#39;name&#39;</span>: guest.name,
            <span class="st">&#39;place&#39;</span>: guest.place,
            <span class="st">&#39;phone&#39;</span>: guest.phone
            }

    <span class="kw">class</span> Guest(<span class="bu">object</span>):

        implements(IGuest)

        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, name, place):
            <span class="va">self</span>.name <span class="op">=</span> name
            <span class="va">self</span>.place <span class="op">=</span> place

    jack <span class="op">=</span> Guest(<span class="st">&quot;Jack&quot;</span>, <span class="st">&quot;Bangalore&quot;</span>)
    jack_frontdesk <span class="op">=</span> FrontDeskNG(jack)

    IDesk.providedBy(jack_frontdesk)
<span class="va">True</span>

    <span class="im">from</span> zope.component <span class="im">import</span> getGlobalSiteManager
    gsm <span class="op">=</span> getGlobalSiteManager()
    gsm.registerAdapter(FrontDeskNG,
                        (IGuest,), IDesk, <span class="st">&#39;ng2&#39;</span>)


    reg_adapter <span class="op">=</span> <span class="bu">list</span>(gsm.registeredAdapters())
    <span class="co">&#39;ng2&#39;</span> <span class="kw">in</span> [x.name <span class="cf">for</span> x <span class="kw">in</span> reg_adapter]
<span class="va">True</span></code></pre></div>
</section>
<section id="registeredhandlers-registeredhandlers" class="level2 unnumbered">
<h2>registeredHandlers [registeredhandlers]</h2>
<p>Возвращает генератор <span><em>IHandlerRegistrations</em></span>, элементы которого описывают зарегистрированные обработчики.</p>
<ul>
<li><p>Модуль: <code>zope.component - IComponentRegistry</code></p></li>
<li><p>Спецификация: <span><em>registeredHandlers()</em></span></p></li>
</ul>
<p>Пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">import</span> datetime

    <span class="kw">def</span> documentCreated(event):
        event.doc.created <span class="op">=</span> datetime.datetime.utcnow()

    <span class="im">from</span> zope.interface <span class="im">import</span> Interface
    <span class="im">from</span> zope.interface <span class="im">import</span> Attribute
    <span class="im">from</span> zope.interface <span class="im">import</span> implements

    <span class="kw">class</span> IDocumentCreated(Interface):
        doc <span class="op">=</span> Attribute(<span class="st">&quot;The document that was created&quot;</span>)

    <span class="kw">class</span> DocumentCreated(<span class="bu">object</span>):
        implements(IDocumentCreated)

        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, doc):
            <span class="va">self</span>.doc <span class="op">=</span> doc


    <span class="kw">def</span> documentCreated(event):
        event.doc.created <span class="op">=</span> datetime.datetime.utcnow()

    <span class="im">from</span> zope.component <span class="im">import</span> adapter

    <span class="at">@adapter</span>(IDocumentCreated)
    <span class="kw">def</span> documentCreated(event):
        event.doc.created <span class="op">=</span> datetime.datetime.utcnow()


    <span class="im">from</span> zope.component <span class="im">import</span> getGlobalSiteManager
    gsm <span class="op">=</span> getGlobalSiteManager()

    gsm.registerHandler(documentCreated, info<span class="op">=</span><span class="st">&#39;ng3&#39;</span>)

    reg_adapter <span class="op">=</span> <span class="bu">list</span>(gsm.registeredHandlers())
    <span class="co">&#39;ng3&#39;</span> <span class="kw">in</span> [x.info <span class="cf">for</span> x <span class="kw">in</span> reg_adapter]
<span class="va">True</span>

    gsm.registerHandler(documentCreated, name<span class="op">=</span><span class="st">&#39;ng4&#39;</span>)
Traceback (most recent call last):

<span class="pp">TypeError</span>: Named handlers are <span class="kw">not</span> yet supported</code></pre></div>
</section>
<section id="registeredsubscriptionadapters-registeredsubscriptionadapters" class="level2 unnumbered">
<h2>registeredSubscriptionAdapters [registeredsubscriptionadapters]</h2>
<p>Возвращает генератор <span><em>ISubscriptionAdapterRegistrations</em></span>, элементы которого описывают зарегистрированные адаптеры&quot;=подписчики.</p>
<ul>
<li><p>Модуль: <code>zope.component - IComponentRegistry</code></p></li>
<li><p>Спецификация: <span><em>registeredSubscriptionAdapters()</em></span></p></li>
</ul>
<p>Пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Interface
    <span class="im">from</span> zope.interface <span class="im">import</span> Attribute
    <span class="im">from</span> zope.interface <span class="im">import</span> implements

    <span class="kw">class</span> IValidate(Interface):
        <span class="kw">def</span> validate(ob):
            <span class="co">&quot;&quot;&quot;Determine whether the object is valid</span>

<span class="co">            Return a string describing a validation problem.</span>
<span class="co">            An empty string is returned to indicate that the</span>
<span class="co">            object is valid.</span>
<span class="co">            &quot;&quot;&quot;</span>

    <span class="kw">class</span> IDocument(Interface):
        summary <span class="op">=</span> Attribute(<span class="st">&quot;Document summary&quot;</span>)
        body <span class="op">=</span> Attribute(<span class="st">&quot;Document text&quot;</span>)

    <span class="kw">class</span> Document(<span class="bu">object</span>):
        implements(IDocument)
        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, summary, body):
            <span class="va">self</span>.summary, <span class="va">self</span>.body <span class="op">=</span> summary, body

    <span class="im">from</span> zope.component <span class="im">import</span> adapts

    <span class="kw">class</span> AdequateLength(<span class="bu">object</span>):

        adapts(IDocument)
        implements(IValidate)

        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, doc):
            <span class="va">self</span>.doc <span class="op">=</span> doc

        <span class="kw">def</span> validate(<span class="va">self</span>):
            <span class="cf">if</span> <span class="bu">len</span>(<span class="va">self</span>.doc.body) <span class="op">&lt;</span> <span class="dv">1000</span>:
                <span class="cf">return</span> <span class="st">&#39;too short&#39;</span>
            <span class="cf">else</span>:
                <span class="cf">return</span> <span class="st">&#39;&#39;</span>

    <span class="im">from</span> zope.component <span class="im">import</span> getGlobalSiteManager
    gsm <span class="op">=</span> getGlobalSiteManager()

    gsm.registerSubscriptionAdapter(AdequateLength, info<span class="op">=</span><span class="st">&#39;ng4&#39;</span>)

    reg_adapter <span class="op">=</span> <span class="bu">list</span>(gsm.registeredSubscriptionAdapters())
    <span class="co">&#39;ng4&#39;</span> <span class="kw">in</span> [x.info <span class="cf">for</span> x <span class="kw">in</span> reg_adapter]
<span class="va">True</span></code></pre></div>
</section>
<section id="registeredutilities-registeredutilities" class="level2 unnumbered">
<h2>registeredUtilities [registeredutilities]</h2>
<p>Эта функция возвращает генератор <span><em>IUtilityRegistrations</em></span>, элементы которого описывают зарегистрированные утилиты.</p>
<ul>
<li><p>Модуль: <code>zope.component - IComponentRegistry</code></p></li>
<li><p>Спецификация: <span><em>registeredUtilities()</em></span></p></li>
</ul>
<p>Пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Interface
    <span class="im">from</span> zope.interface <span class="im">import</span> implements

    <span class="kw">class</span> IGreeter(Interface):
        <span class="kw">def</span> greet(name):
            <span class="co">&quot;say hello&quot;</span>

    <span class="kw">class</span> Greeter(<span class="bu">object</span>):

        implements(IGreeter)

        <span class="kw">def</span> greet(<span class="va">self</span>, name):
            <span class="bu">print</span> <span class="st">&quot;Hello&quot;</span>, name

    <span class="im">from</span> zope.component <span class="im">import</span> getGlobalSiteManager
    gsm <span class="op">=</span> getGlobalSiteManager()

    greet <span class="op">=</span> Greeter()
    gsm.registerUtility(greet, info<span class="op">=</span><span class="st">&#39;ng5&#39;</span>)

    reg_adapter <span class="op">=</span> <span class="bu">list</span>(gsm.registeredUtilities())
    <span class="co">&#39;ng5&#39;</span> <span class="kw">in</span> [x.info <span class="cf">for</span> x <span class="kw">in</span> reg_adapter]
<span class="va">True</span></code></pre></div>
</section>
<section id="registerhandler-registerhandler" class="level2 unnumbered">
<h2>registerHandler [registerhandler]</h2>
<p>Функция позволяет регистрировать обработчики (handlers). Обработчик – это адаптер&quot;=подписчик (subscription adapter), который ничего не возвращает, только выполняет заданную процедуру.</p>
<ul>
<li><p>Модуль: <code>zope.component - IComponentRegistry</code></p></li>
<li><p>Спецификация: <span><em>registerHandler(handler, required=None, name=u”, info=”)</em></span></p></li>
<li><p>Смотри также:</p></li>
</ul>
<p>Замечание: В современной реализации модуля <code>zope.component</code> пока нет поддержки поименованных подписчиков.</p>
<p>Пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">import</span> datetime

    <span class="kw">def</span> documentCreated(event):
        event.doc.created <span class="op">=</span> datetime.datetime.utcnow()

    <span class="im">from</span> zope.interface <span class="im">import</span> Interface
    <span class="im">from</span> zope.interface <span class="im">import</span> Attribute
    <span class="im">from</span> zope.interface <span class="im">import</span> implements

    <span class="kw">class</span> IDocumentCreated(Interface):
        doc <span class="op">=</span> Attribute(<span class="st">&quot;The document that was created&quot;</span>)

    <span class="kw">class</span> DocumentCreated(<span class="bu">object</span>):
        implements(IDocumentCreated)

        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, doc):
            <span class="va">self</span>.doc <span class="op">=</span> doc


    <span class="kw">def</span> documentCreated(event):
        event.doc.created <span class="op">=</span> datetime.datetime.utcnow()

    <span class="im">from</span> zope.component <span class="im">import</span> adapter

    <span class="at">@adapter</span>(IDocumentCreated)
    <span class="kw">def</span> documentCreated(event):
        event.doc.created <span class="op">=</span> datetime.datetime.utcnow()


    <span class="im">from</span> zope.component <span class="im">import</span> getGlobalSiteManager
    gsm <span class="op">=</span> getGlobalSiteManager()

    gsm.registerHandler(documentCreated)

    <span class="im">from</span> zope.component <span class="im">import</span> handle

    handle(DocumentCreated(doc))
    doc.created.__class__.<span class="va">__name__</span>
<span class="co">&#39;datetime&#39;</span></code></pre></div>
</section>
<section id="registersubscriptionadapter-registersubscriptionadapter" class="level2 unnumbered">
<h2>registerSubscriptionAdapter [registersubscriptionadapter]</h2>
<p>Функция используется для регистрации фабрики адаптеров&quot;=подписчиков (subscription adapter).</p>
<ul>
<li><p>Модуль: <code>zope.component - IComponentRegistry</code></p></li>
<li><p>Спецификация: <span><em>registerSubscriptionAdapter(factory, required=None, provides=None, name=u”, info=”)</em></span></p></li>
<li><p>Смотри также:</p></li>
</ul>
<p>Пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Interface
    <span class="im">from</span> zope.interface <span class="im">import</span> Attribute
    <span class="im">from</span> zope.interface <span class="im">import</span> implements

    <span class="kw">class</span> IValidate(Interface):
        <span class="kw">def</span> validate(ob):
            <span class="co">&quot;&quot;&quot;Determine whether the object is valid</span>

<span class="co">            Return a string describing a validation problem.</span>
<span class="co">            An empty string is returned to indicate that the</span>
<span class="co">            object is valid.</span>
<span class="co">            &quot;&quot;&quot;</span>

    <span class="kw">class</span> IDocument(Interface):
        summary <span class="op">=</span> Attribute(<span class="st">&quot;Document summary&quot;</span>)
        body <span class="op">=</span> Attribute(<span class="st">&quot;Document text&quot;</span>)

    <span class="kw">class</span> Document(<span class="bu">object</span>):
        implements(IDocument)
        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, summary, body):
            <span class="va">self</span>.summary, <span class="va">self</span>.body <span class="op">=</span> summary, body

    <span class="im">from</span> zope.component <span class="im">import</span> adapts

    <span class="kw">class</span> AdequateLength(<span class="bu">object</span>):

        adapts(IDocument)
        implements(IValidate)

        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, doc):
            <span class="va">self</span>.doc <span class="op">=</span> doc

        <span class="kw">def</span> validate(<span class="va">self</span>):
            <span class="cf">if</span> <span class="bu">len</span>(<span class="va">self</span>.doc.body) <span class="op">&lt;</span> <span class="dv">1000</span>:
                <span class="cf">return</span> <span class="st">&#39;too short&#39;</span>
            <span class="cf">else</span>:
                <span class="cf">return</span> <span class="st">&#39;&#39;</span>

    <span class="im">from</span> zope.component <span class="im">import</span> getGlobalSiteManager
    gsm <span class="op">=</span> getGlobalSiteManager()

    gsm.registerSubscriptionAdapter(AdequateLength)</code></pre></div>
</section>
<section id="registerutility-registerutility" class="level2 unnumbered">
<h2>registerUtility [registerutility]</h2>
<p>Функция позволяет зарегистрировать утилиту.</p>
<ul>
<li><p>Модуль: <code>zope.component - IComponentRegistry</code></p></li>
<li><p>Спецификация: <span><em>registerUtility(component, provided=None, name=u”, info=u”)</em></span></p></li>
<li><p>Смотри также:</p></li>
</ul>
<p>Пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Interface
    <span class="im">from</span> zope.interface <span class="im">import</span> implements

    <span class="kw">class</span> IGreeter(Interface):
        <span class="kw">def</span> greet(name):
            <span class="co">&quot;say hello&quot;</span>

    <span class="kw">class</span> Greeter(<span class="bu">object</span>):

        implements(IGreeter)

        <span class="kw">def</span> greet(<span class="va">self</span>, name):
            <span class="bu">print</span> <span class="st">&quot;Hello&quot;</span>, name

    <span class="im">from</span> zope.component <span class="im">import</span> getGlobalSiteManager
    gsm <span class="op">=</span> getGlobalSiteManager()

    greet <span class="op">=</span> Greeter()
    gsm.registerUtility(greet)</code></pre></div>
</section>
<section id="subscribers-subscribers" class="level2 unnumbered">
<h2>subscribers [subscribers]</h2>
<p>Функция позволяет получить перечень подписчиков (subscription adapter). Элементы перечня обслуживают заданный интерфейс (от которого они к тому же зависят). Перечень также определяется списком заданных объектов, переданных в функцию в качестве первого параметра.</p>
<ul>
<li><p>Модуль: <code>zope.component - IComponentRegistry</code></p></li>
<li><p>Спецификация: <span><em>subscribers(required, provided, context=None)</em></span></p></li>
</ul>
<p>Пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Interface
    <span class="im">from</span> zope.interface <span class="im">import</span> Attribute
    <span class="im">from</span> zope.interface <span class="im">import</span> implements

    <span class="kw">class</span> IValidate(Interface):
        <span class="kw">def</span> validate(ob):
            <span class="co">&quot;&quot;&quot;Determine whether the object is valid</span>

<span class="co">            Return a string describing a validation problem.</span>
<span class="co">            An empty string is returned to indicate that the</span>
<span class="co">            object is valid.</span>
<span class="co">            &quot;&quot;&quot;</span>

    <span class="kw">class</span> IDocument(Interface):
        summary <span class="op">=</span> Attribute(<span class="st">&quot;Document summary&quot;</span>)
        body <span class="op">=</span> Attribute(<span class="st">&quot;Document text&quot;</span>)

    <span class="kw">class</span> Document(<span class="bu">object</span>):
        implements(IDocument)
        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, summary, body):
            <span class="va">self</span>.summary, <span class="va">self</span>.body <span class="op">=</span> summary, body

    <span class="im">from</span> zope.component <span class="im">import</span> adapts

    <span class="kw">class</span> SingleLineSummary:
        adapts(IDocument)
        implements(IValidate)

        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, doc):
            <span class="va">self</span>.doc <span class="op">=</span> doc

        <span class="kw">def</span> validate(<span class="va">self</span>):
            <span class="cf">if</span> <span class="st">&#39;text</span><span class="ch">\n</span><span class="st">&#39;</span> <span class="kw">in</span> <span class="va">self</span>.doc.summary:
                <span class="cf">return</span> <span class="st">&#39;Summary should only have one line&#39;</span>
            <span class="cf">else</span>:
                <span class="cf">return</span> <span class="st">&#39;&#39;</span>

    <span class="kw">class</span> AdequateLength(<span class="bu">object</span>):
        adapts(IDocument)
        implements(IValidate)

        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, doc):
            <span class="va">self</span>.doc <span class="op">=</span> doc

        <span class="kw">def</span> validate(<span class="va">self</span>):
            <span class="cf">if</span> <span class="bu">len</span>(<span class="va">self</span>.doc.body) <span class="op">&lt;</span> <span class="dv">1000</span>:
                <span class="cf">return</span> <span class="st">&#39;too short&#39;</span>
            <span class="cf">else</span>:
                <span class="cf">return</span> <span class="st">&#39;&#39;</span>

    <span class="im">from</span> zope.component <span class="im">import</span> getGlobalSiteManager
    gsm <span class="op">=</span> getGlobalSiteManager()

    gsm.registerSubscriptionAdapter(SingleLineSummary)
    gsm.registerSubscriptionAdapter(AdequateLength)

    <span class="im">from</span> zope.component <span class="im">import</span> subscribers

    doc <span class="op">=</span> Document(<span class="st">&quot;A text</span><span class="ch">\n</span><span class="st">Document&quot;</span>, <span class="st">&quot;blah&quot;</span>)
    [adapter.validate()
     <span class="cf">for</span> adapter <span class="kw">in</span> subscribers([doc], IValidate)
     <span class="cf">if</span> adapter.validate()]
[<span class="st">&#39;Summary should only have one line&#39;</span>, <span class="st">&#39;too short&#39;</span>]

    doc <span class="op">=</span> Document(<span class="st">&quot;A text</span><span class="ch">\n</span><span class="st">Document&quot;</span>, <span class="st">&quot;blah&quot;</span> <span class="op">*</span> <span class="dv">1000</span>)
    [adapter.validate()
     <span class="cf">for</span> adapter <span class="kw">in</span> subscribers([doc], IValidate)
     <span class="cf">if</span> adapter.validate()]
[<span class="st">&#39;Summary should only have one line&#39;</span>]

    doc <span class="op">=</span> Document(<span class="st">&quot;A Document&quot;</span>, <span class="st">&quot;blah&quot;</span>)
    [adapter.validate()
     <span class="cf">for</span> adapter <span class="kw">in</span> subscribers([doc], IValidate)
     <span class="cf">if</span> adapter.validate()]
[<span class="st">&#39;too short&#39;</span>]</code></pre></div>
</section>
<section id="unregisteradapter-unregisteradapter" class="level2 unnumbered">
<h2>unregisterAdapter [unregisteradapter]</h2>
<p>Функция используется для отмены регистрации фабрики адаптеров. Возвращается значение типа <span><em>boolean</em></span>. Если после выполнения операции состояние регистратора изменилось, то возвращается <span><em>истина</em></span>. Значение <span><em>ложь</em></span> возвращается, если параметр равен <span><em>None</em></span> или компонента не было зарегистрирована.</p>
<ul>
<li><p>Модуль: <code>zope.component - IComponentRegistry</code></p></li>
<li><p>Спецификация: <span><em>unregisterAdapter(factory=None, required=None, provided=None, name=u”)</em></span></p></li>
<li><p>Смотри также:</p></li>
</ul>
<p>Пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Attribute
    <span class="im">from</span> zope.interface <span class="im">import</span> Interface

    <span class="kw">class</span> IDesk(Interface):
        <span class="co">&quot;&quot;&quot;A frontdesk will register object&#39;s details&quot;&quot;&quot;</span>

        <span class="kw">def</span> register():
            <span class="co">&quot;&quot;&quot;Register object&#39;s details&quot;&quot;&quot;</span>


    <span class="im">from</span> zope.interface <span class="im">import</span> implements
    <span class="im">from</span> zope.component <span class="im">import</span> adapts

    <span class="kw">class</span> FrontDeskNG(<span class="bu">object</span>):

        implements(IDesk)
        adapts(IGuest)

        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, guest):
            <span class="va">self</span>.guest <span class="op">=</span> guest

        <span class="kw">def</span> register(<span class="va">self</span>):
            next_id <span class="op">=</span> get_next_id()
            bookings_db[next_id] <span class="op">=</span> {
            <span class="st">&#39;name&#39;</span>: guest.name,
            <span class="st">&#39;place&#39;</span>: guest.place,
            <span class="st">&#39;phone&#39;</span>: guest.phone
            }

    <span class="kw">class</span> Guest(<span class="bu">object</span>):

        implements(IGuest)

        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, name, place):
            <span class="va">self</span>.name <span class="op">=</span> name
            <span class="va">self</span>.place <span class="op">=</span> place

    jack <span class="op">=</span> Guest(<span class="st">&quot;Jack&quot;</span>, <span class="st">&quot;Bangalore&quot;</span>)
    jack_frontdesk <span class="op">=</span> FrontDeskNG(jack)

    IDesk.providedBy(jack_frontdesk)
<span class="va">True</span>

    <span class="im">from</span> zope.component <span class="im">import</span> getGlobalSiteManager
    gsm <span class="op">=</span> getGlobalSiteManager()
    gsm.registerAdapter(FrontDeskNG,
                        (IGuest,), IDesk, <span class="st">&#39;ng6&#39;</span>)

Результат проверяется следующим образом:

    queryAdapter(jack, IDesk, <span class="st">&#39;ng6&#39;</span>)
<span class="op">&lt;</span>FrontDeskNG <span class="bu">object</span> at ...<span class="op">&gt;</span>

Теперь отменяем регистрацию:

    gsm.unregisterAdapter(FrontDeskNG, name<span class="op">=</span><span class="st">&#39;ng6&#39;</span>)
<span class="va">True</span>

После отмены регистрации имеем:

    <span class="bu">print</span> queryAdapter(jack, IDesk, <span class="st">&#39;ng6&#39;</span>)
<span class="va">None</span></code></pre></div>
</section>
<section id="unregisterhandler-unregisterhandler" class="level2 unnumbered">
<h2>unregisterHandler [unregisterhandler]</h2>
<p>Функция отменяет регистрацию обработчика (handler). Возвращается значение типа <span><em>boolean</em></span>. Если после выполнения операции состояние регистратора изменилось, то возвращается <span><em>истина</em></span>.</p>
<ul>
<li><p>Модуль: <code>zope.component - IComponentRegistry</code></p></li>
<li><p>Спецификация: <span><em>unregisterHandler(handler=None, required=None, name=u”)</em></span></p></li>
<li><p>Смотри также:</p></li>
</ul>
<p>Пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Interface
    <span class="im">from</span> zope.interface <span class="im">import</span> Attribute
    <span class="im">from</span> zope.interface <span class="im">import</span> implements

    <span class="kw">class</span> IDocument(Interface):

        summary <span class="op">=</span> Attribute(<span class="st">&quot;Document summary&quot;</span>)
        body <span class="op">=</span> Attribute(<span class="st">&quot;Document text&quot;</span>)

    <span class="kw">class</span> Document(<span class="bu">object</span>):

        implements(IDocument)
        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, summary, body):
            <span class="va">self</span>.summary, <span class="va">self</span>.body <span class="op">=</span> summary, body

    doc <span class="op">=</span> Document(<span class="st">&quot;A text</span><span class="ch">\n</span><span class="st">Document&quot;</span>, <span class="st">&quot;blah&quot;</span>)

    <span class="kw">class</span> IDocumentAccessed(Interface):
        doc <span class="op">=</span> Attribute(<span class="st">&quot;The document that was accessed&quot;</span>)

    <span class="kw">class</span> DocumentAccessed(<span class="bu">object</span>):
        implements(IDocumentAccessed)

        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, doc):
            <span class="va">self</span>.doc <span class="op">=</span> doc
            <span class="va">self</span>.doc.count <span class="op">=</span> <span class="dv">0</span>

    <span class="im">from</span> zope.component <span class="im">import</span> adapter

    <span class="at">@adapter</span>(IDocumentAccessed)
    <span class="kw">def</span> documentAccessed(event):
        event.doc.count <span class="op">=</span> event.doc.count <span class="op">+</span> <span class="dv">1</span>

    <span class="im">from</span> zope.component <span class="im">import</span> getGlobalSiteManager
    gsm <span class="op">=</span> getGlobalSiteManager()

    gsm.registerHandler(documentAccessed)

    <span class="im">from</span> zope.component <span class="im">import</span> handle

    handle(DocumentAccessed(doc))
    doc.count
<span class="dv">1</span>

Now unregister:

    gsm.unregisterHandler(documentAccessed)
<span class="va">True</span>

After unregistration:

    handle(DocumentAccessed(doc))
    doc.count
<span class="dv">0</span></code></pre></div>
</section>
<section id="unregistersubscriptionadapter-unregistersubscriptionadapter" class="level2 unnumbered">
<h2>unregisterSubscriptionAdapter [unregistersubscriptionadapter]</h2>
<p>Функция используется для отмены регистрации фабрики подписчиков (subscription adapter). Возвращается значение типа <span><em>boolean</em></span>. Если после выполнения операции состояние регистратора изменилось, то возвращается <span><em>истина</em></span>.</p>
<ul>
<li><p>Модуль: <code>zope.component - IComponentRegistry</code></p></li>
<li><p>Спецификация: <span><em>unregisterSubscriptionAdapter(factory=None, required=None, provides=None, name=u”)</em></span></p></li>
<li><p>Смотри также:</p></li>
</ul>
<p>Пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Interface
    <span class="im">from</span> zope.interface <span class="im">import</span> Attribute
    <span class="im">from</span> zope.interface <span class="im">import</span> implements

    <span class="kw">class</span> IValidate(Interface):
        <span class="kw">def</span> validate(ob):
            <span class="co">&quot;&quot;&quot;Determine whether the object is valid</span>

<span class="co">            Return a string describing a validation problem.</span>
<span class="co">            An empty string is returned to indicate that the</span>
<span class="co">            object is valid.</span>
<span class="co">            &quot;&quot;&quot;</span>

    <span class="kw">class</span> IDocument(Interface):
        summary <span class="op">=</span> Attribute(<span class="st">&quot;Document summary&quot;</span>)
        body <span class="op">=</span> Attribute(<span class="st">&quot;Document text&quot;</span>)

    <span class="kw">class</span> Document(<span class="bu">object</span>):
        implements(IDocument)
        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, summary, body):
            <span class="va">self</span>.summary, <span class="va">self</span>.body <span class="op">=</span> summary, body

    <span class="im">from</span> zope.component <span class="im">import</span> adapts

    <span class="kw">class</span> AdequateLength(<span class="bu">object</span>):

        adapts(IDocument)
        implements(IValidate)

        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, doc):
            <span class="va">self</span>.doc <span class="op">=</span> doc

        <span class="kw">def</span> validate(<span class="va">self</span>):
            <span class="cf">if</span> <span class="bu">len</span>(<span class="va">self</span>.doc.body) <span class="op">&lt;</span> <span class="dv">1000</span>:
                <span class="cf">return</span> <span class="st">&#39;too short&#39;</span>
            <span class="cf">else</span>:
                <span class="cf">return</span> <span class="st">&#39;&#39;</span>

    <span class="im">from</span> zope.component <span class="im">import</span> getGlobalSiteManager
    gsm <span class="op">=</span> getGlobalSiteManager()

    gsm.registerSubscriptionAdapter(AdequateLength)

    <span class="im">from</span> zope.component <span class="im">import</span> subscribers

    doc <span class="op">=</span> Document(<span class="st">&quot;A text</span><span class="ch">\n</span><span class="st">Document&quot;</span>, <span class="st">&quot;blah&quot;</span>)
    [adapter.validate()
     <span class="cf">for</span> adapter <span class="kw">in</span> subscribers([doc], IValidate)
     <span class="cf">if</span> adapter.validate()]
[<span class="st">&#39;too short&#39;</span>]

Теперь отменяем регистрацию:

    gsm.unregisterSubscriptionAdapter(AdequateLength)
<span class="va">True</span>

После отмены регистрации:

    [adapter.validate()
     <span class="cf">for</span> adapter <span class="kw">in</span> subscribers([doc], IValidate)
     <span class="cf">if</span> adapter.validate()]
[]</code></pre></div>
</section>
<section id="unregisterutility-unregisterutility" class="level2 unnumbered">
<h2>unregisterUtility [unregisterutility]</h2>
<p>Функция используется для отмены регистрации утилиты. Возвращается значение типа <span><em>boolean</em></span>. Если после выполнения операции состояние регистратора изменилось, то возвращается <span><em>истина</em></span>. Значение <span><em>ложь</em></span> возвращается, если параметр равен <span><em>None</em></span> или утилита не была зарегистрирована.</p>
<ul>
<li><p>Модуль: <code>zope.component - IComponentRegistry</code></p></li>
<li><p>Спецификация: <span><em>unregisterUtility(component=None, provided=None, name=u”)</em></span></p></li>
<li><p>Смотри также:</p></li>
</ul>
<p>Пример:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="im">from</span> zope.interface <span class="im">import</span> Interface
    <span class="im">from</span> zope.interface <span class="im">import</span> implements

    <span class="kw">class</span> IGreeter(Interface):
        <span class="kw">def</span> greet(name):
            <span class="co">&quot;say hello&quot;</span>

    <span class="kw">class</span> Greeter(<span class="bu">object</span>):

        implements(IGreeter)

        <span class="kw">def</span> greet(<span class="va">self</span>, name):
            <span class="cf">return</span> <span class="st">&quot;Hello &quot;</span> <span class="op">+</span> name

    <span class="im">from</span> zope.component <span class="im">import</span> getGlobalSiteManager
    gsm <span class="op">=</span> getGlobalSiteManager()

    greet <span class="op">=</span> Greeter()
    gsm.registerUtility(greet)

    queryUtility(IGreeter).greet(<span class="st">&#39;Jack&#39;</span>)
<span class="co">&#39;Hello Jack&#39;</span>

Теперь отменяем регистрацию:

    gsm.unregisterUtility(greet)
<span class="va">True</span>

После отмены регистрации имеем:

    <span class="bu">print</span> queryUtility(IGreeter)
<span class="va">None</span></code></pre></div>
</section>
<section id="sec:present" class="level2">
<h2><span class="header-section-number">12.1</span> Современные компонентные архитектуры</h2>
<p>Замечание об использовании интерфейсов в Go <a href="https://tour.golang.org/methods/5" class="uri">https://tour.golang.org/methods/5</a>.</p>
<p><span><strong>Черкашин</strong> Евгений Александрович<br />
</span> <span><strong>Байджу</strong> Мутхукадан<br />
</span> <span><strong>Компонентное программирование в Python</strong></span><br />
ISBN 978-5-XXXXX-XXXX-X</p>
<p>Редактор <em>Е. А. Черкашин</em><br />
Верстка <em>Е. А. Черкашин</em></p>
<p>Темплан 2016г. Поз.186</p>
<p>Подписано в печать 28.12.2016. Формат 60<span class="math inline">\(\times\)</span>90 1/16.<br />
Уч.-изд.л.6,4. Усл.печ.л. 6,8. Тираж 100 экз. Заказ 170</p>
<p>Издательство ИРНИТУ<br />
664074, г.Иркутск, ул. Лермонтова, 83 [lastpage]</p>
</section>
</section>
</body>
</html>
